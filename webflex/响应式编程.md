# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241126091852663](.\images\image-20241126091852663.png)



**响应延迟**

传统命令式编程的另一个问题是：当一个服务需要做很多操作而不仅仅是IO请求的时候，响应延迟相应的增大。

如服务A需要调用服务B和服务C，比如查询数据库，聚合结果并返回。意味着服务A的响应时间包括：

- 服务B的响应时间（网络延迟时间+处理时间）
- 服务C的响应时间（网络延迟时间+处理时间）
- 数据请求响应时间（网络延迟时间+处理时间）



![image-20241126091817119](.\images\image-20241126091817119.png)

如果服务调用没有前后依赖关系，则可以并行调用服务，如果使用java的CompletableFuture异步调用并注册回调，开发会复杂很多，而且阅读和维护也会复杂很多。



**压垮客户端**

微服务另外一个问题就是：服务A请求服务B的数据，如果数据量非常的时候，超过了服务A能处理的程度，则会导致服务OOM。



**总结**

这些问题都是响应式编程要解决的。

优势：

- 不用Thread per Request模型，使用少量线程即可处理大量的请求。
- 在执行IO操作时不让线程等待。
- 简化并行调用。
- 支持背压，让客户端告诉服务端它能处理多少负载。

### 1.1.1  消息驱动通信

响应式编程的定义

响应式编程使用异步、事件驱动构建非阻塞式应用的。此类应用仅需少量的线程用于横向扩展。

该定义的关键一点是：借助背压技术，防止生产者压垮消费者。

**怎么做？**

答案就是使用异步数据流编程。

如果服务A需要从服务B获取数据。对于响应式编程，服务A向服务B发起请求，并立即返回（非阻塞异步）。

之后请求的数据以数据流的方式返回给服务A，服务B对每个数据项发布onNext事件，当所有的数据都发布了OnNext事件，就发布OnComplete事件结束，如果发生异常，服务B就发布OnError事件，之后不再发布OnNext事件。

![image-20241126093315691](.\images\image-20241126093315691.png)

响应式编程使用函数式编程风格，用于对数据流进行不同的转换。

流可以作为输入，也可以合并，映射和过滤等。

**响应式系统**

响应式系统的设计目标：

- 响应性（以时序的方式响应）
- 健壮（即使发生错误也可以保证响应性）
- 弹性（在不同的工作负载下保持响应性）
- 消息驱动（依赖异步消息传递机制）

响应式编程可以确保单个服务的异步非阻塞，整个系统的响应式需要整体考滤。



### 1.2 响应式应用案例

**响应式编程是使用异步数据流进行编程**

流是一个时序事件序列，可以发送三种不同的事件：（某种类型的）值 、错误或者一个完成信号。

分为值、错误、完成定义事件的函数，异步的处理事件。

监听一个流称为订阅，定义的函数称为观察者，流是被观察者，即观察者模式。

每个流会有多个方法，如map、filter、scan等等。

当调用其中一个方法时，它会基于原来的流返回一个新的流。

它不对原来的点击流做任何的修改，这个特性称为不变性，也可以称为方法链式调用。

```sh
clickStream:  ---c---c--c---c------c-->
              vvvv map(c becomes 1)vvvv
              ---c---c--c---c------c-->
              vvvvvvvvv scan(+) vvvvvvvv
counterstream:---1---2--3---4------5-->
```

map(f) 会根据提供的f函数把原来Stream中的Value分别映射到新的Stream中

scan(g) 会根据你提供的G函数把Stream中的所有Value聚合成一个Value x=g(sccumulated,current)

每click一次，countStream就会把点击的总次数发送给它的观察者。



### 1.3 响应式编程的现状

2011年，微软发布了.NET的响应式扩展，以方便异步、事件驱动的程序。

ReactiveX混合了迭代器和观察者模式，不同之处在于一个是推模式，一个是基于迭代器的拉模式。

除了对变化事件的观察，完成事件和异常事件也会发送给订阅者。

ReactiveX的基本思想是事件是数据，数据是事件。

响应式扩展被移植到了几种语言和平台上，包括 javascript、Python、C++、swift和java、ReactiveX很快成为一种跨语言的标准，将响应式编程引入到行业中。

RxJava，是java的ReactiveX实现。

RxJava是其他reactivex jvm平台技术的主要技术，其他的如RxScala、RxKotlin、RxGroovy。RxJava已经碾为Android开发的核心技术，并且可以开箱即用的使用RxJava。

这表明RxJava不仅仅是一个库，它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。



### 1.4 为什么采用响应式Spring？

响应式系统非常的复杂，在构建这类系统时困难也非常的多。

要轻松构建响应式系统，就必须首先分析能够构建这类系统的框架，然后选择其中之一。

选择框架最常用的方法之一是分析其可用功能，相关性及社区。

在JVM领域，构建响应式系统最知名的框架是Akka和vert.x生态系统。

一方面,Akka是一个受欢迎的框架，具有大量功能和大型社区，然后，Akka最初是作为Scala生态系统的一部分构建的，在很长一段时间内，它仅在基于Scala编写的解决方法中展示它强大的功能，尽管Scala是一种基于JVM的语言，但它与JAVA明显不同，几年前，Akka直接支持java，但是出于某些原因，它在java世界中不像在Scala世界中那么受欢迎。

另一方法，Vert.x框架也是构建高效响应式系统的强大解决方案，Vert.x的设计初衷是作为Node.js在java虚拟机上的替代方法，它支持非阻塞和事件驱动。然后，Vert.x仅在几年前开始具备竞争力，在过去的15年中，Spring框架一直在构建灵活且健状的应用程序框架市场中占有主导地位。

Spring框架使用适合开发人员的编程模型，为构建Web应用程序提供了广泛的可能性，然后长期以来，它在构建健状的响应式系统方法存在一个局限。

Spring框架在一个单独的线程中包装了阻塞式网络调用，同时Spring MVC依赖于Servlet API ，这使得所有的实现必须使用线程的单次请求（thread-per-request)模型。

这种模型非常不理想，效率低下。

为此，响应式规则建议使用非阻塞的操作，但这是Spring生态系统缺少的。此外Spring也没有与Netty等响应式服务器进行良好的集成，而这些响应式服务器解决了上下文切换的问题。

## 2 无处不在的响应性

### 2.1 API不一致的问题

大量的同类弄响应式可供选择（RxJava、CompletableStage、Vert.x、Akka）

另外一方面，丰富的选择很容易使得系统过于复杂。例如，若存在两个依赖于同一个异步非阻塞通信概念但具有不同的API的库，会导致 我们需要提供额外的工具类，以便将一个回调转换为另外一个回调，反之亦然。

Spring4.x框架中的ListenableFuture和CompletionStage之间没有直接集成 。

在许多情况下，为了解决几个问题并使得几个独立的库兼容，必须提供自己的适配并在几个地方重用。

自己写的适配可能bug。需要额外的维护。

Spring5.x框架扩展了ListenableFuture的API并且提供了一个Completable的方法来解决不兼容的问题。

这里的核心 问题在于没有标准。



### 2.2 推拉

在整个响应式环境演变的早期阶段，所有库的设计思想都是把数据从源头推送到订阅者。

因为纯粹的拉模型在某些场景下效率不够高。

拉模型

![image-20241126222758306](.\images\image-20241126222758306.png)

问题：

处理时间方面，仍然存在一些效率低下的情况。

发送一批元素比发送一个元素需要更多的时间。

为了提供最终的优化，只会请求一次数据，当数据变为可用时，该数据源异步推送数据。

![image-20241126223017360](.\images\image-20241126223017360.png)

再次对整体处理时间做了优化。在交互过程中，只有当服务等待每个响应时会有大段空间时间，当第一个元素到达后，数据库会在数据到达时开始发送后续元素。



### 2.3 流量控制问题

在生产者与消费者的处理过程中，会存在两边处理速度不一致的问题。两种场景：

1. 慢生产者和快消费者。
2. 快生产者和慢消费者。

使用队列推送数据的关键要素之一是选择有合适特性的队列 

通常有3种。无界队列、有界丢序队列、有限阻塞队列。

**无界队列**

![image-20241126223504790](.\images\image-20241126223504790.png)

此队列的最大问题在于，一旦到达内存上限，整个系统就很容易崩溃。

**有界丢弃队列**

![image-20241126223629051](.\images\image-20241126223629051.png)

此技术考滤了资源的限制，并且可以根据资源的能力配制队列的容易，当消息的重要性很低时，采用这种队列是一种常见的做法。

**有界阻塞队列**

![image-20241126223917359](.\images\image-20241126223917359.png)

遗憾的是这种技术否定了系统的所有异步的行为。通常一旦生产者到达队列的限制。它就会开始被阻塞并将处理该状态，直接消费者消费了一个元素，从而使队列中出现可用空间为止，由此我们可以得出结论，最慢的消费者的吞吐率限制了系统总吞吐量。继而，除了否定异步行为了该技术还否定了有效的资源利用率，因此想要实现回弹性、弹性和即时响应所有的三方法，那么这些场景会部不可接受。





### 2.4 解决方法

来自 Lightbend、Netflix 和 Pivotal 的一群天才工程师齐聚一堂，共同解决上述问题 并为 JVM 社区提供标准。 

经过长达一年的努力，响应式流规范的初稿公诸于世。

其概念就是响应式编程模式的标准化。



## 3 响应式流规范

### 3.1 响应式流规范基础

响应式流规范网站：

```sh
http://www.reactive-streams.org
```

响应式规则发布了一组接口，用于实现：

maven地址:

```xml
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck-flow</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-examples</artifactId>
  <version>1.0.3</version>
</dependency>
```

响应式流规范文档

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
```

**响应式流规范**

响应式流（Reactive Streams）规范，规定了异步组件之前使用背压进行交互。

响应式流在java 9中使用flow API适配。Flow API是互操作的规范，而不是具体的实现，它的主义跟响应式流规范一致。

响应式流规范包括如下接口

**Publisher**

表示数据流的生产者或者数据源，包含一个方法让订阅者注册 到发布者，Puhblisher代表了发布者和订阅者直接连接的标准化入口点。

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```



**Subscriber**

表示消费者，onSubscriber方法为我们提供了一种标准化的方法来通知Subscriber订阅成功。

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- onSubscribe发布者在开始处理之前调用，并向订阅者传递一个订阅票据对象（Subscription).
- onNext 用于通知订阅者发布者发布了新的数据项。
- onError 用于通知订阅者，发布者遇到了异常，不再发布数据事件。
- onComplete 用于通知订阅者所有的数据事件都已经发布完。

**Subscription**

onSubscribe方法的传入参数引入一名为Subscription(订阅)的订阅票据。

Subscription为控制元素的生产提供了基础。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- request 用于让订阅者通知发布者随后 需要发布的元素数量。
- cancel 用于让订阅者取消发布者随后的事件流。

**Processor**

如果实体需要转换进来的项目，并将转换后的项目传递给另一个订阅者，此时需要Processor接口。该接口既是订阅者，又是发布者。

```xml
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```



### 3.2 响应式流规范实战

地址：

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification
```

添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

异步发布者

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Publisher的实现，用于进行数据的生产操作，可以理解为要加工的数据
 *
 * @author nullnull
 * @since 2023/6/27
 */
public class AsyncIterablePublisher<T> implements Publisher<T> {


    /**
     * 默认的批次大小
     */
    private static final int DEFAULT_BATCH_SIZE = 1024;

    /**
     * 迭代器，用于原始数据的生成操作
     */
    private final Iterable<T> iterable;

    /**
     * 线程池接口，用于生成任务的并行执行
     */
    private final Executor executor;

    /**
     * 用于批次处理任务的大小
     */
    private final int batchSize;


    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor) {
        this(iterable, executor, DEFAULT_BATCH_SIZE);
    }

    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor, int batchSize) {
        //进行参数的检查
        if (null == iterable) {
            throw new NullPointerException("iterable is null");
        }

        if (null == executor) {
            throw new NullPointerException("executor is null");
        }

        if (batchSize < 1) {
            throw new IllegalArgumentException("param batch size is < 1");
        }


        this.iterable = iterable;
        this.executor = executor;
        this.batchSize = batchSize;
    }

    @Override
    public void subscribe(Subscriber<? super T> s) {
        new SubscriberImpl(s).init();
    }


    /**
     * 用于处理订阅的信号
     */
    static interface Signal {
    }

    /**
     * 取消订阅的信号
     */
    enum Cancel implements Signal {
        Instance;
    }

    /**
     * 订阅的信号
     */
    enum Subscribe implements Signal {
        Instance;
    }

    /**
     * 发送的信号
     */
    enum Send implements Signal {
        Instance;
    }

    /**
     * 请求的信号
     */
    static final class Request implements Signal {
        final long n;

        public Request(long n) {
            this.n = n;
        }
    }

    /**
     * 订阅票据，实现了Subscription接口和Runnable接口
     */
    final class SubscriberImpl implements Subscription, Runnable {

        /**
         * Subscriber的引用，用于通信
         */
        private final Subscriber<? super T> subscriber;

        /**
         * 该订阅票据是否失效的标志
         */
        private boolean cancelled = false;

        /**
         * 记录订阅者的数量，这些请求还没有对订阅者回复
         */
        private long demand = 0;

        /**
         * 发送给订阅者的数据流
         */
        private Iterator<T> iterator;

        /**
         * 该队列用于记录发送票据的信号（入栈信号），如"request"，"cancel"等。
         * <p>
         * 通过此队列可以在Publisher端使用多线程异步处理
         */
        private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


        /**
         * 确保票据不会并发的标志，
         * <p>
         * 防止在调用订阅者的onXxx方法的时候并发调用。规范1.3规定的不能并发。
         */
        private final AtomicBoolean on = new AtomicBoolean(false);

        public SubscriberImpl(Subscriber<? super T> subscriber) {
            //根据规范，如果Subscriber为null，需要抛空指针异常，此处抛null。
            if (null == subscriber) {
                throw null;
            }

            this.subscriber = subscriber;
        }


        private void doRequest(int n) {
            // 规范规定，如果请求的元素个数小于1，则抛异常
            // 并在异常信息中指明错误的原因：n必须是正整数。
            if (n < 1) {
                terminateDueTo(new IllegalArgumentException(subscriber
                        + "violated the Reactive Streams rule 3.9 by requesting a non -positive number of elements."));
            }
            // 根据规范 3.17，当请求的元素数大于Long.MAX_VALUE的时候，将请求数  设置为Long.MAX_VALUE即可。
            else if (demand + n < 1) {
                //此认为是无界流
                demand = Long.MAX_VALUE;
                //开始向下游发送元素
                doSend();
            }
            //其他情况，表示当前是设置了正常请求数量
            else {
                //记录下请求个数的元素
                demand += n;
                //开始向下游发送元素
                doSend();
            }
        }


        private void doSend() {
            try {
                long leftBatchSize = batchSize;
                //为充分利用线程池，最多发送BatchSize个元素。然后放弃当前线程，重新调度，通知订阅者onNext信号
                do {
                    T next;
                    boolean hashNext;

                    try {
                        //订阅者在订阅的时候，已经调用了hashNext方法，直接获取
                        // Need to keep track of End-of-Stream
                        next = iterator.next();
                        //检查还有没有数据，如果没有了，表示流结束了
                        hashNext = iterator.hasNext();
                    } catch (final Throwable e) {
                        // If `next` or `hasNext` throws (they can, since  it is user - provided),we need to treat
                        // the stream as errored as per rule1.4

                        //如果next方法或者hashNext方法抛出异常（用户提供），认为流招聘了异常了发送onError信号
                        terminateDueTo(e);

                        return;
                    }

                    //向下流订阅者发送next的信号
                    subscriber.onNext(next);

                    //如果已经到达结束位置，
                    if (!hashNext) {
                        // We need to consider this `Subscription` as cancelled as per rule 1.6
                        // 首先考滤票据取消了订阅
                        doCancel();

                        // Then we signal `onComplete` as per rule 1.2 and    1.5
                        //发送onComplete信号给订阅者
                        subscriber.onComplete();
                    }

                } while (
                    //确保当前没有被取消订阅
                    // This makes  sure that rule 1.8 is upheld,
                    // i.e.we need to stop signalling "eventually"
                        !cancelled
                                //并且还有剩余的元素
                                // 如果还有剩余批次的元素。This   makes sure that we only send
                                // `batchSize`number of elements in one go (so  we can yield to other Runnables)
                                && --leftBatchSize > 0
                                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)
                                && --demand > 0);


                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)

                // If the `Subscription` is still alive and well,
                // and we have demand to satisfy, we signal ourselves to send more data

                // 如果订阅票据没有取消，还有请求，通知自己发送更多的数据
                if (!cancelled && demand > 0)
                    signal(Send.Instance);

            } catch (Throwable t) {

                // We can only get here if `onNext` or `onComplete` threw,
                // and they are not allowed to according to 2.13,
                // so we can only cancel and log here.

                // 如果到这里，只能是onNext或onComplete抛异常，只能取消。

                // Make sure that we are cancelled,
                // since we cannot do   anything else since the `Subscriber`is faulty.

                // 确保已取消，因为是Subscriber的问题
                doCancel();

                // 记录错误信息
                (new IllegalStateException(subscriber
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onNext or "
                        + "onComplete. ", t))
                        .printStackTrace(System.err);
            }
        }


        /**
         * 异常给认
         *
         * @param signal
         */
        private void signal(final Signal signal) {
            //将信号放入入栈队列
            if (inboundSignals.offer(signal)) {
                //信号放入线程成功，则调度线程进行处理
                tryScheduleToExecute();
            }
        }

        /**
         * 该方法确保订阅票据同一个时间在同一个线程运行
         * <p>
         * 规范1.3规定，调用`Subscriber`的`onSubscribe`，`onNext`，`onError`和 `onComplete`方法必须串行，不允许并发。
         */
        private final void tryScheduleToExecute() {

            // 使用原子变量进行CAS操作，成功，是说明当前线程可以处理，失败表示已经在处理了
            if (on.compareAndSet(false, true)) {
                try {
                    //向线程池中提交一个任务
                    executor.execute(this);
                    //如果不能提交线程池运行，则优雅的退出
                } catch (Throwable e) {
                    if (!cancelled) {
                        //错误不可恢复，执行取消订阅
                        doCancel();
                        try {
                            // 停止,发送error信号
                            terminateDueTo(new
                                    IllegalStateException("Publisher terminated due to unavailable Executor.",
                                    e));
                        } finally {
                            // 后续的入站信号不需要处理了，清空信号
                            inboundSignals.clear();
                            // 取消当前订阅票据，但是让该票据处于可调度状态，以防清空入站信号之后又有入站信号加入。  异步订阅者：
                            on.set(false);

                        }

                    }

                }
            }

        }


        /**
         * 规范3.5指明，Subscription.cancel方法必须及时的返回，保持调用者的响应性， 还必须是幂等的，必须是线程安全的。
         * <p>
         * 因此该方法不能执行密集的计算。
         */
        private void doCancel() {
            cancelled = true;
        }


        /**
         * 终止订阅，
         * <p>
         * 规范1.6指出，`Publisher`在通知订阅者`onError`或者`onComplete`信号之
         * 前，
         * <p>
         * **必须**先取消订阅者的订阅票据（`Subscription`）。
         * <p>
         * <p>
         * <p>
         * 当发送onError信号之前先取消订阅
         *
         * @param exception
         */
        private void terminateDueTo(Throwable exception) {
            //发送error前，必须取消订阅
            cancelled = true;

            try {
                //给下游发送onError信号
                subscriber.onError(exception);
            } catch (Throwable e) {
                // 规范1.9指出，onError不能抛异常。
                // 如果onError抛异常，只能记录信息。
                (new IllegalStateException(
                        subscriber +
                                "violated the  Reactive Streams rule 2.13 by throwing an exception from onError.", e))
                        .printStackTrace(System.err);
            }
        }


        @Override
        public void run() {
            // 与上次线程执行建立happens-before关系，防止并发执行
            // 如果on.get()为false，则不执行，线程退出
            // 如果on.get()为false，则表示没有线程在执行，当前线程可以执行
            if (on.get()) {
                //1,从队列中取出一个信号
                Signal poll = inboundSignals.poll();
                // 规范1.8：如果`Subscription`被取消了，则必须最终停止向`Subscriber`发送通知。
                // 规范3.6：如果取消了`Subscription`，则随后调用`Subscription.request( long n)`必须是无效的（NOPs）。
                // 如果订阅票据没有取消
                if (!cancelled) {
                    try {
                        //根据信号进行方法的处理操作
                        // 请求
                        if (poll instanceof Request) {
                            doRequest((int) ((Request) poll).n);
                        }
                        //发送信息
                        if (poll == Send.Instance) {
                            doSend();
                        }
                        //取消信号
                        if (poll == Cancel.Instance) {
                            doCancel();
                        }
                        //订阅信号
                        if (poll == Subscribe.Instance) {
                            doSubscribe();
                        }
                    } finally {
                        // 保证与下一个线程调度的happens-before关系
                        on.set(false);
                        //如果还有信号需要处理
                        if (!inboundSignals.isEmpty()) {
                            // 调度当前线程进行处理
                            tryScheduleToExecute();
                        }
                    }

                }
            }


        }

        /**
         * 不是在`Publisher.subscribe`方法中同步地调用`subscriber.onSubscribe` 方法，而是异步地执行subscriber.onSubscribe方法
         * <p>
         * 这样可以避免在调用线程执行用户的代码。因为在订阅者的onSubscribe方法中要执行 Iterable.iterator方法。
         * <p>
         * 异步处理也无形中遵循了规范的1.9。
         */
        private void doSubscribe() {
            try {
                //获取数据源的迭代器
                iterator = iterable.iterator();

                if (iterator == null) {
                    // 如果iterator是null，就重置为空集合的迭代器。我们假设 iterator永远不是null值。
                    iterator = Collections.<T>emptyList().iterator();
                }
            } catch (Throwable e) {
                // Publisher发生了异常，此时需要通知订阅者onError信号。
                // 但是规范1.9指定了在通知订阅者其他信号之前，必须先通知订阅者  onSubscribe信号。
                // 因此，此处通知订阅者onSubscribe信号，发送空的订阅票据
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {
                        // 空的
                    }

                    @Override
                    public void cancel() {
                        // 空的
                    }
                });
                // 根据规范1.9，通知订阅者onError信号
                terminateDueTo(e);
            }

            if (!cancelled) {
                try {
                    // 为订阅者设置订阅票据。
                    subscriber.onSubscribe(this);
                } catch (Throwable e) {
                    // Publisher方法抛异常，此时需要通知订阅者onError信号。
                    // 但是根据规范2.13，通知订阅者onError信号之前必须先取消该订阅 者的订阅票据。
                    // Publisher记录下异常信息。
                    terminateDueTo(new IllegalStateException(subscriber
                            + "violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe. ",
                            e));
                }

                // 立即处理已经完成的迭代器
                boolean hashNext = false;
                try {
                    // 判断是否还有未发送的数据，如果没有，则向订阅者发送onComplete 信号
                    hashNext = iterator.hasNext();
                } catch (Throwable e) {
                    // 规范的1.4规定
                    // 如果hasNext发生异常，必须向订阅者发送onError信号，发送信号之  前先取消订阅
                    // 规范1.2规定，Publisher通过向订阅者通知onError或 onComplete信号，
                    // 发送少于订阅者请求的onNext信号。
                    terminateDueTo(e);
                }


                // 如果没有数据发送了，表示已经完成，直接发送onComplete信号终止订阅 票据。
                // 规范1.3规定，通知订阅者onXxx信号，必须串行，不能并发。
                if (!hashNext) {
                    try {
                        // 规范1.6指明，在通知订阅者onError或onComplete信号之   前，必须先取消订阅者的订阅票据。
                        // 在发送onComplete信号之前，考虑一下，有可能是  Subscription取消了订阅。
                        doCancel();
                        subscriber.onComplete();
                    } catch (final Throwable t) {
                        // 规范2.13指出，onComplete信号不允许抛异常，因此此处只能 记录下来日志
                        (new IllegalStateException(subscriber
                                + " violatedthe Reactive Streams rule 2.13 by throwing an exception from onComplete.",
                                t)).printStackTrace(System.err);
                    }
                }
            }

        }

        /**
         * 注册订阅者发送过来的信号
         *
         * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
         */
        @Override
        public void request(final long n) {
            signal(new Request(n));
        }


        @Override
        public void cancel() {
            signal(Cancel.Instance);
        }

        /**
         * init方法的设置，用于确保SubscriptionImpl实例在暴露给线程池之前已经构造完成
         * <p>
         * 因此，在构造器一完成，就调用该方法，仅调用一次。
         * <p>
         * 先发个信号试一下
         */
        void init() {
            signal(Subscribe.Instance);
        }
    }
```

异步订阅者

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 自定义订阅者信息
 * <p>
 * 基于Executor的异步运行的订阅者实现，一次请求一个元素，然后对每个元素调用用户定义的方
 * 法进行处理。
 * 注意：该类中使用了很多try-catch用于说明什么时候可以抛异常，什么时候不可以抛异常
 *
 * @author liujun
 * @since 2023/6/30
 */
public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {

    /**
     * Signal表示发布者和订阅者之间的异步协议
     */
    private static interface Signal {
    }

    /**
     * 表示数据流发送完成，完成信号
     */
    private enum OnComplete implements Signal {
        Instance;
    }

    /**
     * 错误信号
     */
    private static class OnError implements Signal {
        public final Throwable error;

        public OnError(Throwable error) {
            this.error = error;
        }
    }

    /**
     * 表示下一个数据项信号
     *
     * @param <T>
     */
    private static class OnNext<T> implements Signal {
        private T next;

        public OnNext(T next) {
            this.next = next;
        }
    }

    /**
     * 表示订阅者的订阅成功信号
     */
    private static class OnSubscribe implements Signal {
        private Subscription subscription;

        public OnSubscribe(Subscription subscription) {
            this.subscription = subscription;
        }
    }


    /**
     * 订阅单据,根据规范3.1，该引用是私有的
     */
    private Subscription subscription;

    /**
     * 用于表示当前的订阅者是否处理完成
     */
    private boolean done;

    /**
     * 根据规范的2.2条款，使用该线程池异步处理各个信号
     */
    private final Executor executor;


    /**
     * 存储信号的队列
     */
    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


    /**
     * 根据规范2.7和2.11，使用原子变量确保不会有多个订阅者线程并发执行。
     */
    private final AtomicBoolean on = new AtomicBoolean(false);


    /**
     * This method is invoked when the OnNext signals arrive
     * Returns whether more elements are desired or not, and if no more elements are   desired,
     * for convenience.
     *
     * @param element
     * @return
     */
    protected abstract boolean whenNext(final T element);

    /**
     * This method is invoked when the OnComplete signal arrives
     * override this method to implement your own custom onComplete logic.
     */
    protected void whenOnComplete() {
    }


    /**
     * This method is invoked if the OnError signal arrives
     * override this method to implement your own custom onError logic.
     */
    protected void whenOnError(Throwable e) {

    }


    /**
     * 仅有这一个构造器，只能被子类调用
     * 传递一个线程池即可
     *
     * @param executor
     */
    public AsyncSubscriber(Executor executor) {
        if (executor == null) {
            throw null;
        }
        this.executor = executor;
    }

    @Override
    public void run() {
        // 跟上次线程执行建立happens-before关系，防止多个线程并发执行
        if (on.get()) {
            try {
                //从队列中取出信号
                Signal poll = inboundSignals.poll();
                // 根据规范条款2.8，如果当前订阅者已完成，就不需要处理了。
                if (!done) {
                    //根据信号类型对应处理
                    if (poll instanceof OnNext) {
                        handleOnNext(((OnNext<T>) poll).next);
                    }
                    //订阅信号
                    else if (poll instanceof OnSubscribe) {
                        handleOnSubscribe(((OnSubscribe) poll).subscription);
                    }
                    //错误信号
                    else if (poll instanceof OnError) {
                        handleOnError(((OnError) poll).error);
                    }
                    //完成信号
                    else if (poll instanceof OnComplete) {
                        handleOnComplete();
                    }
                }
            } finally {
                //设置为false，让下一个线程可以调度。
                on.set(false);
                //队列中还存在数据，继续执行入队列信号
                if (!inboundSignals.isEmpty()) {
                    tryScheduleToExecute();
                }
            }
        }
    }

    /**
     * 调度放入线程池处理操作
     * 确保订阅者一次仅在一个线程执行
     */
    private void tryScheduleToExecute() {
        //原子CAS操作，将false改为true
        if (on.compareAndSet(false, true)) {
            try {
                //将任务提交线程池
                executor.execute(this);
            } catch (Throwable e) {
                // 根据规范条款2.13，如果不能执行线程池的提交方法，需要优雅退出
                if (!done) {
                    try {
                        // 由于错误不可恢复，因此取消订阅票据
                        done();
                    } finally {
                        //首先做队列的清空处理
                        inboundSignals.clear();
                        // 由于订阅票据已经取消，但是此处依然让订阅者处于可调度的状
                        //态，以防在清空入站信号之后又有信号发送过来
                        // 因为信号的发送是异步的
                        on.set(false);
                    }
                }
            }
        }
    }

    /**
     * 幂等地标记当前订阅者已完成处理，不再处理更多的元素。
     * 因此，需要取消订阅票据（Subscription）
     */
    private void done() {
        // 在此处，可以添加done，对订阅者的完成状态进行设置；
        // 虽然规范3.7规定Subscription.cancel()是幂等的，我们不需要这么做。
        // 当whenNext方法抛异常，认为订阅者已经处理完成（不再接收更多元素）
        done = true;
        // If we are bailing out before we got a `Subscription`there 's little need for cancelling it.
        if (subscription != null) {
            try {
                subscription.cancel();
            } catch (Throwable e) {
                // 根据规范条款3.15，此处不能抛异常，因此只是记录下来。
                (new IllegalStateException(subscription
                        + " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        e)).printStackTrace(System.err);
            }
        }
    }

    /**
     * Here it is important that we do not violate 2.2 and 2.3 by calling  methods on  the `Subscription`or `Publisher`
     * <p>
     * 完成信号处理
     */
    private void handleOnComplete() {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onError before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive  Streams rule 1.09 signalling onError prior "
                            + "to onSubscribe. ")).printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;

        //发送完成信号
        whenOnComplete();

    }

    /**
     * 错误信号处理
     *
     * @param error
     */
    private void handleOnError(Throwable error) {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onComplete before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe. "))
                    .printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;
        //发送错误信号
        whenOnError(error);
    }

    /**
     * 订阅信号处理
     *
     * @param subscriptionTmp
     */
    private void handleOnSubscribe(Subscription subscriptionTmp) {
        if (subscriptionTmp == null) {
            // Getting a null `Subscription` here is not valid so lets just  ignore it.
            return;
        }

        //如果上一个订阅还存在，则需进要对当前信号做取消处理
        if (subscription != null) {
            try {
                subscriptionTmp.cancel();
            } catch (final Throwable t) {
                //Subscription.cancel is not allowed to throw an exception, according to rule 3.15
                (new IllegalStateException(subscriptionTmp +
                        " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        t)).printStackTrace(System.err);
            }
            return;
        }


        //其他情况，表示正常，发送首个请求数据的信号
        subscription = subscriptionTmp;

        try {
            // If we want elements, according to rule 2.1 we need to
            //call `request`
            // And, according to rule 3.2 we are allowed to call this
            //synchronously from within the `onSubscribe`method
            subscription.request(1); // Our Subscriber is unbuffered and modest,
            //it requests one element at a time
        } catch (final Throwable t) {
            // Subscription.request is not allowed to throw according
            //to rule 3.16
            (new IllegalStateException(subscription
                    + " violated the Reactive Streams rule 3.16 by throwing an exception from request.",
                    t)).printStackTrace(System.err);
        }
    }

    /**
     * 处理数据
     *
     * @param element
     */
    private void handleOnNext(final T element) {
        // If we aren't already done
        if (done) {
            return;
        }
        // Technically this check is not
        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            //        // Check for spec violation of 2.1 and 1.09
            (new IllegalStateException(
                    "Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before  "
                            + "`Subscription.request`. (no Subscription)")).printStackTrace(System.err);
        }

        try {
            //如果数据还有下一条记录，则再次请求1条记录
            if (whenNext(element)) {
                try {
                    // Our Subscriber is
                    //unbuffered and modest, it requests one element at a time
                    subscription.request(1);
                } catch (Throwable e) {
                    // Subscription.request is not allowed to throw
                    //according to rule 3.16
                    (new IllegalStateException(subscription
                            + "violated the Reactive Streams rule 3.16 by throwing an exception from request."
                            + " ", e)).printStackTrace(System.err);
                }
            }
            //如果没有元素了，标识结束
            else {
                done();
            }
        } catch (Throwable e) {
            //当发生异常，标识当前完成
            done();
            //发送异常信息
            try {
                onError(e);
            } catch (Throwable ex) {
                //Subscriber.onError is not allowed to throw an
                //exception, according to rule 2.13
                (new IllegalStateException(this
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.",
                        ex)).printStackTrace(System.err);
            }

        }


    }

    @Override
    public void onSubscribe(Subscription s) {
        // As per rule 2.13, we need to throw a `java.lang.NullPointerException`if the `Subscription`is `null`
        if (s == null) {
            throw null;
        }
        signal(new OnSubscribe(s));
    }

    private void signal(Signal signal) {
        // 信号入站，线程池调度处理
        // 不需要检查是否为null，因为已经实例化了。
        if (inboundSignals.offer(signal)) {
            //放入执行调度，立即执行
            tryScheduleToExecute();
        }
    }

    @Override
    public void onNext(T t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `element`is `null`
        if (t == null) {
            throw null;
        }

        signal(new OnNext<>(t));
    }

    @Override
    public void onError(Throwable t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `Throwable`is `null`
        if (t == null) {
            throw null;
        }
        signal(new OnError(t));
    }

    @Override
    public void onComplete() {
        signal(OnComplete.Instance);
    }
}
```

单元测试

```java
import org.junit.Test;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class AsyncReactiveTest {

    @Test
    public void dataTest() throws InterruptedException {
        Set<Integer> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(i);
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<Integer> publisher
                = new AsyncIterablePublisher<>(elements, executorService);

        //同步订阅者的测试
        MySubscriber subscriberTmp = new MySubscriber();
        publisher.subscribe(subscriberTmp);


        ////异常订阅者的处理
        //final SelfSubscriber<Integer> subscriber = new SelfSubscriber<>
        //        (Executors.newFixedThreadPool(2)) {
        //    @Override
        //    protected boolean whenNext(Integer element) {
        //        System.out.println("接收到的流元素：" + element);
        //        return true;
        //    }
        //};
        //publisher.subscribe(subscriber);

        Thread.sleep(1000000);

    }


    public class MySubscriber implements Subscriber<Integer> {
        private Subscription sub;

        private int randNum = 5;


        @Override
        public void onSubscribe(Subscription s) {
            System.out.println("调用了订阅方法");
            sub = s;
            sub.request(1);
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("调用了onNext方法" + integer + ",rand:" + randNum);

            if (integer == 0 || (integer + 1) % randNum == 0) {
                System.out.println("再次request:" + randNum);
                sub.request(randNum);
            }
        }

        @Override
        public void onError(Throwable t) {
            System.out.println("错误处理:" + t);
        }

        @Override
        public void onComplete() {
            System.out.println("结束");
        }
    }

}
```

### 3.3 响应式流技术兼容套件

#### 3.3.1 TCK

响应式流看着比较简单，实际包含许多的隐藏陷阱。

除java接口外，该规范还包含许多针对实现的文档化规则。

这些规则严格限制每个接口，同时，保留规范中提到的所有行为至关重要。

开发人员需要一个可以验证所有行为并确保响应库标准化且想到兼容的通用工具。

Konrad Malawski 已经为此实现了一个工具包，其名称为响应式流技术兼容套件（Reactive  Streams Technology Compatibility Kit），简称为 TCK。

TCK是一组TestNG测试用例，需要对其进行扩展，并为相应的Publisher或者Subscriber准备验证。

首先还是引入maven坐标

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>6.9.10</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.16</version>
    </dependency>
</dependencies>
```

**发布者验证**

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.tck.PublisherVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TckTest extends PublisherVerification<String> {


    public TckTest()
    {
        super(new TestEnvironment());
    }

    @Override
    public Publisher<String> createPublisher(long l) {

        Set<String> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(String.valueOf(i));
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<String> publisher
                = new AsyncIterablePublisher<>(elements, executorService);
        return publisher;
    }

    @Override
    public Publisher<String> createFailedPublisher() {

        Set elements = new HashSet<>();
        elements.add(new RuntimeException("手动异常"));

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        return new AsyncIterablePublisher<>(elements,executorService);
    }
}
```

只遵循上述测试用例配制，无法检查该Publisher的准确性，因为许多测试假设流中存在多个元素。

响应式流TCK考滤了这种极端情况，并支持设置一外名为maxElementsFromPublisher方法，该方法返回一个值，用于指定生成元素的最大数量。

```java
    @Override
    public long maxElementsFromPublisher() {
        //return super.maxElementsFromPublisher();
        return 10;
    }
```

一方面重写该方法可以跳过需要多个元素的测试，另一方面，响应式流规则的覆盖范围将减小，可能需要实现自定义测试用例。

**订阅者验证**

订阅者存在两种验证方式。黑盒验证和白盒验证。

首先看黑盒验证

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.tck.SubscriberBlackboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TCKBlackBoxTest extends SubscriberBlackboxVerification<Integer> {


    protected TCKBlackBoxTest() {
        super(new TestEnvironment());
    }

    @Override
    public Subscriber<Integer> createSubscriber() {
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素:" + element);
                //该返回为true，表示继续接收下一个元素，false表示不再请求了
                return true;
            }
        };
        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }

    //@Override
    //public void triggerRequest(Subscriber<? super Integer> subscriber) {
    //    //该方法直接向订阅者发送信号，默认该方法什么都不做
    //    AsyncSubscriber<Integer> subscriber1 = (AsyncSubscriber<Integer>) subscriber;
    //    subscriber1.onNext(100000);
    //}
}
```

该测试用例，可以模拟真实的用户活动。

再看白盒测试

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.reactivestreams.tck.SubscriberWhiteboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class TestWhiteBoxTest extends SubscriberWhiteboxVerification<Integer> {

    protected TestWhiteBoxTest() {
        super(new TestEnvironment());
    }


    @Override
    public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> whiteboxSubscriberProbe) {

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素：" + element);
                //返回true表示请求下一个元素，false表示不再请求
                return true;
            }

            @Override
            public void onSubscribe(Subscription subscription) {
                super.onSubscribe(subscription);
                whiteboxSubscriberProbe.registerOnSubscribe(new SubscriberPuppet() {
                    @Override
                    public void triggerRequest(long elements) {
                        subscription.request(elements);
                    }

                    @Override
                    public void signalCancel() {
                        subscription.cancel();
                    }
                });
            }

            @Override
            public void onNext(Object object) {
                super.onNext(object);
                whiteboxSubscriberProbe.registerOnNext((Integer) object);
            }

            @Override
            public void onError(Throwable t) {
                super.onError(t);
                whiteboxSubscriberProbe.registerOnError(t);
            }

            @Override
            public void onComplete() {
                super.onComplete();
                whiteboxSubscriberProbe.registerOnComplete();
            }
        };


        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }
}
```

createSubscriber方法实现与黑盒验证的工作方式相同，并返回Subscriber实例，但此处还有一个名为whiteboxSubscriberProbe的附加参数。

在这种情况下，whiteboxSubscriberProbe代表了一种机制，该机制实现对需求的嵌入式控制和输入信号的捕获。

与黑盒验证相比，通过正确的注册探测钩子，测试套件不仅能够发送需求，还能验证需求是否被满足以及所有元素是否被接受。同时，需求监控机制比以前更加透明。我们实现了subScriberPupper，它会为直接访问收到的Subscription进行适配。



同时TCK还提供 了processor的测试，此处略过。



## 4. 响应流的异步与并行

一方面，响应流的API中的规则 2.2和3.4规定，对由publisher生成并由Subscriber消费的所有信号的处理过程应该是非阻塞和非干扰的。

因此基于具体的执行环境，可以高效的利用处理器的一个节点和一个内核。

另一方面，所有处理器或者内核的高效利用需要并行化，对响应式流规范中的并行化概念的可以理解为对Subscrber#onNext方法的并行调用。

遗憾的是，规则 中的规则1.3规定，必须以线程安全的方式触发onXXX方法的调用，并且如果由多个线程执行，则使用外部同步，这一假定对所有OnXXX方法的串行化或者简单顺序调用。反过来，这意味着无法创建类型ParallelPublisher的组件并在流中对元素进行并行处理。

如果高效的利用资源，就必须分析常见了流处理管道。



![image-20241127122543496](.\images\image-20241127122543496.png)

一种解决方案是在阶段之间传递异步消息，对于基于内存的流处理而言，这意味着执行过程的一部分被绑定到了一个线程而另一部分被绑定到了另一个线程。

![image-20241127122804397](.\images\image-20241127122804397.png)

通常的做法是：两个独立 的线程之间拆分处理过程，在阶段之前放置异步边界。

又因为两个线程可以彼此独立地工作，所以通过这样做，将元素的整体处理过程并行化。为了实现并行化，必须应用一种数据结构（例如queue)来正确的解耦处理过程。

拆分线程之间的处理过程会导致数据结构中的额外的开销。当然，由于响应式流的规定，这样的数据结构是有界的。数据结构中的数据项数量通常等于Subscriber从其他Publisher请求的批处理的大小，而这取决于系统的一般容量。



![image-20241127123609250](.\images\image-20241127123609250.png)

每个处理阶段都可以绑定一个单犯的线程。



## 5. 响应式环境的转变

JDK9包含了响应式规范这一事实强调了该规范的重要性，并且该规范已经开始改变这个行业。

### 5.1 RxJava的转变

例如：一个应用程序把RxJava1.x和Observalbe作为组件之间的核心通信类型:

```java
interface LogService {
    Observable<String> stream();
}
```

遵循响应式流规范并从以下特定依赖中报出我们的接口

```java
interface LogService {
    Publisher<String> stream();
}
```

将RxJava2类型反向转换为响应式流兼容类型：

```java
Flowable.just(1, 2, 3)
   .map(String::valueOf)
   .toObservable()
   .toFlowable(BackpressureStrategy.ERROR)
   .subscribe();

```



### 5.2 Vert.x 的调整

为了遵循规范，Vert.x  包含一个额外的模块，该模块为响应式流 API 提供支持

```java
// ...
.requestHandler(request -> {
    ReactiveReadStream<Buffer> rrs = ReactiveReadStream.readStream();
    HttpServerResponse response = request.response();
    Flowable<Buffer> logs = 
Flowable.fromPublisher(logsService.stream()).map(Buffer::buffer)
       .doOnTerminate(response::end);
    logs.subscribe(rrs);
    response.setStatusCode(200);
    response.setChunked(true);
    response.putHeader("Content-Type", "text/plain");
    response.putHeader("Connection", "keep-alive");
    Pump.pump(rrs, response).start();
});
// ...
```

### 5.3 Ratpack的改进

```java
RatpackServer.start(server -> server.handlers(chain -> chain.all(ctx -> {
    Publisher<String> logs = logsService.stream();
    ServerSentEvents events = serverSentEvents(
        logs, event -> event.id(Objects::toString).event("log").data(Function.identity());
   );
    ctx.render(events);
})));
```

Patpack还提供了对规范接口的自身实现

```java
Publisher<String> logs = logsService.stream();
TransformablePublisher publisher = Streams.transformable(logs)
   .filter(this::filterUserSensitiveLogs)
   .map(this::escape);
```



## 6. Spring响应式编程

### 6.1 观察者模式

好像观察者模式似乎与响应式编程无关，但经过一些小改动，它定义了响应式编程的基础

![image-20241127125125558](.\images\image-20241127125125558.png)

**Subject接口**

```java

/**
 * Subject接口
 *
 * @author liujun
 * @since 2023/7/13
 */
public interface Subject {

    /**
     *  注册观察者
     */
    void registerObserver(Observer observer);

    /**
     * 解绑观察者
     *
     * @param observer
     */
    void unregisterObserver(Observer observer);

    /**
     * 通知事件变更
     *
     * @param event
     */
    void notifyObservers(String event);

}

```

**Observer接口**

```java

/**
 * Observer接口
 *
 * @author nullnull
 * @since 2023/7/13
 */
public interface Observer {

    void observe(String event);

}
```

**Subject实现类**

```java

import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteSubject implements Subject {

    /**
     * 保证Set是线程安全的
     */
    private Set<Observer> observers = new CopyOnWriteArraySet<>();

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void unregisterObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String event) {
        observers.forEach(observer -> observer.observe(event));
    }
}
```

Observer的实现类

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverA implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}

```

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverB implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}
```

单元测试

```java
import org.junit.Test;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ObserverTest {
    @Test
    public void dataTest() {
        Subject subject = new ConcreteSubject();
        Observer observer1 = new ConcreteObserverA();
        Observer observer2 = new ConcreteObserverB();
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);
        subject.notifyObservers("hello null null");
        System.out.println("==================================");
        subject.unregisterObserver(observer1);
        subject.notifyObservers("great null null");

    }
}

```

输出：

```java
com.nullnull.observer.ConcreteObserverA --- hello null null
com.nullnull.observer.ConcreteObserverB --- hello null null
==================================
com.nullnull.observer.ConcreteObserverB --- great null null
```

可以使用java8的lambda的特性:

```java
 @Test
    public void dataTestLambda() {
        Subject subject = new ConcreteSubject();
        subject.registerObserver(e -> System.out.println("A: " + e));
        subject.registerObserver(e -> System.out.println("B: " + e));
        subject.notifyObservers("This message will receive A & B");

        subject.notifyObservers("hello null null");
        System.out.println("==================================");

    }
```

输出:

```java
A: This message will receive A & B
B: This message will receive A & B
A: hello null null
B: hello null null
```



### 6.2 基于@EventListener注解的发布和订阅模式

实现一个简单的WEB服务，用于显示当前的温度。

![image-20241127222027473](.\images\image-20241127222027473.png)

**maven依赖**

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>


        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

**实体**

```java

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }
}

```

**TemperatureSensor类模拟传感器**

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    private final ApplicationEventPublisher publisher;

    private final Random random = new Random();

    private final ScheduledExecutorService service =
            Executors.newSingleThreadScheduledExecutor();

    public TemperatureSensor(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    @PostConstruct
    public void startProcessing() {
        this.service.schedule(this::probe, 1, TimeUnit.SECONDS);
    }

    private void probe() {
        double temperature = 16 + random.nextGaussian() * 10;
        System.err.println("发送事件。。。");
        // 通过ApplicationEventPublisher发布Temperature事件

        publisher.publishEvent(new Temperature(temperature));
        service.schedule(this::probe, random.nextInt(5000),
                TimeUnit.MILLISECONDS);
    }
}
```

**暴露SSE端点**

```java
import org.json.JSONObject;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@RestController
public class TemperatureController {

    private final Set<SseEmitter> clients = new CopyOnWriteArraySet<>();

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {

        // ResponseBodyEmitter的子类，用于发送SSE（Server-Send Event）：服务器发送 的事件
        //    SseEmitter emitter = new SseEmitter();
        // 设置超时时间
        SseEmitter emitter = new SseEmitter(10000L);
        // 将当前发射器放到集合中
        clients.add(emitter);
        // 给当前发射器设置事件处理函数

        /*
        当异步请求超时的时候调用的代码。
        该方法在异步请求超时的时候由容器线程调用。
         */
        emitter.onTimeout(() -> clients.remove(emitter));
        /*
        当异步请求结束的时候调用的代码。
        当超时或网络错误而终止异步请求处理的时候，在容器线程调用该方法。
        该方法一般用于检车一个ResponseBodyEmitter实例已经无用了。
         */
        emitter.onCompletion(() -> clients.remove(emitter));
        return emitter;
    }

    /**
     * @param temperature
     * @Async // 异步事件处理
     * @EventListener // 事件监听器，该监听器只接收Temperature事件
     */
    @Async // 异步事件处理
    @EventListener // 事件监听器，该监听器只接收Temperature事件
    public void handleMessage(Temperature temperature) {
        System.out.println("监听到web的调度事件了 -- " + temperature);
        List<SseEmitter> deadEmitters = new ArrayList<>();
        // 遍历发射器集合
        clients.forEach(emitter -> {
            try {
                // 发射器发送温度对象，json类型
                final JSONObject jsonObject = new JSONObject(temperature);
                final String s1 = jsonObject.toString();
                emitter.send(s1);
            } catch (Exception ignore) {
                // 如果抛异常，则将该发射器放到deadEmitters集合中
                deadEmitters.add(emitter);
            }
        });
        // 从clients中移除所有失效的发射器。
        clients.removeAll(deadEmitters);
    }
}

```

**配制异步支持**

```java
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@Configuration
@EnableAsync
public class MyAsyncConfig implements AsyncConfigurer {
    // 为异步调用设置Executor
    @Override
    public Executor getAsyncExecutor() {
        // 使用包含两个核心线程的 ThreadPoolTaskExecutor，可以将核心线程增加到一百  个。
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(100);
        // 如果没有正确配置队列容量，线程池就无法增长。
        // 这是因为程序将转而使用 SynchronousQueue，而这限制了并发。
        executor.setQueueCapacity(5);
        executor.initialize();
        return executor;
    }
    // 为异步执行引发的异常配置异常处理程序。
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        // 此处仅记录异常
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

**入口程序配制**

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo10Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo10Application.class, args);
  }
}
```

resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```

启动服务

Demo10Application

访问网页

http://127.0.0.1:8080/

显示：

```tex
Connection opened
Temperature: 23.53 C
Temperature: 8.66 C
Temperature: 19.28 C
Connection closed
Connection opened
```

控制台输出：

```sh
发送事件。。。
2024-11-27 22:30:50.741  INFO 28324 --- [pool-1-thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@499ff586
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@1ad9aed1
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@6eed6b83
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@141e43fa
```



### 6.3 使用RxJava作为响应式框架

官网地址：

```sh
http://reactivex.io/
```

ReactiveX通常被定义为观察者模式、迭代器模式和函数式编程的组合。

Java平台上有一个用于响应式编程的标准库，即RxJava，是Reactive Extensions(响应式扩展，也称为ReactiveX)的Java实现，目前它并不是唯一的响应式库，还是Akka Streams和Project Reactor.

随着2.x版本的发布，RxJava本身发生了很大的变化。

RxJava是迄今为止应用最广泛的响应式库。

这些API从该库的早期版本以来就没有发生改变。



#### 6.3.1 响应式流

使用Rxjava1.x版本实现生产者与消费者

maven坐标

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

代码

```java
    @Test
    public void rxjava1() {

        //创建发布者
        Observable<String> observable = Observable.create(
                new Observable.OnSubscribe<String>() {
                    @Override
                    public void call(Subscriber<? super String> subscriber) {
                        for (int i = 0; i < 10; i++) {
                            subscriber.onNext("hello null null " + i);
                        }
                        subscriber.onCompleted();
                    }
                });

        //创建订阅者
        observable.subscribe(new Subscriber<String>() {
            @Override

            public void onCompleted() {
                System.out.println("on completed");
            }

            @Override

            public void onError(Throwable throwable) {
                System.out.println("on error :" + throwable.getMessage());
            }

            @Override

            public void onNext(String s) {
                System.out.println("on next: " + s);
            }
        });
    }
```

控制台可以输出：

```java
on next: hello null null 0
on next: hello null null 1
on next: hello null null 2
on next: hello null null 3
on next: hello null null 4
on next: hello null null 5
on next: hello null null 6
on next: hello null null 7
on next: hello null null 8
on next: hello null null 9
on completed
```

创建一个Observable并使其带有一个回调，该回调将在订阅者出现时立即被触发。此时Observer将产生一个字符串值，交将流的结束信号发送给订阅者。

可以使用lambda改进下

```java
    @Test
    public void rxjava1Lambda() {
        //创建发布者，使用Lambda表达式
        Observable.create(
                        subscriber -> {
                            for (int i = 0; i < 10; i++) {
                                subscriber.onNext("hello null null " + i);
                            }
                            subscriber.onCompleted();
                        }
                )
                //指定了调用者
                .subscribe(
                        System.out::println,
                        System.err::println,
                        () -> System.out.println("结束")
                );

    }
```

还是同样的输出：

```tex
hello null null 0
hello null null 1
hello null null 2
hello null null 3
hello null null 4
hello null null 5
hello null null 6
hello null null 7
hello null null 8
hello null null 9
结束
```



#### 6.3.2 just方法

just用来引用元素，使用旧式数组、或者使用from，通过iterable集合创建observable实例

```java
    @Test
    public void testJust() {
        Observable<String> just = Observable.just("1", "2", "3", "4", "5");
        just.subscribe(
                item -> System.out.println(item),
                ex -> System.err.println(ex),
                () -> System.out.println("完成")
        );
    }
```

输出:

```tex
1
2
3
4
5
完成
```

使用from

```java
    @Test
    public void testFrom() {
        Observable<Integer> from = Observable.from(new Integer[]{1, 2, 3, 4, 5});
        from.subscribe(
                itm -> System.out.println("下一个元素是:" + itm),
                ex -> System.err.println("异常信息是:" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是:1
下一个元素是:2
下一个元素是:3
下一个元素是:4
下一个元素是:5
结束
```

#### 6.3.3 from方法

from甚至可以接收一个callable对象的返回。

```java
    @Test
    public void testFromCallable() {
        Observable<String> fromCallable = Observable.fromCallable(() -> "hello null null");

        fromCallable.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello null null
结束
```

或者接收一个Future对象

```java
    @Test
    public void testFeature() {
        Future<String> submit = Executors.newCachedThreadPool().submit(() -> "hello word");

        Observable<String> from = Observable.from(submit);

        from.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello word
结束
```



#### 6.3.4 concat方法

每个传入concat操作符会通过将每个数据项重新发送到下游观察者的方式来消费所有数据项。然后，传入流将被处理，直到发生终止操作（OnComplete()，OnError()），并且其处理顺序会与concat()方法中的顺序保持一致。

```java
    @Test
    public void testConcat() {
        Observable.concat(
                Observable.just("hello "),
                Observable.from(new String[]{"null null"}),
                Observable.just("!")
        ).forEach(
                item -> System.out.println("下一个元素：" + item),
                ex -> System.out.println(ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素：hello 
下一个元素：null null
下一个元素：!
结束
```

>注：虽然异常定义处理很方便，但在发生错误的情奖品下，默认的Subscriber实现仍会抛出`rx.exceptions.OnErrorNotImplementedException。`



#### 6.3.5 interval生成异步序列

RxJava不仅可以生成一个未来的事件，还可以基于时间间隔等生成一个异步事件的序列。

```java
    @Test
    public void testInterval() throws InterruptedException {
        Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素：" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成")
                );
        Thread.sleep(5000);
    }

```

输出：

```tex
下一个元素：0
下一个元素：1
下一个元素：2
下一个元素：3
下一个元素：4
```

每秒输出一人上元素。共5秒.

#### 6.3.6 取消订阅

取消订阅的接口:

```java
public interface Subscription {
    // 订阅取消
    void unsubscribe();
    // 检查 Subscriber是否仍在等待事件
    boolean isUnsubscribed();
}
```

为了便于理解这个取消订阅的接口，可以假调情况：订阅者是唯一对事件感兴趣的一方，并且订阅者会消费它，直到CountDownLatch发出一个外部信号。传入流每100毫秒生成一个新事件，而这些事件会产生无限序号，即0,1,2,3....，以下订阅以及取消订阅

```java
    @Test
    public void testUnsubscribe() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Subscription subscribe = Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素:" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成:")
                );

        new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //如果订阅票据还在订阅状态，则取消订阅
            if (!subscribe.isUnsubscribed()) {
                subscribe.unsubscribe();
            }
            latch.countDown();
        }).start();

        System.out.println("主线程完成");
        latch.await();
        System.out.println("等待结束");
    }
```

输出:

```tex
主线程完成
下一个元素:0
下一个元素:1
等待结束
```

#### 6.3.7 map操作符

RxJava中最常用的操作符就是Map

```java
    /**
     * Returns an Observable that applies a specified function to each item emitted by the source Observable and
     * emits the results of these function applications.
     * <dl>
     *  <dt><b>Backpressure:</b></dt>
     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Observable}'s backpressure
     *  behavior.</dd>
     *  <dt><b>Scheduler:</b></dt>
     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.</dd>
     * </dl>
     *
     * @param <R> the output type
     * @param func
     *            a function to apply to each item emitted by the Observable
     * @return an Observable that emits the items from the source Observable, transformed by the specified
     *         function
     * @see <a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>
     */
    public final <R> Observable<R> map(Func1<? super T, ? extends R> func) {
        return unsafeCreate(new OnSubscribeMap<T, R>(this, func));
    }
```

![image-20241128223247756](.\images\image-20241128223247756.png)

通过对每个数据项应用函数转换（Observable）发出的数据，map执行一对一转换。

输出流具有与输入流相同数量的元素。

```java
    /**
     * Map函数用于对象的转换操作
     */
    @Test
    public void map2() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.map(item -> {
            return item * 100;
        }).forEach(item -> System.out.println(item));
    }
```

输出：

```tex
100
200
300
400
500
600
```



#### 6.3.8 filter操作符

与map操作符相比，filter操作符所产生的元素可能少于它所接收的元素。它只发生那些已经成功通过谓词测试的元素：

![image-20241128223728825](.\images\image-20241128223728825.png)

代码

```java
    @Test
    public void filter() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.filter(item -> {
            return item % 2 == 0;
        }).forEach(item -> System.out.println(item));
    }
```

输出:

```tex
2
4
6
```

#### 6.3.9 count操作符

count操作符自描述性很强，它发出的唯一值代表输入的元素数量。但是，count操作符只在原始流结束时发出结果，因此在处理无限流时，count操作符将不会完成或者返回任何内容：

![image-20241128224032199](.\images\image-20241128224032199.png)

样例：

```java
    @Test
    public void count() {
        List<Integer> dataList = new ArrayList<>(1000);

        for (int i = 0; i < 1000; i++) {
            dataList.add(i);
        }

        Observable.from(dataList)
                //过滤出偶数
                .filter(item -> item % 2 == 0)
                //计数
                .count()
                //输出
                .subscribe(
                        item -> System.out.println("结果计数:" + item)
                );
    }
```

```tex
结果计数:500
```

#### 6.3.10 zip操作符

该操作符具体更复杂的行为，因为它会通过应用zip函数来组合来自两个并行流的值。通常用于填充数据。具特别适合用于部分预期结果从不同源获取的情况：

![image-20241128224507365](.\images\image-20241128224507365.png)

样例代码

```java
    @Test
    public void zip() {
        Observable.zip(Observable.just(1, 2, 3, 4),
                        Observable.just("a", "b", "C", "D"),
                        (a, b) -> a + b)
                .forEach(System.out::println);

    }
```

输出：

```tex
1a
2b
3C
4D
```



#### 6.3.11 concatMap操作符

![image-20241129094319937](.\images\image-20241129094319937.png)





#### 更多

更多的响应式流的图片，可以查看：

```javascript
http://rxmarbles.com/
```

操作符的描述：

```javascript
https://reactivex.io/documentation/operators.html
```





### 6.4 Rxjava+SpringBoot

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>


        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

温度类的信息

```java
package com.nullnull.spring4observer2;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }

}

```

业务实现类

```java

import org.springframework.stereotype.Component;
import rx.Observable;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 业务实现类
 *
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    /**
     * 随机数生成对象
     */
    private final Random random = new Random();

    private final Observable<Temperature> dataStream = Observable
            //随机生成0-int最大值的数
            .range(0, Integer.MAX_VALUE)
            //对以接收到的int数据做处理，Observable
            .concatMap(tick -> Observable.just(tick)
                    //随机延迟5秒内
                    .delay(random.nextInt(5000), TimeUnit.MILLISECONDS)
                    //将随机的流返回为Temperature对象
                    .map(tickKey -> this.probe())
                    //生成生产者
                    .publish()
                    // — 让一个可连接的Observable表现得像一个普通的Observable
                    .refCount()
            );

    private Temperature probe() {
        return new Temperature(16 + random.nextGaussian() * 10);
    }

    public Observable<Temperature> temperatureStream() {
        return dataStream;
    }
}
```

TemplateSensor 使用温度值暴露了一个流，通过使用TemperatureSensor, 可以将每个新的SseEmitter订阅到Observable流，并接收到onNext信号发送给SSE客户端

RxSseEmitter

```java
import org.json.JSONObject;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import rx.Subscriber;

import java.io.IOException;

/**
 * RxSseEmitter 负责从Subscriber接收到的数据转换为JSON响应客户端
 * @author nullnull
 * @since 2023/7/15
 */
public class RxSseEmitter extends SseEmitter {
    static final long SSE_SESSION_TIMEOUT = 30 * 60 * 1000L;
    private final Subscriber<Temperature> subscriber;

    public RxSseEmitter() {
        super(SSE_SESSION_TIMEOUT);
        //订阅一个流
        this.subscriber = new Subscriber<Temperature>() {
            @Override
            public void onNext(Temperature temperature) {
                try {
                    //将数据转换为JSON对象
                    final JSONObject jsonObject = new JSONObject(temperature);
                    final String temperatureJson = jsonObject.toString();
                    System.out.println(temperatureJson);
                    //数据输出
                    RxSseEmitter.this.send(temperatureJson);
                } catch (IOException e) {
                    unsubscribe();
                }
            }

            @Override
            public void onError(Throwable e) {
                System.err.println(e);
            }

            @Override
            public void onCompleted() {
                System.out.println("job done");
            }
        };
        onCompletion(subscriber::unsubscribe);
        onTimeout(subscriber::unsubscribe);
    }


    public Subscriber<Temperature> getSubscriber() {
        return subscriber;
    }
}
```

controller:

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;

/**
 * @author nullnull
 * @since 2023/7/15
 */
@RestController
public class TemperatureController {

    private final TemperatureSensor temperatureSensor;

    public TemperatureController(TemperatureSensor temperatureSensor) {
        this.temperatureSensor = temperatureSensor;
    }

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {
        RxSseEmitter emitter = new RxSseEmitter();
        //数据源对象生产数据，交给订阅者SseEmitter
        temperatureSensor.temperatureStream().subscribe(emitter.getSubscriber());
        return emitter;
    }
}

```

启动入口

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo12Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo12Application.class, args);
  }
}

```

src/main/resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```



启动服务

```javascript
http://127.0.0.1:8080/
```

浏览器出现：

```tex
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```



浏览器访问：

```javascript
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```

当没有订阅时，温度传感器不会探测数据，只有订阅后，才有数据返回。



### 6.5 Spring响应式编程

#### 6.5.1 Sping WebFlux

Spring Framework 5添加新模块`srping-web-reactive`,使用响应式非阻塞引擎支持类型Spring MVC的@controller编程模型

![image-20241129231123927](.\images\image-20241129231123927.png)

Spring web Reactive使用Servlet 3.1 非阻塞特性，也可以运行于非Servlet运行时，如Netty和Undertow等.

对每个运行时适配了一组公共的响应式`ServerHttpRequest`和`ServerHttpResponse`抽象，以`Flux<DataBuffer>`的形式暴露请求和响应，读写完全支持背压。

`spring-core`模块提供了`Encoder`和`Decoder`契约，用于对`Flux`的数据进行序列化和反序列化。

`spring-web`模块添加了JSON和XML的实现，用于web应用或其他SSE流和零拷贝文件传输。

`spring-web-reactive`模块包含了Spring Web Reactive框架以支持@controller编程模型。

重新定义了很多Spring MVC的契约，如`HandlerMapping`和`HandlerAdapter`以支持异步和非阻塞，响应式地操作HTTP的请求和响应。

Sping MVC和Sping Web Reactive不共享任何代码，处理逻辑有很多是共通的。

跟Spring MVC的编程模型一样，但是支持响应式的类型并且以响应式的方式执行。

下述类型都可以作为控制方法的@RequestBody参数来使用

- `Account account`-account在调用控制器之前非阻塞地反序列化。

- `Mono<Account> account`-控制使用`Mono`声明执行的逻辑，当account反序列化后执行。

- `Single<Account> account`-跟`Mono`一样，使用RxJava执行引擎。

- `Flux<Account> accounts`- 输入流场景

- `Observable<Account> accounts`-使用RxJava的输入流。

返回值类型

- `Mono<Account>`-当Mono结束，非阻塞地序列化给定的Account对象
- `Single<Account>`-跟Mono的一样，但是使用RxJava执行引擎。
- `Flux<Account>`-流场景，根据请求content type的不同，有可能是SSE
- `Flux<SseEvent>`-SSE流。
- `Observable<SseEvent>`-使用RxJava执行引擎的SSE流。
- `Mono<void>`-当Mono结束，请求处理结束。
- `void`-当方法返回。请求处理结束。表示同步、非阻塞的控制器方法。
- `Account`-非阻塞的序列化给定的Account，表示同步、非阻塞控制器方法。



#### 6.5.2 WebSocket

最知名的全双工客户端-服务器通信双工协议，即WebSocket。

WebSocket协议通信于2013年引入至Spring框架中，旨在进行异步消息发送，但其实际的实现仍然有一些阻塞操作。

例如，将数据写入I/O或者从I/O读取数据仍然是阻塞操作，因此这二者影响应用程序的性能。

WebFlux模块为WebSocket引入了改进版本的基础设施。WebFlux同时提供客户端和服务器基础设施。

**服务端WebSocket API**

WebFlux提供`webSocketHandler`作为处理WebSocket的连接的核心接口。

该接口有一个名为`handle`的方法，它接收`WebSocketSession`。`WebSocketSession`类表示客户端和服务器之间的成功握手，并提供包括有关握手、会话属性和传入数据流的信息和访问。

使用echo消息响应发送者的示例：

```java
class EchoWebSocketHandler implements WebSocketHandler{
    @Override
    public Mono<Void> handle(WebSocketSession session){
        return session.receive()
            .map(WebSocketMessage::getPayloadAsText)
            .map(tm -> "Echo:" + tm)
            .map(session::textMessage)
            .as(session::send);
    }
}
```

 此代码表示接收入站消息，并转换，然后封装为WebSocketMEssage对象，发送出去。其中发送返回Mono<Void>,当写出完成，该Mono完成。

WebSocketMessage是DataBuffer的包装器，它提供了额外功能，例如将以字节为单位的有效负载转换为文本。

一旦提取了传入消息，我们在该文本前加上“Echo.”后缀，将新文本消息包装在WebSocketMessage中，并使用WebSocketSession#Send方法将其发送回客户端。这里Send方法接受Publish<WebSocketMessage>并返回Mono<void>作为结果。

因此通过使用Reactor API中的as操作符，我们可以将Flux视作为Mono<Void>,并使用session::send作为转换函数。

**客户端 WebSocket API**

与WebSocket模块(基于WebMVC)不同，webFlux还为我们提供了客户端的支持。要发送WebSocket连接请坟，可以使用WebSocketClient类。

```java
public interface WebSocketClient {
    Mono<Void> execute(
   URI url,
        WebSocketHandler handler
   );
    Mono<Void> execute(
   URI url,
        HttpHeaders headers,
        WebSocketHandler handler
   );
}
```

**对比WebFlux WebSocket与Spring WebSocket模块**

Spring WebSocket模块的主要缺点是它阻塞了与I/O的交互，而Spring WebFlux提供了完全无阻塞的写入和读取。

WebFlux模块通过使用响应式流规范和Project Reactor提供了更好的流抽象，旧WebSocket模块中的WebSocketHandler接口只允许一次处理一条消息，此外WebSocketSession#SendMessage方法仅允许以同步方式发送消息。

旧Spring WebSocket模块的一个关键特性就是它与Spring Messaging模块的良好集成，而这能用@Message注解秋场景WebSocket端点。

```java
@Controller
public class GreetingController {
    @MessageMapping("/hello")
    @SendTo("/topic/greetings")
    public Greeting greeting(HelloMessage message) {
   return new Greeting("Hello, " + message.getName() + "!");
   }
}
```

上述代码展示了使用SpringMessaging模块声明的WebSocket端点，遗憾的是。WebFlux模块的WebSocket集成缺少此类支持，为了场景复杂的处理程序，必须提供自己的基础设施。

**作为WebSocket轻量级替代品的响应式SSE**

与重量级WebSocket一起，HTML5引入了一种创建静态连接的新方法，其中服务器能够推送事件。该技术解决了与WebSocket类似的问题。

SSE 不支持二进制编码并将事件限制为UTF-8 编码。这意味着WebSocket 可能对较小的消息 有用，并且在客户端和服务器之间传输的流量较少，因此具有较低的延迟。 

总而言之，SSE 通常是WebSocket 的一个很好的替代品。由于SSE 是HTTP 协议的抽象，因此 WebFlux 支持与典型REST 控制器相同的声明性函数式端点配置和消息转换

### 6.6 RSocket

Rsocket是一个应用通信协议，用于多路复用全双工通信中。可以TCP、WebSocket或其他字节流传输中使用，提供了如下交互模型：

- `Request-Response`-发送一个消息，接收一个消息
- `Request-Stream`-发一个消息，接收返回消息。
- `channel`-双向发送消息流。
- `Fire-and-Forget`-发送单向消息。

建立初始连接之后，就没有客户端服务端的概念了，因为双方地位对称，都可以初始化交互。因此Rocket中只有请求者或者响应者。而没有客户端和服务端的概念，交互称为“请求流”或者简单的称为“请求们”。

Rsocket关键特性和优势：

- 跨网络边界的响应式流定义-对于诸如“请求流”或者“通道”之类的流请求，背压信号在请求者和响应者之间传播，从而允许请求者放慢源处的响应者的速度，从而减少了对网络层拥塞控制的依赖以及在网络级别或者任何级别缓冲。
- Request throttling-可以从两端发送‘LEASE’帧，因此命名为'Leasing'，以及限定给时间内另一端允许的请求总数。租约定期更新。
- Session恢复-这是专为断开连接而设计，用于维护会话的状态。状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况停止生产者减少所需的状态量。
- 对于大消息的分隔和再组装。
- KeepAlived（心跳）

**协议**

Rsocket的优点之一是，它在线路上具有定义明确的行为，并且易于阅读的规范以及某些协议扩展。

**建立连接**

最初，客户端通过一些低级流传输(例如TCP或者UDP)连接到服务器，并向服务器发送"SETUP"帧以设置连接参数。

服务器可以拒绝“SETUP”帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非“SETUP”帧指示使用租凭语义来限制数量。在这种情况下，双方都必须等待另一方的“租约”帧以允许发出请求。

**发送请求**

一量建立连接，双方都可以通过帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一发起请求。这些帧中每一个都将一个消息从请求者传送到响应者。

响应者然后可以返回带有响应消息的“PAYLOAD”帧，并且在“REQUEST_CHANNEL”的情况下，请求者还可以发送带有更多请求消息的“PAYLOAD”帧发出信号。

每一端还可以通过“METADATA_PUSH”帧发送元数据通知，该元数据通知与任何单独请求无与，而与整个连接有关。



**消息格式**

Rsocket消息包含数据与元数据。元数据可以发送路由、安全令牌等。数据和元数据的格式可以不同。每个类的mime类型都在“SETUP”框架中声明，并应用于给定连接上的所有请求。

尽管所有消息都可以具有元数据，但通常每个请求都包含诸如路由之类的元数据，因此包含在请求的第一条消息中。即带有帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一。

协议扩展定义了于用应用程序 的通用元数据格式：

- [composite Metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)-多个独立化的元数据条目。
- [Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)-请求的路由。



**java实现**

RSocket的java实现基于Project Reactor构建。TCP和WebScoket的传输建立在Reactor Netty之上。作为响应式库。Reactor简化了实现协议工作。对于应用程度，自然要配合使用带有声明性运算符和透明性背压支持的“Flux”和"Mono"

Spring Support  

 spring-messaging 模块包含如下内容：

 [RSocketRequester](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-requester) —流式API，使用 io.rsocket.RSocket 对数据和元数据编码解码，发起 请求。

 [Annotated Responders](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-annot-responders) —  @MessageMapping 注解的用于处理请求的处理器方法

## Spring WebFlux核心原理

## 7. Project Reactor

### 7.1 Spring WebFlux与Project Reactor

Spring Framework从版本5开始，基于Project Reactor支持响应式编程。

Project Reactor是用于在JVM上构建非阻塞应用程序的Reactive库，基于Reactive Stream规范。

Project Reactor是生态系统中响应式的基础，并且与Spring密切合作进行开发。

Spring WebFlux要求Project Reactor作为核心依赖项。

**模块**

Project Reactor由Reactor文档中列出的一组模块组成。

主要组件是Reactor Core，其中包括响应类型Flux和它们实现了Reactive Stream的Publisher接口以及一组可应用于这些类型的运算符。

其中一些模块是：

`Reactor Test`——提供一些实用程序来测试响应流。

`Reactor Extra`——提供一些额外的Flux运算符。

`Reactor Netty`——无阻塞且支持背压的TCP，HTTP和UDP的客户端和服务器。

`Reactor Adapter`——用于与其他响应式（如Rxjava和Akka Streams）的适配。

`Reactor Kafka`——用于Kafka的响应式API，作为Kafka的消费者。

**并发模型**

有两种在响应式链中切换执行某些方式：`publishOn`和`subscribeOn`.

区别如下：

- publishOn（Scheduler scheduler）——响应所有后续运算符的执行（只要未指定其他任何内容）。
- subscribeOn(Schedule scheduler) ——根据链中最早的subscribeOn调用，更改整个操作符链所订阅的线程。它不影响随后对PublishOn的调用行为。

Schedulers类用于包含提供执行上下文的静态方法。

- `parallel()`——为并行工作而调整的固定线程池，可创建与CPU内核数量一样多的工作线程池。
- `single()`——单个可重用线程。此方法为所有调用方我不用同一线程，直到调度程序被释放为止。如果您希望按响应专用线程，则可以为每个呼叫使用Schedulers.newSingle()。
- `boundedElastic()`——动态创建一定数量的工作者，它限制了它可以支持线程的数量，并且在线程可用时重新调度要安排的任务。这是包装同步阻塞调用的不错选择。
- `immediate()`——立即在执行线程上运行，而不切换执行上下文。
- `fromExecutorService(ExecutorService)`——可用于从任何现有ExecutorService中创建调度程序。

### 7.2 Project Reactor 1.x 版本

通过与Spring框架的完美集成 以及与Netty的组合，非常适合开发具备异步和非阻塞消息处理的高性能系统。

Reactor 1.x的缺点：

1. 该库没有背夺控制。除了阻塞生产线线程或者跳过事件之外，事件驱动的Reacor 1.x并没有控制背压的方法。
2. 错误处理非常复杂。Reactor 1.x提供了几种错误处理和失败的方法。但使用比较复杂。

### 7.3 Project Reactor 2.x 版本

Reactor 2首开响应式流的先河

![image-20241201224830940](.\images\image-20241201224830940.png)

在Reacotr设计中，最重要的变化是将事件总线和流功能提供到单独的模块中。此外，深度的重新设计使新的Reacotr Stream库完全符合响应式流规范。Reactor团队大大改进了Reacotr的API。



### 7.4 Project Reactor 3.x版本

Reactor事件总线在2中得到了改进。首先负责发送消息的Reactor对象被重命名为EventBus，该模块也经过重新设计以支持响应式流规范。

Reactor3 以java8作为基线，同时Reactor 3.x塑造了Spring 5框架的响应式变种。

该库支持所有常见的背压传播模式：

1. 仅推送：当订阅者通过subscription.request(Long.Max_VALUE)请求有效无限数量的元素时。
2. 仅拉取：当订阅者通过subscription.request(1)仅在收到一个元素后请求下一个元素。
3. 推-拉（混合）当订阅者的实时控制需求，且发布者可以适应所提出的数据消费速度时。

为适配不支持推拉式操作的模型的旧API，Reactor提供了许多老式背压机制，包括缓冲、开窗、消息丢弃、启动异常等。

某些情况下，上述策略甚至可以用于实际需求出现之前预取数据，从而提高系统的响应性。

此外，Reactor API还提供了足够的工具用于消除用户活动的尖峰并防止系统过载。

Project Reactor在设计上脂在对并发透时，因此它不会强制执行任何并发模型。同时，它提供了一组有用的调度程序，它们几乎能以任何形式管理执行线程，如果所提出的所有调度程序都不符合要求，开发人员可以基于完全的低阶控制来创建自己的调度程序。

## 8.Project Reactor核心

### 8.1 在项目中添加Reactor

mavn依赖:

```xml
<dependencies>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <version>3.4.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 8.2 响应类型——Flux和Mono

响应流规范只定义了4个接口：

- Publisher<T>
- Subscriber<T>
- Subscription
- Processor<T,R>

Project Reactor提供了Publish<T>接口的实现，即Flux<T>和Mono<T>

**Flux**

Flux定义了一个通用的响应式流，它可以产生零个、一个或者多个元素，乃至无限元素。有公式

```sh
onNext x 0..N [OnError | OnComplete]
```

**Mono**

与Flux相比,Mono类型定义了一个最多可以生成一个元素的流。有公式如下

```sh
onNext x 0..1 [OnError | OnComplete]
```

当应用程序API最多返回一个元素时，可以使用Mono<T>

它可以轻松替换CompletableFuture<T>，并提供相似的语义，只不过completableFuture在没有发出值的情况下无法正常完成。

`CompletableFuture`全立即开始处理，而Mono在订阅者出现之前什么也不做。

Mono类型不仅提供了大量的响应式操作符，还能够整合到更大 的响应式工作流中。

当需要对已完成的操作通知客户端时，也可以使用Mono。此时可以返回`Mono<void>`类型并在处理完成时发出onComplete的信号，或者在发生异常时返回`onError()`,此时我们不返回任何数据，而发出通知信号，而该信号可以用作进一步计算的触发器。

Mono和Flux可以容易地想到转换。

如: `Flux<T>.collectLIst()`返回`Mono<List<T>>`，而`Mono<T>.flux()`返回`Flux<T>`

**RxJava2响应式类型**

即使RxJava2.x库和Project Reactor具有相同的基础，RxJava2还是有一组不同的响应式发布者。

由于这两个库实现了相同的理念，包含响应操作符、线程管理和错误处理，都非常的相似。因此、或者或少熟悉其中一个库意味着同时熟悉了这两个库。

Rxjava1.x中最初只有`Observable`这一个响应式类型，之后又添加了`Single`和`Completable`类型。

在版本2.具体以下响应式类型：

- `Observable`
- `Flowable`
- `Single`
- `Maybe`
- `Completable`

1. **Observable**

   1. 与Rxjava1.x的Observable语义几乎相同，但是不接收`null`值。
   2. `Observable`即不支持背压，也不实现Publisher接口，所以它与响应式流规范不直接兼容。
   3. Observable类型的开销小于Flowable类型。
   4. 它具有toFlowable方法，可以通过用户选择的背压策略将流转换为Flowable。

2. **Flowable**

   1. Flowable类型是Reactor Flux类型的直接对应物。
   2. 实现了响应式流的Publisher，可以应用由Project Reactor实现的响应式工作流中。困为API消费PUblisher类型的参数，而不是针对特定的Flux类型。

3. **Single**

   1. Single类型表示生成仅生成一个元素的流。
   2. 不继承Publisher接口。
   3. 具有toFlowable方法。
   4. 不需要背压策略。
   5. 相较于Reactor中的Mono类型，Single更好地表示了CompletableFuture的主义。但是在订阅发生之前它仍不会开始处理。

4. **Maybe**

   1. 实现了与Reactor中的Mono类型相同的语义，但是不兼容响应式流，因为Maybe不实现Publisher接口。
   2. 具有toFlowable方法，以兼容响应式流规范。

5. **Completable**

   1. 只能触发OnError或者OnComplete信号，但不能产生OnNext信号。
   2. 不实现Publisher接口，但是具有toFlowable方法。
   3. 它对应不能生成OnNext信号的Mono<Void>类型。

   

   总而言之，要与其他兼容响应式流的代码集成，应将RxJava类型转换为Flowable类型。

   

   

   

   ### 8.3 创建Flux和Mono序列

   Flux和Mono提供了许多工厂方法，可以根据已有的数据流创建响应流。
   
   如：可以使用对象引用或集合创建Flux，甚至可以简单地用数字范围来创建。
   
   ```java
     /**
        * 使用元素进行构建
        */
       @Test
       public void just() {
           Flux<String> just = Flux.just("hello", "nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   ```
   
   使用数组构建
   
   ```java
       @Test
       public void fromArray() {
           Flux<String> arrayFlux = Flux.fromArray(new String[]{"hello", "nullnull", "dd"});
           arrayFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   dd
   ```
   
   使用集合构建
   
   ```java
       @Test
       public void fromIterable() {
           Flux<Integer> interFlux = Flux.fromIterable(Arrays.asList(1, 2, 3, 4, 5));
           interFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   1
   2
   3
   4
   5
   ```
   
   使用range生成
   
   ```java
       @Test
       public void range() {
           Flux<Integer> range = Flux.range(100, 5);
           range.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   100
   101
   102
   103
   104
   ```

   

   **创建Mono序列**
   
   Mono提供类似的工厂方法，但订针对单个元素。它经常与nullable类型和Optional类型一起使用。
   
   ```java
       @Test
       public void just()
       {
           Mono<String> just = Mono.just("nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:

   ```tex
   nullnull
   ```
   
   使用`justOrEmpty`
   
   ```java
       @Test
       public void justOrEmpty() {
           Mono<String> objectMono = Mono.justOrEmpty(null);
           objectMono.subscribe(System.out::println);
       }
   ```

   此啥也不会输出
   
   避免空指针，使用Option对象
   
   ```java
       @Test
       public void justOrEmptyOption()
       {
           Mono<String> objectMono = Mono.justOrEmpty(Optional.empty());
           objectMono.subscribe(System.out::println);
       }
   ```

   同样的，这个啥也不会输出.
   
   点击`justOrEmpty`方法的源码发现，以上两种参数调用，都是同一个方法，在内部做了判断。
   
   ```java
   	public static <T> Mono<T> justOrEmpty(@Nullable Optional<? extends T> data) {
   		return data != null && data.isPresent() ? just(data.get()) : empty();
   	}
   ```

   同时Mono对于包装异步操作非常有用。
   
   Mono提供了：
   
   - `fromCallable(Callable)`
   - `fromRunnable(Runnable)`
   - `fromSupplier(Supplier)`
   - `fromFuture(CompletableFuture)`
   - `fromCompletionStage(CompletionStage)`
   
   样例：使用Mono包装Http请求：
   
   ```java
       @Test
       public void monoHttpRequest() throws IOException {
           Mono.fromCallable(() -> httpRequest()).subscribe(System.out::println);
       }
   
       @Test
       public void monoHttpRequestLambda() {
           Mono.fromCallable(this::httpRequest).subscribe(System.out::println);
       }
   
       private String httpRequest() throws IOException {
           URL url = new URL("https://www.baidu.com");
           URLConnection urlConnection = url.openConnection();
           urlConnection.connect();
   
           try (InputStream inputStream = urlConnection.getInputStream();
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);) {
               String tmp = null;
   
               StringBuilder result = new StringBuilder();
   
               while ((tmp = bufferedReader.readLine()) != null) {
                   result.append(tmp).append("\n");
               }
   
               return result.toString();
           } catch (IOException e) {
               throw e;
           }
       }
   ```
   
   输出：
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   ```
   
   带有error以及完成的信号处理
   
   ```java
       /**
        * 异常及完成信号处理
        */
       @Test
       public void monoHttpRequestLambdaFull() {
           Mono.fromCallable(this::httpRequest).subscribe(
                   item -> System.out.println(item),
                   ex -> System.out.println("异常信息:" + ex.toString()),
                   () -> System.out.println("请求完成")
           );
       }
   ```
   
   输出:
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   请求完成
   ```

   Flux和Mono都可以使用`from(Publish<T> p)`工厂方法适配任何其他Publisher实例。
   
   flux使用Publisher
   
   ```java
       @Test
       public void publisher() {
           Flux.from((subscriber) -> {
                       for (int i = 0; i < 10; i++) {
                           subscriber.onNext("hello" + i);
                       }
                       subscriber.onComplete();
                   })
                   .subscribe(
                           System.out::println,
                           System.out::println,
                           () -> System.out.println("处理结果")
                   );
       }
   ```
   
   输出：
   
   ```tex
   hello0
   hello1
   hello2
   hello3
   hello4
   hello5
   hello6
   hello7
   hello8
   hello9
   处理结果
   ```
   
   两种响应式类型都提供了简单的方法来创建常用的空流以及只包含错误的流：
   
   ```java
           //empty工厂方法，它们分别生成Flux或者Mono的空实例。
           Flux<String> empty = Flux.empty();
           //never方法创建一个永远不会发出完成、数据、或者错误等信号的流
           Flux<String> never = Flux.never();
           //error(Throwable)工厂方法创建一个序列，该序列在订阅时始终通过每个订阅者的onError(....)方法传播错误。
           // 由于错误是在Flux或者Mono声明期间被创建，因此每个订阅者都会收到相同的Throwable实例。
           Mono<String> error = Mono.error(new RuntimeException("错误对象"));
   ```
   
   defer工厂方法创建一个序列，并在订阅时决定其行为，可以为不同的订阅者生成 不同的数据：
   
   ```java
      public boolean isValidSeed(String seed) {
           System.out.println("调用了isValidSeed方法");
           return true;
       }
   
       public String getData(String seed) {
           try {
               System.out.println("方法执行：5s");
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           return "echo:" + seed;
       }
   
       public Mono<String> requestData(String seed) {
           if (isValidSeed(seed)) {
               return Mono.fromCallable(() -> getData(seed));
           } else {
               return Mono.error(new RuntimeException("Invalid seed value"));
           }
       }
   
       public Mono<String> requestDeferData(String seed) {
           Mono<String> data;
           if (isValidSeed(seed)) {
               data = Mono.fromCallable(() -> getData(seed));
           } else {
               data = Mono.error(new RuntimeException("Invalid seed value"));
           }
           return Mono.defer(() -> data);
       }
   
       /**
        * 仅调用requestData方法
        */
       @Test
       public void request() {
           requestData("nullnull");
       }
   
       /**
        * 调用requestDeferData方法不订阅
        */
       @Test
       public void requestDeferData() {
           requestDeferData("nullnull");
       }
   
       /**
        * 调用requestDeferData并订阅
        */
       @Test
       public void requestDeferDataSubscribe() {
           requestDeferData("nullnull").subscribe();
       }
   ```

   首先执行`request`
   
   可以看到输出:

   ```java
   调用了isValidSeed方法
   ```

   而`getData`方法并未被触发执行

   
   
   再执行`requestDeferData`方法

   ```java
   调用了isValidSeed方法
   ```

   还是同样的结果，仅仅仅证方法被执行，而`getData`方法并未被触发执行

   
   
   最后执行带有订阅的方法`requestDeferDataSubscribe`
   
   ```tex
   调用了isValidSeed方法
   方法执行：5s
   ```
   
   此时`getData`方法，在被订阅后，被执行。

总结：

1. Project Reactor只需要使用`just`方法枚举元素就可以创建Flux和Mono序列。
2. 可以使用justOrEmpty轻松的将Optional包装到Mono中，或者使用fromSupplier方法将Supplier包装到Mono中。
3. 可以使用fromFuture方法映射Future，或者使用fromRunnable工厂方法映射Runnable.
4. 可以使用fromArray或者fromIterator方法将数组或者Iterator集合转换为Flux流。



### 8.4 订阅响应式流

Flux和Mono提供对subscribe()方法基于lambda的重载，简化了订阅的开发。

subscribe方法的所有重载都返回Disposable接口的实例，可以用于取消基础的订阅过程。

在重载方法1-4中，订阅发出无界数据（Long.MAX_VALUE）的请求。

注意：简单订阅请求无界数据（Long.MAX_VALUE）的选项有时可能迫使生产者完成大量工作以满足需求。因此，如果生产者适合处理有界数据，建议使用订阅对象或者应用请求限制操作符来控制需求。

```java
//重载方法1
//订阅流的最简单的方法，忽略所有信号，通常用于触发具有副作用的流处理。
public final Disposable subscribe();


//重载方法2
//对每个值(onNext信号)调用DataCompsumer，不处理OnError和onComplete信号
public final Disposable subscribe(Consumer<? super T> consumer);

//重载方法3
//与重载方法2相同，处理OnError信号，忽略onComplete信号
public final Disposable subscribe(@Nullable Consumer<? super T> consumer, Consumer<? super Throwable> errorConsumer) 
    
    
//重载方法4
//与方法3相同，处理onComplete信号。
public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer) ;

//重载方法5
//消费响应式流中所有元素，包括错误处理和完成信号，重要的是，这种重载方法能通过请求足够数量的数据来控制订阅，当然请求数量仍然可以是Long.MAX_VALUE.
	public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer,
			@Nullable Consumer<? super Subscription> subscriptionConsumer);

//重载方法6,此方法最通用，但很少被用到
//订阅序列的通用方法，可以为Subscribe的实现提供所需的行为
public final void subscribe(Subscriber<? super T> actual) ;

```

subscribe案例1

```java
    @Test
    public void subscribe() {
        Flux.just("hello", "nullnull", "kk")
                .subscribe(
                        data -> System.out.println("onNext:" + data),
                        ex -> System.out.println("异常信息:" + ex),
                        () -> System.out.println("完成信号")
                );
    }
```

subscribe最基本的用法,输出:

```tex
onNext:hello
onNext:nullnull
onNext:kk
完成信号
```

添副作用

```java
    @Test
    public void subscribeDoOnNext() {
        Flux.range(10, 20)
                //过滤能被5整除的数
                .filter(item -> item % 5 == 0)
                //数据转换，添加前缀v，并转换为字符串
                .map(num -> "v->" + num)
                // 添副作用,用于在发送新的数据项之前执行一些操作，但它不改变数据流本身
                .doOnNext(System.out::println)
                .subscribe();
    }
```

输出:

```tex
v->10
v->15
v->20
v->25
```

**只处理正常情况**

```java
    @Test
    public void subscribeOk() {
        Flux.range(1, 20)
                .filter(item -> item % 4 == 0)
                .subscribe(System.out::println);
    }
```

输出：

```tex
4
8
12
16
20
```

**添加异常处理**

```java
    @Test
    public void subscribeException() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onError(new IllegalArgumentException("添加错误"));
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex)
        );
    }
```

输出:

```tex
tem:0
item:1
item:2
item:3
item:4
异常情况:java.lang.IllegalArgumentException: 添加错误
```

**添加完成事件**

```java
    @Test
    public void subscribeFinish() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onComplete();
            ;
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex),
                () -> System.out.println("处理完成")
        );
    }
```

输出：

```tex
item:0
item:1
item:2
item:3
item:4
处理完成
```

**订阅成功就取消**

```java
    @Test
    public void subscribeCancel() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        //一订阅成功就取消订阅
                        subscription -> subscription.cancel()
                );
    }
```

控制台没有任何的输出

**订阅指定数量**

```java
    @Test
    public void subscribeRequest() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        subscription -> {
                            //订阅响应式流5个元素
                            subscription.request(5);
                            //取消订阅
                            subscription.cancel();
                        }
                );
    }
```

输出：

```tex
onNext:1
onNext:2
onNext:3
onNext:4
onNext:5
```

此处没有收到onComplete信号，因为订阅者在流完成之前取消了订阅。

注意：

1. 响应式流可以由生产者完成（使用onError或者OnComplete信号）
2. 响应流也可以由订阅者完成，通过Subscription实例进行取消。
3. Disposable实例也可用于取消。

**Disposable使用**

通常，Disposable实例不是由订阅者使用，而是由更上一级的抽象的代码使用。

如在主线程通过调用Disposable来取消流处理。

```java
    @Test
    public void disposable() throws InterruptedException {
        Disposable disposable = Flux.interval(Duration.ofMillis(100)).subscribe(data -> System.out.println("onNext:" + data));
        Thread.sleep(2000L);
        //主线程取消订阅
        disposable.dispose();
    }
```

输出:

```tex
onNext:0
onNext:1
onNext:2
onNext:3
onNext:4
onNext:5
onNext:6
onNext:7
onNext:8
onNext:9
onNext:10
onNext:11
onNext:12
onNext:13
onNext:14
onNext:15
onNext:16
onNext:17
onNext:18
onNext:19
```

**自定义订阅者**

如果默认的`subscribe(...)`方法不提供所需的多种功能，则可以实现自己的Subscriber，直接从响应式流规范实现Subscriber接口，并将其订阅到流.

```java
    @Test
    public void selfSubscriber() {
        Subscriber<String> subscriber = new Subscriber<String>() {

            private volatile Subscription subscription;

            @Override
            public void onSubscribe(Subscription s) {
                subscription = s;
                System.out.println("订阅请求1个元素");
                subscription.request(1);
            }

            @Override
            public void onNext(String s) {
                System.out.println("OnNext 接收到1个元素:" + s);
                System.out.println("OnNext 再请求1个元素");
                subscription.request(1);
            }

            @Override
            public void onError(Throwable t) {
                System.out.println("发生错误:" + t);
            }

            @Override
            public void onComplete() {
                System.out.println("成功完成");
            }
        };

        Flux<String> dataTest = Flux.just("hello","nullnull","dd");
        dataTest.subscribe(subscriber);
    }
```

输出：

```tex
订阅请求1个元素
OnNext 接收到1个元素:hello
OnNext 再请求1个元素
OnNext 接收到1个元素:nullnull
OnNext 再请求1个元素
OnNext 接收到1个元素:dd
OnNext 再请求1个元素
成功完成
```

但是，此订阅方法是不对的，它打破了线性代码的封装，也容易出错。

最困难的部分是需要自己管理背压并正确实现订阅者所有的TCK要求。

在前面的示例中，打破了有关订阅验证和取消的这几个TCK。

建议扩展Project Reactor提供的BaseSubscriber类。在这种情况下，订阅者如下所示。

```java
    @Test
    public void recommend() {
        BaseSubscriber<String> baseSubscriber = new BaseSubscriber<String>() {
            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                System.out.println("订阅成功,开始请求第一个元素");
                subscription.request(1);
            }

            @Override
            protected void hookOnNext(String value) {
                System.out.println("hookOnNext-->" + value);
                System.out.println("请求下一个元素");
                request(1);
            }

            @Override
            protected void hookOnComplete() {
                System.out.println("成功完成");
            }

            @Override
            protected void hookOnError(Throwable throwable) {
                System.out.println("发生错误");
            }
        };
        Flux<String> dataTest = Flux.just("hello", "nullnull", "dd");
        dataTest.subscribe(baseSubscriber);
    }
```

输出:

```tex
订阅成功,开始请求第一个元素
hookOnNext-->hello
请求下一个元素
hookOnNext-->nullnull
请求下一个元素
hookOnNext-->dd
请求下一个元素
成功完成
```

使用BaseSubscriber，实现符合TCK的订阅者更为容易。

订阅者在本身拥有生命周期管理的宝贵资源时，会需要这种方法。



### 8.5 用操作符转换响应式流

使用响应式流，除了需要能够创建和使用流，还必须能够完美地转换和操作。

Project Reactor为几乎所胡所需的响应式转换提供了工具，通常可以对库的功能特性做如下分类：

1. 转换现在序列
2. 查看序列的处理方法。
3. 拆分和聚合Flux序列
4. 处理时间。
5. 同步返回数据。

**常规操作符**

1. 映射响应式流元素。

转换序列的最自然方式是将每个元素映射到一个新值。

`Flux`和`Mono`给出了`map`操作符，具有`map(Function<T,R>)`签名的方法可以用于逐个处理元素。

当操作符元素的类型从T转换为R时，整个序列的类型将改变。

![image-20241203230950044](.\images\image-20241203230950044.png)

Mono类的map操作符具有类似的行为。

`cast(Class c)`操作符将流的元素强制转换为目标类。

实现`case(Class c)`操作符的最简单方法是使用`map()`操作符。

Flux类的

```java
	public final <E> Flux<E> cast(Class<E> clazz) {
		Objects.requireNonNull(clazz, "clazz");
		return map(clazz::cast);
	}
```

**index操作符**

index操作符用于枚举序列中的元素。方法签名为:`public final Flux<Tuple2<Long, T>> index()`

```java
    @Test
    public void testIndex() {
        Flux.range(1, 10)
                //数据值转换，添加前缀ds->
                .map(item -> "ds->" + item)
                //给每个值生成一个序列，从0开始
                .index()
                //订阅输出
                .subscribe(System.out::println);
    }
```

输出：

```tex
[0,ds->1]
[1,ds->2]
[2,ds->3]
[3,ds->4]
[4,ds->5]
[5,ds->6]
[6,ds->7]
[7,ds->8]
[8,ds->9]
[9,ds->10]
```

**timestamp操作符**

```java
    @Test
    public void testTimestamp() throws InterruptedException {
        Flux
                //每50毫秒产生一个元素
                .interval(Duration.ofMillis(50))
                //数值转换
                .map(item -> "ds->" + item)
                //生成时间戳
                .timestamp()
                //订阅处理
                .subscribe(item -> System.out.println("OnNext:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("完成信号")
                );

        Thread.sleep(500);
    }
```

输出：

```tex
OnNext:[1733239459690,ds->0]
OnNext:[1733239459737,ds->1]
OnNext:[1733239459784,ds->2]
OnNext:[1733239459831,ds->3]
OnNext:[1733239459878,ds->4]
OnNext:[1733239459942,ds->5]
OnNext:[1733239459990,ds->6]
OnNext:[1733239460038,ds->7]
OnNext:[1733239460084,ds->8]
OnNext:[1733239460131,ds->9]
```



### 8.5.2 过滤响应式流

Project Reactor包含过滤元素的各种操作符。

1. `filter`操作符仅传递满足条件的元素。
2. `ignoreElements`操作符返回`Mono<T>`并过滤所有元素。结果序列仅在原始序列结束后结束。
3. `take(n)`操作符限制所获取的元素，该方法忽略除前n个元素之外的所有元素。
4. `takeLast`仅返回最后一个元素。
5. `takeUntil(Predicate)`传递一个元素直到满足某个条。
6. `elementAt(n)`只可用于获取序列的第n个元素。
7. `single`操作符从数据源发出单个数据项，也为空数据源发出`NoSuchElementException`错误信号,或者为具有多个元素的数据源发出IndexOutOfBoundsExceptionw信号，它不仅可以基于一定数量来获取或跳过元素，还可以通过带有`Duration`的`skip(Duration)`或者`take(Duration)`操作符
8. `TakeUntilOther(Publisher)`或`skipUntilOther(Puhlisher)`操作符，可以或获取一个元素，直到某些消息从另一个流到达。

样例1：

该工作流，首先开始一个流的处理，然后从其他流收到特定事件后，停止该流的处理。

```java

    @Test
    public void testStartStop() throws InterruptedException {
        System.out.println("start");
        //延迟1秒后开始触发
        Mono<String> start = Mono.just("start").delayElement(Duration.ofSeconds(1));
        //在延迟4秒后停止
        Mono<String> stop = Mono.just("stop").delayElement(Duration.ofSeconds(4));
        Flux.interval(Duration.ofMillis(500))
                .map(item -> "fluxElement:" + item)
                .skipUntilOther(start)
                .takeUntilOther(stop)
                .subscribe(System.out::println);
        Thread.sleep(6000);

        System.out.println("finish");
    }
```

输出:

```tex
start
fluxElement:2
fluxElement:3
fluxElement:4
fluxElement:5
fluxElement:6
fluxElement:7
finish
```

查看弹珠图

![image-20241204223422077](.\images\image-20241204223422077.png)



### 8.5.3 收集响应式流

收集列表中的所有元素，并使用`Flux.CollectionList()`和`Flux.CollectSortedList()`将结果集合处理为Mono流是可以的，`Flux.CollectSortedList()`不仅会收集元素，还会对它们进行排序

```java
    @Test
    public void testCollectSortedList() {
        Flux.just(1, 3, 2, 5, 6, 2, 4, 1)
                .collectSortedList(Comparator.reverseOrder())
                .subscribe(System.out::println);
    }
```

输出：

```te
[6, 5, 4, 3, 2, 2, 1, 1]
```

> 注意：收集集合中的序列元素可能非常的耗费资源，当序列具有许多元素时这种现象成为突出。
>
> 此外，尝试在无限流上收集数据可能消耗所有可用的内存。

Project Reactor不仅可以将Flux元素收集到List，还可以收集以下内容：

1. 使用`CollectMap`操作符的映射（`Map<K,T>`）;
2. 使用`CollectMultimap`操作符的多映射（`Map<k,Collection<T>>`）；
3. `Flux.collect(Collector)`操作符收集到任何实现了`java.util.stream.Collector`的数据结构。
4. `Flux`和Mono都有repeat()方法和repeat(times)方法，这两种方法可以针对传入序列进行循环操作。
5. `defaultIfEmpty(T)`是另一个简洁的方法，它能为空Flux或者Mono提供默认值。
6. `Flux.distinct()`仅传递之前未在流中遇到过的元素。但是因为此方法会跟踪所有唯一性的元素，所以(尤其涉及高基数数据时)请谨慎使用，distinct方法具有重载方法，可以为重复跟踪提供自定义算法。因此有时可以手动优化distinct操作符的资源使用。
7. `Flux.distinctUntilChange()`操作符没有此限制，可以用于无限流以删除出现在不间断行中重复项。

>高基数是具有非常罕见元素或唯一性元素的数据，如身份编号和用户名就是典型的高基数数据，而枚举或者来自小弄固定字典的值就不是

**`collectMap`操作符的使用**

```java
    @Test
    public void testCollectMap() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(new Function<Integer, String>() {
                    @Override
                    public String apply(Integer integer) {
                        return "key:" + integer;
                    }
                })
                .subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=2, key:1=1, key:6=6, key:5=5, key:4=4, key:3=3}
```

或者使用lambda表达式

```java
    @Test
    public void testCollectMap1() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item)
                .subscribe(System.out::println);
    }
```

`collectMap`两个参数的使用，也就是分别对Key和分别进行转化操作

```java
    @Test
    public void testCollectMap2() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item, value -> "value:" + value)
                .subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=value:2, key:1=value:1, key:6=value:6, key:5=value:5, key:4=value:4, key:3=value:3}
```

`collectMap`三个参数的使用，也就是分别对Key和分别进行转化操作，可以在集合中，额外的添加元素

```java
    @Test
    public void testCollectMap3() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item, value -> "value:" + value, () -> {
                    Map<String, String> result = new HashMap<>();
                    for (int i = 0; i < 3; i++) {
                        result.put("ik-" + i, "iv" + i);
                    }
                    return result;
                })
                .subscribe(System.out::println);
    }
```

输出:

```tex
{ik-0=iv0, key:2=value:2, key:1=value:1, ik-2=iv2, ik-1=iv1, key:6=value:6, key:5=value:5, key:4=value:4, key:3=value:3}
```



**`collectMultiMap`操作符的使用**

```java
    @Test
    public void testCollectMultiMap() {
        Flux.just(1, 2, 3)
                .collectMultimap(key -> "key:" + key, value -> {
                    List<String> valueResult = new ArrayList<>();
                    for (int i = 0; i < value; i++) {
                        valueResult.add("vs:" + i);
                    }
                    return valueResult;
                }).subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=[[vs:0, vs:1]], key:1=[[vs:0]], key:3=[[vs:0, vs:1, vs:2]]}
```

三个参数使用;

```java
    @Test
    public void testCollectMultiMap2() {
        Flux.just(1, 2, 3)
                .collectMultimap(key -> "key:" + key, value -> {
                            List<String> valueResult = new ArrayList<>();
                            for (int i = 0; i < value; i++) {
                                valueResult.add("vs:" + i);
                            }
                            return valueResult;
                        },
                        () -> {
                            Map map = new HashMap<String, List<String>>();
                            for (int i = 0; i < 2; i++) {
                                map.put("add:" + i, Arrays.asList("addv" + i));
                            }
                            return map;
                        }

                ).subscribe(System.out::println);
    }
```

输出:

```tex
{add:0=[addv0], key:2=[[vs:0, vs:1]], key:1=[[vs:0]], key:3=[[vs:0, vs:1, vs:2]], add:1=[addv1]}
```

**repeat操作符的使用**

```java
    @Test
    public void repeat() {
        Flux.just(1, 2, 3)
                //此数据会打印3遍，1次原始数据，2次重复数据
                .repeat(2)
                .subscribe(System.out::println);
    }
```

输出：

```
1
2
3
1
2
3
1
2
3
```

**defaultIfEmpty操作符的使用**

```java
    @Test
    public void defaultIfEmpty() {
        Flux.empty().defaultIfEmpty("nullnull").subscribe(System.out::println);
    }
```

输出：

```tex
nullnull
```

**distinct操作符**

```java
    @Test
    public void distinct() {
        Flux.just(1, 2)
                .repeat(2)
                .distinct()
                .subscribe(System.out::println);
    }
```

经过去重操作后，数据只剩下了两个,此去重是全局去重

输出：

```tex
1
2
```

**distinctUntilChanged操作符的使用**

对于非连续性重复数据是没有效果的

```java
    @Test
    public void distinctUntilChanged()
    {
        Flux.just(1,2)
                .repeat(2)
                .distinctUntilChanged()
                .subscribe(System.out::println);
    }

```

输出：

```tex
1
2
1
2
1
2
```

连续重复测试

```java
    @Test
    public void distinctUntilChanged2()
    {
        Flux.just(1,1,2,2,3,3,1,1)
                .distinctUntilChanged()
                .subscribe(System.out::println);

    }
```

输出:

```tex
1
2
3
1
```

![image-20241204231856554](.\images\image-20241204231856554.png)

### 8.5.4 裁减流中元素

Project Reactor可以：

1. 统计流中元素的数量
2. 检查所有元素是否具有`Flux.all(Predicate)`所需的属性。
3. 使用`Flux.any(Predicate)`操作会检查是否至少有一个元素具有所需属性。
4. 使用`hasElements`操作符检查流中是否包含多个元素；
5. 使用`hasElement`操作符检查流中是否包含某个所需的元素。短路逻辑，在元素与值匹配时立即返回true.
6. `any`操作符不仅可以检查元素的相等性，还可以通过提供自定义predicate实例检查任何其他属性。



**any**

检查序列是是否包含偶数

```java
    @Test
    public void any() {
        Flux.just(1, 2, 3)
                //检查是否包含偶数
                .any(item -> item % 2 == 0)
                .subscribe(System.out::println);
    }
```

输出：

```tex
true
```

**reduce**

Flux类

能使用自定义逻辑来裁剪序列，`reduce`操作符通常需要一个初始值和一个函数，而该函数会将结果与当前步的元素组合在一起

```java
    @Test
    public void reduce() {
        Flux.range(1, 5)
                .reduce(0, (item1, item2) -> item1 + item2)
                .subscribe(System.out::println);
    }
```

输出：

```tex
15
```

reduce操作符只生成最终结果。加点代码，看下中间的过程

```java
    @Test
    public void reduce() {
        Flux.range(1, 5)
                .reduce(0, (item1, item2) ->
                        {
                            System.out.println("item1:" + item1 + ",item2:" + item2);
                            return item1 + item2;
                        }
                )
                .subscribe(System.out::println);
    }
```

输出:

```tex
item1:0,item2:1
item1:1,item2:2
item1:3,item2:3
item1:6,item2:4
item1:10,item2:5
15
```

弹珠图

![image-20241214133133196](.\images\image-20241214133133196.png)



**scan操作符**

scanr操作符在进行聚合时，可以向下游发送中间结果。

```java
    @Test
    public void scan() {
        Flux.range(1, 5)
                .scan(0, (num1, num2) -> num1 + num2)
                .subscribe(System.out::println);
    }
```

输出：

```tex
0
1
3
6
10
15
```

scan操作符对于许多需要获取处理中事件相关信息的应用程序有用。

可以使用scan计算移动的平均值

```java
    @Test
    public void scanAvg() {
        int arrLength = 3;
        Flux.range(1, 10)
                .index()
                //scan第一个发射的元素是它的初始值
                .scan(new int[arrLength], (arr, entry) -> {
                    arr[(int) (entry.getT1() % arrLength)] = entry.getT2();
                    return arr;
                })
                //当窗口的数据被填满后，才开始计算平均值
                .skip(arrLength)
                .map(array -> Arrays.stream(array).sum() * 1.0 / arrLength)
                .subscribe(System.out::println);
    }
```

输出：

```tex
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
```

**then**

Mono和Flux流有then、thenMany和thenEmpty操作符，它们在上游完成时完成。

上游完成处理后，这些操作符可以用于触发新流，订阅是对于新流的。

```java
    @Test
    public void thenMany() {
        Flux.just(1, 2, 3)
                .doOnNext(item -> System.out.println("输出：" + item))
                .thenMany(Flux.just(4, 5, 6))
                .subscribe(System.out::println);
    }
```

输出：

```tex
输出：1
输出：2
输出：3
4
5
6
```

即使1、2、3是由流生成和处理的，subscribe方法中lambda也只接收4、5、6





### 8.5.5 组合响应式流

Project Reactor可以将许多传入流组成合一个传出流。

指定的操作符虽然有许多重载方法，但都会执行以下转换。

1. `concat`操作符通过向下流转发接收的元素来连接所有数据源，当操作符连接两个流时，它首先消费并重新发送第一个流的元素，然后对第二个执行相同的操作。
2. `merge`操作符将来自上游序列的数据合并到一个下游序列中。与concat操作符不同，上游数据源是立即（同时）被 订阅的。
3. `zip`操作符订阅所有上游，等待所有数据源发出第一个元素，然后将接收到的元素组合到一个输出序列中。
4. `comineLatest`操作符与`zip`操作符的工作方式类似，但是，只要至少一个上游数据源发出一个值，它就会生成新的序列。

**concat操作符**

```java
    @Test
    public void concat() throws InterruptedException {
        Flux.concat(
                        Flux.range(10, 5).delayElements(Duration.ofMillis(100))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅1:")),
                        Flux.range(100, 5).delayElements(Duration.ofMillis(110))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
                )
                .subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出:

```tex
当前被订阅1:
10
11
12
13
14
当前被订阅2
100
101
102
103
104
```

可以发现，此操作符是按顺序一个订阅完成，再订阅第二个。

**merge操作符**

```java
    @Test
    public void merge() throws InterruptedException {
        Flux.merge(
                        Flux.range(10, 5).delayElements(Duration.ofMillis(100))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅1:")),
                        Flux.range(100, 5).delayElements(Duration.ofMillis(110))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
                )
                .subscribe((t) -> System.out.println("onNext:" + t),
                        e -> System.out.println("exception" + e),
                        () -> System.out.println("finish")
                );
        Thread.sleep(2000);
    }
```

输出:

```tex
当前被订阅1:
当前被订阅2
onNext:10
onNext:100
onNext:11
onNext:101
onNext:12
onNext:102
onNext:13
onNext:103
onNext:14
onNext:104
finish
```

可以发现两个流同步被订阅。并且同时向下游发送了数据。

**zip操作符**

```java
    @Test
    public void zip() throws InterruptedException {
        Flux.zip(
                Flux.range(0, 6)
                        .delayElements(Duration.ofMillis(100))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅1")),
                Flux.range(100, 5)
                        .delayElements(Duration.ofMillis(500))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
        ).subscribe((t) -> System.out.println("二元组：t1：" + t.getT1() + ",t2:" + t.getT2()),
                e -> System.out.println("error" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
当前被订阅1
当前被订阅2
二元组：t1：0,t2:100
二元组：t1：1,t2:101
二元组：t1：2,t2:102
二元组：t1：3,t2:103
二元组：t1：4,t2:104
finish
```

可以发现个流被同时订阅，并且只有两个流中的数据都到达了，才被送到下游。

![image-20241205093139538](.\images\image-20241205093139538.png)



**combineLatest操作符**

```java
    @Test
    public void combineLatest() throws InterruptedException {
        Flux.combineLatest(
                Flux.range(0, 6)
                        .delayElements(Duration.ofMillis(100))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅1")),
                Flux.range(100, 5)
                        .delayElements(Duration.ofMillis(500))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅2")
                        ),
                (var1, var2) -> "数据1:" + var1 + ",数据2:" + var2
        ).subscribe((t) -> System.out.println("二元组" + t),
                e -> System.out.println("error" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
当前被订阅1
当前被订阅2
二元组数据1:3,数据2:100
二元组数据1:4,数据2:100
二元组数据1:5,数据2:100
二元组数据1:5,数据2:101
二元组数据1:5,数据2:102
二元组数据1:5,数据2:103
二元组数据1:5,数据2:104
finish
```



弹珠图:

![image-20241205094009730](.\images\image-20241205094009730.png)



### 8.5.6 流元素批处理

Project Reactor支持以下几种方式对流元素(Flux<T>)执行批处理

1. 将元素缓冲（buffering）到容器(如list)中，结果流的类型为Flux<List<T>>.
2. 通过开窗（windowing）方式，将元素加入诸如Flux<Flux<T>>等流中，请注意，现在流信息不是值，而是可以处理的子流。
3. 通过某些刍将元素分组（grouping）到具有`Flux<GroupedFlux<K,T>>`类型的流中。每个新键都会触发一个新的GroupFlux实例，并且具有该键的所有元素都将被推送到GroupFlux类的实例中。

可以基于以下场景进行开窗和缓冲操作：

1. 处理元素的数量。比如每10个元素一批处理。
2. 一段时间，比方说每5分钟一次。
3. 基于一些谓语，比方说在每个新的偶数之前切割。
4. 基于来自其他Flux的一个事件，该事件控制着执行过程。

**缓冲**

```java
    @Test
    public void buffer() {
        Flux.range(100, 13)
                .buffer(3).
                subscribe(System.out::println);
    }
```

输出：

```tex
[100, 101, 102]
[103, 104, 105]
[106, 107, 108]
[109, 110, 111]
[112]
```

buffer操作符将许多事件收集到一个事件集合中。该集合本身成为下游操作符的事件。当需要使用元素集合来生成一些请求，而不是使用仅包含一个元素的集合来生成许多小请求时，用缓冲区操作符来实现批处理会比较方便。

如可以将数据项缓冲几秒种然后批量插入，而不是逐个将元素插入数据库。



**windows操作符**

如果需要根据数据序列中的元素是否为素数进行开窗拆分，可以使用window操作符的变体`windowUntil`

```java
  @Test
    public void windowUntil() {
        Flux.range(101, 20)
                .windowUntil(this::isPrime)
                .subscribe(window -> window.collectList()
                        .subscribe(item -> System.out.println("windows:" + item)));
    }

    private boolean isPrime(Integer value) {
        if (value < 2) {
            return false;
        }
        if (value == 2 || value == 3) {
            return true;
        }
        if (value % 2 == 0) {
            return false;
        }

        double sqrt = Math.sqrt(value);
        for (int i = 3; i < sqrt; i++) {
            if (value % i == 0) {
                return false;
            }
        }

        return true;
    }
```

输出：

```tex
windows:[101]
windows:[102, 103]
windows:[104, 105, 106, 107]
windows:[108, 109]
windows:[110, 111, 112, 113]
windows:[114, 115, 116, 117, 118, 119, 120]
```

![image-20241205231445153](.\images\image-20241205231445153.png)

window操作符和buffer操作符类型，buffer操作符仅在缓冲区关闭时才会发出集合，而windows操作符会在事件到达时立即对其进行传播，以更快地做出响应并实现更复杂的工作流程。

**groupBy操作符**

groupBy操作符通过某些条件对响应流中的元素进行分组。通过对每个元素打一个标签（key），按照标签元素进行分组。

如：将整数序列按奇数和偶数进行分组，并仅跟踪每组中的最后两个元素。

```java
    @Test
    public void groupBy() {
        Flux.range(1, 11)
                .groupBy(item -> item % 2 == 0 ? "偶数" : "奇数")
                .subscribe(groupFlux -> {
                    groupFlux.scan(new ArrayList<>(),
                                    (list, element) -> {
                                        list.add(element);
                                        if (list.size() > 3) {
                                            list.remove(0);
                                        }
                                        return list;
                                    })
                            .filter(list -> !list.isEmpty())
                            .subscribe(item -> System.out.println("key:" + groupFlux.key() + "-->" + item));
                });
    }
```

输出：

```tex
key:奇数-->[1]
key:偶数-->[2]
key:奇数-->[1, 3]
key:偶数-->[2, 4]
key:奇数-->[1, 3, 5]
key:偶数-->[2, 4, 6]
key:奇数-->[3, 5, 7]
key:偶数-->[4, 6, 8]
key:奇数-->[5, 7, 9]
key:偶数-->[6, 8, 10]
key:奇数-->[7, 9, 11]
```

![image-20241205232659387](.\images\image-20241205232659387.png)

### 8.5.7 flatMap、concatMap和FlatMapSequential操作符

floatMap操作符在逻辑中由map和flatten这两个操作组成。

flatMap操作符的map部分将传入的每个元素转换为响应式流（`T->Flux<R>`)

flatten部分将所有的生成响应式流合并为一个新的响应式流，通过该流可以传递R类型的元素。

Project Reactor提供了FlatMap操作的一些不同变体，除了重载，该库还提供flatMapSequential操作符和concatMap操作符。

这三个操作符在以下几个方面有所不同：

1. 操作符是否立即订阅其内部流;

flatMap操作符和flatMapSequential操作符会立即订阅，而concatMap操作符则会在生成 下一个子流并订阅它之前等待每个内部完成。

2. 操作符是否保留生成元素的顺序。

concatMap天生保留与源元素相同的顺序，flatMapSequential操作符通过对所接收的元素进行排序来保留顺序，而flatMap操作符不一定保留原始排序。

3. 操作符是否对来自不同子流元素进行交错。

flatMap操作允许交错，而concatMap和flatMapSequential不允许交错。

floatMap案例

```java
    @Test
    public void floatMap() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .doOnNext(System.out::println)
                .flatMap(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("已经订阅"))
                ).subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```te
[1, 2, 3]
已经订阅
[a, b, c]
已经订阅
[7, 8, 9]
已经订阅
7
a
1
8
b
9
2
c
3
```



![image-20241205234250476](.\images\image-20241205234250476.png)

可以发现，三个流是立即被订阅的，不保留生成元素的顺序的。同时不同子流数据也会进行交错。



**concatMap**

```java
    @Test
    public void concatMap() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .doOnNext(System.out::println)
                .concatMap(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("已经订阅"))
                ).subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```tex
[1, 2, 3]
已经订阅
[a, b, c]
[7, 8, 9]
1
2
3
已经订阅
a
b
c
已经订阅
7
8
9
```

![image-20241205234722529](.\images\image-20241205234722529.png)

可以发现，流并不立即被订阅的，而是按顺序一个完成后，再订阅另外一个的，由于按顺序订阅所以数据是保留了原数据顺序，并且不会出现交错执行的情况。

**flatMapSequential操作符**

```java
    @Test
    public void flatMapSequential() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .flatMapSequential(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("订阅"))
                ).subscribe(System.out::println);
        Thread.sleep(2000);
    }
```

输出：

```tex
订阅
订阅
订阅
1
2
3
a
b
c
7
8
9
```

![image-20241205235252762](.\images\image-20241205235252762.png)



通过观察运行可以发现，三个流都是被立即订阅的，并且不允许出现元素交错的情况。



### 8.5.8 元素采样

对于高吞场景而言，通过应用采样技术处理一小部分是有意义的。

`sample`操作符和`sampleTimeout`操作符可以让流周期性的发出与时间窗口内最后看到的值相对应的数据项。

场景：每100ms就从流中取一个元素。

```java
    @Test
    public void sample() throws InterruptedException {
        Flux.range(1, 50)
                .delayElements(Duration.ofMillis(10))
                .sample(Duration.ofMillis(100))
                .subscribe(System.out::println);
        Thread.sleep(5000L);
    }
```

输出：

```tex
6
11
17
24
31
37
43
49
50
```

假如每10毫秒都顺序生成数据项，订阅者也只会收到所指定的约束条件内的一小部分事件。通过这种方法，我们可以在不需要传入事件就能成功操作的场景下使用被动限速。流控。

**sampleTimeout操作符**

```java
    @Test
    public void sampleTimeout() throws InterruptedException {
        Random rand = new Random();
        Flux.range(1, 20)
                .delayElements(Duration.ofMillis(100))
                //并发计算超时时间，调节速度快慢
                .sampleTimeout(item -> Mono.delay(Duration.ofMillis(rand.nextInt(100) + 50)), 20)
                .subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```tex
1
2
3
4
6
7
8
9
10
11
14
15
17
```



![image-20241206122228356](.\images\image-20241206122228356.png)



### 8.5.9 将响应式流转换为阻塞结构

Project Reactor库提供了一个API，用于将响应式流转换为阻塞结构。

以下选项来阻塞流，并同步生成结果：

1. toIterable方法将响应式Flux转换为阻塞Iterable.
2. toStream方法将响应式Flux转换为阻塞Stream API。从Reactor 3.2开始，在底层使用toIterable方法。
3. blockFirst方法阻塞了当前线程，直到上游发出第一个值或完成流为止。
4. blockLast方法阻塞了当前线程，直到上游发出最后一个流或者完成流为止。在OnError的情况下，它会在被阻塞的线程中抛出异常。

**toIterable**

```java
    @Test
    public void testToIterable() {
        Iterable<Integer> iterable = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .toIterable();
        System.out.println("-----------------");
        for (Integer value : iterable) {
            System.out.println("item:" + value);
        }
        System.out.println("finish");
    }
```

输出：

```tex
-----------------
item:1
item:2
item:3
finish
```

![image-20241206123109036](.\images\image-20241206123109036.png)

可以发现数据已经被转换为阻塞式的，按顺序一个一个输出：



**toStream**

```java
    @Test
    public void toStream() {
        Stream<Integer> stream = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .toStream();
        System.out.println("-----------------");
        stream.forEach((item) -> System.out.println("each:" + item));
        System.out.println("finish");
    }
```

输出：

```tex
-----------------
each:1
each:2
each:3
finish
```

效果与toIterable一样，一个一个的输出。

![image-20241206123521376](.\images\image-20241206123521376.png)



**blockFirst**

```java
    @Test
    public void blockFirst() throws InterruptedException {
        Integer blockFirst = Flux.just(1, 2, 3)
                .delayElements(Duration.ofMillis(500))
                .doOnNext(System.out::println)
                //此会阻塞主线程，直到收到第一个元素
                .blockFirst();
        System.out.println("-----------");
        System.out.println("获取值:" + blockFirst);
        Thread.sleep(5000L);
    }
```

输出：

```tex
1
-----------
获取值:1
```



![image-20241206123833937](.\images\image-20241206123833937.png)



**blockLast**

```java
    @Test
    public void blockLast() {
        Integer i = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .doOnEach(System.out::println)
                //该方法会阻塞，直到等到流中的最后一个元素或者完成
                .blockLast();
        System.out.println("----------");
        System.out.println("结果" + i);
        System.out.println("finish");
    }
```

输出:

```tex
doOnEach_onNext(1)
doOnEach_onNext(2)
doOnEach_onNext(3)
onComplete()
----------
结果3
finish
```

![image-20241206124312258](.\images\image-20241206124312258.png)



```java
    @Test
    public void blockLastSub() throws InterruptedException {
        Flux<Integer> integerFlux = Flux.just(1, 2, 3).delayElements(Duration.ofSeconds(1));
        integerFlux.subscribe(integer -> System.out.println("第一个订阅：" + integer));
        integerFlux.subscribe(integer -> System.out.println("第二个订阅：" + integer));
        integerFlux.subscribe(integer -> System.out.println("第三个订阅：" + integer));

        System.out.println("订阅结束...");

        Integer i = integerFlux.blockLast();
        System.out.println("阻塞等待最后一个元素：");
        System.out.println("value:" + i);
        Thread.sleep(5000);
    }
```

输出：

```tex
订阅结束...
第二个订阅：1
第一个订阅：1
第三个订阅：1
第一个订阅：2
第二个订阅：2
第三个订阅：2
第一个订阅：3
第三个订阅：3
第二个订阅：3
阻塞等待最后一个元素：
value:3
```

由此可以看出，此blockLast与subcribe这两个互不影响。独立运行。



### 8.5.10 在序列处理时查看元素

有时，我们需要对处理管道中的每个元素或特定信号执行操作，为满足此类要求，Project Reactor提供了以下方法：

1. `doOnNext(Consumer<T>)`使我们对Flux或者Mono上的每个元素执行一些操作。
2. `doOnComplete`和`doOnError(Throwable)`可以应用在相应的事件上。
3. `doOnSubscribe(Consumer<Subscription>)`、`doOnRequest(LongConsumber)`和`doOnCancel(Runable)`使我们能对订阅生命周期事件做出处理。
4. 无论什么原因导致的流终止，`doOnTerminate(runnable)`都会在流终止时被调用 。
   1. 此外Flux和Mono都提供了`doOnEarch(Consumer<Signal>)`方法，该方法处理表示响应流领域的所有信号。包括`onError`、`onSubscribe`、`onNext`、`OnError`、`OnComplete`

**异常信号打印**

```java
    @Test
    public void doOnEach() {
        Flux.just(1, 2, 3)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .doOnEach(item -> System.out.println("打印：" + item))
                .subscribe();
    }
```

输出:

```tex
打印：doOnEach_onNext(1)
打印：doOnEach_onNext(2)
打印：doOnEach_onNext(3)
打印：onError(java.lang.RuntimeException: 手动异常)
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxPrint.doOnEach(TestFluxPrint.java:17)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

doOnEach的弹珠图

![image-20241206134948889](.\images\image-20241206134948889.png)

其他信号的处理

```java
    @Test
    public void doSign() {
        Flux.just(1, 2, 3)
                .doOnNext(item -> System.out.println("doOnNext打印：" + item))
                .doOnComplete(() -> System.out.println("doOnComplete完成信号打印:"))
                .doOnError(e -> System.out.println("doOnError异常信号打印" + e))
                .doOnSubscribe(item -> System.out.println("订阅时打印:"))
                .doOnRequest((t) -> System.out.println("doOnRequest请求时打印:" + t))
                .doOnTerminate(() -> System.out.println("任何终止信号都会收到："))
                .doOnEach(item -> System.out.println("打印：" + item))
                .subscribe();
    }
```

输出：

```tex
订阅时打印:
doOnRequest请求时打印:9223372036854775807
doOnNext打印：1
打印：doOnEach_onNext(1)
doOnNext打印：2
打印：doOnEach_onNext(2)
doOnNext打印：3
打印：doOnEach_onNext(3)
doOnComplete完成信号打印:
任何终止信号都会收到：
打印：onComplete()
```



### 8.5.11 物化与非物化信号

将流中元素转换为Signal称为物化。将物化过的Signal对象转换为流即为非物化 。

有时采用信号进行流处理比采用数据进行处理更有用，为了将数据流转换为信号流并再次返回，Flox和Mono提供了materialize方法和dematerialize方法

```java
    @Test
    public void materialize() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                //将异常流转换为信号
                .materialize()
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("完成"));

        Thread.sleep(3000);
    }
```

输出：

```tex
item:false
next:onNext(1)
item:false
next:onNext(2)
item:false
next:onNext(3)
item:false
next:onError(java.lang.IllegalArgumentException: 手动异常)
item:true
完成
```

可以看此，此时异常已经被处理成了普通信号进行处理。不是收到了error信号

那如果不使用异常流转换呢？

```java
    @Test
    public void materialize2() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.err.println("error:" + e),
                        () -> System.out.println("完成"));

        Thread.sleep(3000);
    }
```

那此时输出：

```tex
item:false
next:1
item:false
next:2
item:false
next:3
item:false
error:java.lang.IllegalArgumentException: 手动异常
```

此时收到的就是错误信号了,此进如果没有对异常信息处理，那么将会被抛出去

```java
    @Test
    public void materialize2() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item));

        Thread.sleep(3000);
    }
```

输出:

```tex
item:false
next:1
item:false
next:2
item:false
next:3
item:false
[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
Caused by: java.lang.IllegalArgumentException: 手动异常
	at com.nullnull.recator.TestFluxPrint.materialize2(TestFluxPrint.java:57)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

物化后非物化的处理

```java
    @Test
    public void materializeEach() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnNext(item -> System.out.println("doOnNext信号:" + item))
                .materialize()
                //日志输出
                .log()
                //非物化处理
                .dematerialize()
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item));

        Thread.sleep(3000);
    }
```

输出：

```tex
[ INFO] (main) onSubscribe(FluxMaterialize.MaterializeSubscriber)
[ INFO] (main) request(unbounded)
doOnNext信号:1
[ INFO] (parallel-1) onNext(onNext(1))
item:false
next:1
doOnNext信号:2
[ INFO] (parallel-1) onNext(onNext(2))
item:false
next:2
doOnNext信号:3
[ INFO] (parallel-1) onNext(onNext(3))
item:false
next:3
[ INFO] (parallel-1) onNext(onError(java.lang.IllegalArgumentException: 手动异常))
[ INFO] (parallel-1) cancel()
item:false
[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
Caused by: java.lang.IllegalArgumentException: 手动异常
	at com.nullnull.recator.TestFluxPrint.materializeEach(TestFluxPrint.java:69)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

log方法，该方法使用可用的记录器记录所有处理过的信号。

![image-20241207151428057](.\images\image-20241207151428057.png)





### 8.6 以编程方式创建流

有时候，需要一种更复杂的方法来在流中生成信号，或将对象的生命周期绑定到响应式流的生命周期。

### 8.6.1 push和create方法

push工厂方法能够通过适配一个单线程生产者来创建Flux实例。

主要用于衔接外部数据。

此方法对于适配异步、单线程、多值API非常有用，而无须关注背压和取消，push本身包含背压和取消。

```java
    @Test
    public void push() throws InterruptedException {
        //将命令式流转换为响应式流,此处只能是单线程的
        Flux.push(new Consumer<FluxSink<Integer>>() {
                    @Override
                    public void accept(FluxSink<Integer> integerFluxSink) {
                        //通过单线程的方式，调用其他方法，其他方法的返回值，可以通过FluxSink追加到下游的响应式流中
                        IntStream.range(1, 100).forEach((t) -> integerFluxSink.next(t));
                    }
                }).delayElements(Duration.ofMillis(200))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("e:" + e),
                        () -> System.out.println("finish"));

        Thread.sleep(2000);
    }
```

输出：

```tex
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
```

使用lambda编写:

```java
    @Test
    public void pushLambda() throws InterruptedException {
        Flux.push(fluxSink -> IntStream.range(1, 100).forEach(fluxSink::next))
                //延迟200毫秒
                .delayElements(Duration.ofMillis(200))
                //订阅
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("e:" + e),
                        () -> System.out.println("finish"));

        Thread.sleep(2000);
    }
```

输出：

```tex
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
```

push工厂方法可以很方便地使用默认的背压和取消策略来适配异步的API

![image-20241207162831166](.\images\image-20241207162831166.png)



**create方法**

create与push方法类似，起到桥接的作用。

该方法不能从不同的线程发送事件。

```java
    /**
     * 事件处理器
     */
    static class MyEventProcess {
        private MyEventListener listener;
        private Random rand = new Random();

        /**
         * 注册回调的事件监听器
         *
         * @param listener
         */
        void register(MyEventListener listener) {
            this.listener = listener;
        }

        public void process() {
            //构建数据，向下游发送
            while (rand.nextInt() % 3 != 0) {
                List<String> dataChunk = new ArrayList<>();
                for (int i = 0; i < 10; i++) {
                    dataChunk.add("data-" + i);
                }
                //发送数据
                listener.onDataChunk(dataChunk);
            }
            //完成信号
            listener.processComplete();
        }
    }

    /**
     * 回调接口
     *
     * @param <T>
     */
    interface MyEventListener<T> {
        /**
         * 传递数据的信号
         *
         * @param chunk
         */
        void onDataChunk(List<T> chunk);

        /**
         * 处理数据的信号
         */
        void processComplete();
    }

    @Test
    public void create() throws InterruptedException {
        MyEventProcess process = new MyEventProcess();
        Flux<Object> objectFlux = Flux.create(fluxSink -> {
            //注册监听器
            process.register(new MyEventListener<String>() {
                @Override
                public void onDataChunk(List<String> chunk) {
                    //将数据发送到下游的响应式流中
                    for (String chunkItem : chunk) {
                        fluxSink.next(chunkItem);
                    }
                }

                @Override
                public void processComplete() {
                    //结束流的发送
                    fluxSink.complete();
                }
            });
        });
        objectFlux.subscribe(item -> System.out.println("item:" + item),
                e -> System.out.println("e" + e),
                () -> System.out.println("完成")
        );

        //开始生成数据
        process.process();
        Thread.sleep(5000);
    }
```

输出：

```tex
item:data-0
item:data-1
item:data-2
item:data-3
item:data-4
item:data-5
item:data-6
item:data-7
item:data-8
item:data-9
完成
```



**generate工厂方法**

generate工厂方法指在基于生成器的内部处理状态创建复杂序列。

它需要一个初始值和一个函数，该函数根据前一个状态计算下一个状态，并将onNext信号发送给下游的订阅者。

```java
@Test
    public void generate() throws InterruptedException {
        Flux.generate(
                        //用于构建初始值
                        new Callable<ArrayList<Long>>() {
                            @Override
                            public ArrayList<Long> call() throws Exception {
                                final ArrayList<Long> dataList = new ArrayList<>();
                                dataList.add(0L);
                                dataList.add(1L);

                                return dataList;
                            }
                        },//函数的处理逻辑
                        new BiFunction<ArrayList<Long>, SynchronousSink<Long>, ArrayList<Long>>() {
                            @Override
                            public ArrayList<Long> apply(ArrayList<Long> list, SynchronousSink<Long> sink) {
                                final Long getLong1 = list.get(list.size() - 1);
                                final Long getLong2 = list.get(list.size() - 2);
                                //向下游发送元素
                                sink.next(getLong1);

                                list.add(getLong1 + getLong2);

                                return list;
                            }
                        }

                ).delayElements(Duration.ofMillis(200))
                .take(10)
                .subscribe(
                        item -> System.out.println("next:" + item),
                        ex -> System.out.println("error:" + ex),
                        () -> System.out.println("完成")
                );

        Thread.sleep(3000L);
    }
```

输出:

```tex
next:1
next:1
next:2
next:3
next:5
next:8
next:13
next:21
next:34
next:55
完成
```

使用lambda表达式

```java
    @Test
    public void generateLambda() throws InterruptedException {
        Flux.generate(
                        () -> {
                            final ArrayList<Long> dataList = new ArrayList<>();
                            dataList.add(0L);
                            dataList.add(1L);

                            return dataList;
                        },
                        (list, sink) -> {
                            final Long getLong1 = list.get(list.size() - 1);
                            final Long getLong2 = list.get(list.size() - 2);
                            //向下游发送元素
                            sink.next(getLong1);

                            list.add(getLong1 + getLong2);

                            return list;
                        }

                ).delayElements(Duration.ofMillis(200))
                .take(10)
                .subscribe(
                        item -> System.out.println("next:" + item),
                        ex -> System.out.println("error:" + ex),
                        () -> System.out.println("完成")
                );

        Thread.sleep(3000L);
    }
```

输出:

```tex
next:1
next:1
next:2
next:3
next:5
next:8
next:13
next:21
next:34
next:55
完成
```

使用二元组

```java
    @Test
    public void generateTuples() throws InterruptedException {
        Flux.generate(() -> Tuples.of(0, 1),
                        (tuples, sink) -> {
                            sink.next(tuples.getT2());
                            int sumValue = tuples.getT1() + tuples.getT2();
                            return Tuples.of(tuples.getT2(), sumValue);
                        })
                .delayElements(Duration.ofMillis(300))
                .take(10)
                .subscribe(System.out::println);
        Thread.sleep(5000);
    }
```

输出:

```tex
1
1
2
3
5
8
13
21
34
55
```

在下一个值生成之前，每个新值都被同步传播组了订阅者。

当生成不同的复杂响应流，而该序列需要保持发射之彰的中间状态时，该方法非常有用。



**disposable** 

`using`工厂方法能根据一个`disposable`资源创建流，它在响应式编程中实现了`tr-with-resources`方法

这是一个模拟连接的对象

```java
    static class Connection implements AutoCloseable {
        private final Random rand = new Random();

        static Connection newConnection() {
            System.out.println("创建Connection对象");
            return new Connection();
        }

        public Iterable<String> getData() {
            if (rand.nextInt(10) < 3) {
                throw new RuntimeException("通信异常");
            }
            return Arrays.asList("数据1", "数据2");
        }

        /**
         * 关闭资源的方法，即使发生错误，也得关闭
         *
         * @throws Exception
         */
        @Override
        public void close() {
            System.out.println("关闭Connection连接");
        }
    }

```

传统的使用方法

```java
    @Test
    public void old() {
        try (Connection connection = Connection.newConnection()) {
            connection.getData().forEach(dat -> System.out.println("接收到的数据:" + dat));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```

输出:

```tex
创建Connection对象
接收到的数据:数据1
接收到的数据:数据2
关闭Connection连接
```

或者发生异常:

```tex
创建Connection对象
关闭Connection连接

java.lang.RuntimeException: java.lang.RuntimeException: 通信异常

	at com.nullnull.recator.TestFluxUsing.old(TestFluxUsing.java:47)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
Caused by: java.lang.RuntimeException: 通信异常
	at com.nullnull.recator.TestFluxUsing$Connection.getData(TestFluxUsing.java:26)
	at com.nullnull.recator.TestFluxUsing.old(TestFluxUsing.java:45)
	... 27 more
```

使用响应式流来操作

```java
    @Test
    public void using() {
        Flux.using(
                //获取连接
                Connection::newConnection,
                //正常执行方法
                connection -> Flux.fromIterable(connection.getData()),
                //执行关闭
                Connection::close
        ).subscribe(
                item -> System.out.println("next:" + item),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")

        );
    }
```

输出:

```tex
创建Connection对象
next:数据1
next:数据2
关闭Connection连接
finish
```

或者发生异常：

```tex
创建Connection对象
关闭Connection连接
error:java.lang.RuntimeException: 通信异常
```

即使发生了异常，连接也被关闭了。

连接的生命周期与流的生命周期绑定。

操作符还可以通知订阅者流终止之前或之后是否应该进行清除动作。



**usingWhen包装响应式事务**

与Using操作符类似，usingWhen操作符使我们能以响应式方式管理资源 。但是,using操作符同步获取受托管资源。同时,usingWhen操作符响应式地获取受托管资源（通过订阅Publisher的实例）。此外,usingWhen操作符接受不同的处理程序，以便应对主处理流终止的成功和失败。这些处理程序由发布者实现。

可以仅使用`usingWhen`一个操作符实现完全无阻塞的响应式事务。

```java
    public static class Transaction {
        private static final Random rand = new Random();
        private final int id;

        /**
         * 创建事务
         *
         * @param id
         */
        public Transaction(int id) {
            this.id = id;
        }

        /**
         * 开启响应式事务
         *
         * @return
         */
        public static Mono<Transaction> beginTransaction() {
            System.out.println("开启事务");
            return Mono.defer(() -> Mono.just(new Transaction(rand.nextInt())));
        }

        /**
         * 响应式插入数据
         *
         * @param rows
         * @return
         */
        public Flux<String> insertRow(Publisher<String> rows) {
            return Flux.from(rows)
                    .delayElements(Duration.ofMillis(500))
                    //将数据转换为响应式流
                    .flatMap(row -> {
                        if (rand.nextInt(10) < 3) {
                            return Mono.error(new IllegalArgumentException("出错条目:" + row));
                        } else {
                            return Mono.just(row);
                        }
                    });
        }

        /**
         * 提交事务
         *
         * @return
         */
        public Mono<Void> commit() {
            return Mono.defer(() -> {
                System.out.println("开始提交事务:");
                if (rand.nextBoolean()) {
                    return Mono.empty();
                } else {
                    return Mono.error(new RuntimeException("事务提交异常"));
                }
            });
        }

        /**
         * 响应式事务的回滚
         *
         * @return
         */
        public Mono<Void> rollback() {
            return Mono.defer(() -> {
                System.out.println("开始提交事务");
                if (rand.nextBoolean()) {
                    return Mono.empty();
                } else {
                    return Mono.error(new RuntimeException("回滚异常"));
                }
            });
        }
    }
```

使用`usingWhen`操作

```java
    /**
     * 使用usingWhen实现一个更新的事务
     */
    @Test
    public void usingWhen() throws InterruptedException {
        Flux.usingWhen(
                //提供资源
                Transaction.beginTransaction(),
                //插入数据
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("插入数据");
                        return transaction.insertRow(Flux.just("a", "b", "c"));
                    }
                },
                //正常提交事务
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("提交事务");
                        return transaction.commit();
                    }
                },
                //发生异常时，清理资源
                new BiFunction<Transaction, Throwable, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction, Throwable throwable) {
                        System.out.println("回滚事务");
                        return transaction.rollback();
                    }
                },
                //如果查询取消，清理资源
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("取消查询");
                        return null;
                    }
                }
        ).subscribe(event -> System.out.println("onNext:" + event),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
开启事务
插入数据
onNext:a
回滚事务
开始提交事务
error:java.lang.IllegalArgumentException: 出错条目:b
```

或者成功:

```tex
开启事务
插入数据
onNext:a
onNext:b
onNext:c
提交事务
开始提交事务:
finish
```

改成lambda

```java
    @Test
    public void usingWhenLambda() throws InterruptedException {
        Flux.usingWhen(
                //提供资源
                Transaction.beginTransaction(),
                //资源的使用，即插入数据
                transaction -> transaction.insertRow(Flux.just("a", "b", "c")),
                //提交事务
                transaction -> transaction.commit(),
                //发生异常，清理资源
                (transaction, throwable) -> transaction.rollback(),
                transaction -> transaction.rollback()

        ).subscribe(event -> System.out.println("onNext:" + event),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出：

```tex
开启事务
onNext:a
onNext:b
onNext:c
开始提交事务:
error:java.lang.RuntimeException: Async resource cleanup failed after onComplete
```

或者：

```tex
开启事务
onNext:a
onNext:b
onNext:c
开始提交事务:
finish
```

使用usingWhen操作符，不仅可以可以更容易的实以完全响应式的方式管理生命周期，还可以轻松实现响应式事务。



### 8.7 错误处理

`onError`信号是响应式流规范的一组成部分，一种将异常传播给可以处理它的用户，但是，如果最终订阅者没有为`onError`信号定义处理程序，那么将抛出`onError`抛异常。

响应式流的语义定义了`OnError`是一个终止操作，该操作之后流会停止执行。

我们可能采取以下策略中的一种做出不同响应：

1. 为`subscribe`操作符中的`OnError`信号定义处理程序。
2. 通过`OnErrorReturn`操作符捕获异常，并用一个默认静态值或一个异常中计算出的值替换它。
3. 通过`OnErrorResume`操作符捕获异常并执行备用工作流。
4. 通过`OnErrorMap`操作符获取并将其转换为另一个异常来更好地表现当前场景。
5. 定义一个在发生错误时重新执行的响应式工作流。如果源响应序列发出错误信号 ，那么`retry`操作符会重新订阅该序列。

**OnError信号**

```java
    /**
     * 仅处理OnNext事件，没有处理OnError，则抛出异常
     */
    @Test
    public void onError() {
        Flux.from(new Publisher<String>() {
            @Override
            public void subscribe(Subscriber<? super String> s) {
                s.onError(new RuntimeException("手动异常"));
            }
        }).subscribe(System.out::println);
    }
```

输出:

```tex
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxOnError$1.subscribe(TestFluxOnError.java:25)
	at reactor.core.publisher.FluxSource.subscribe(FluxSource.java:66)
	at reactor.core.publisher.Flux.subscribe(Flux.java:8095)
	at reactor.core.publisher.Flux.subscribeWith(Flux.java:8268)
	at reactor.core.publisher.Flux.subscribe(Flux.java:8065)
	at reactor.core.publisher.Flux.subscribe(Flux.java:7989)
	at reactor.core.publisher.Flux.subscribe(Flux.java:7932)
	at com.nullnull.recator.TestFluxOnError.onError(TestFluxOnError.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

对Error进行处理

```java
    /**
     * 处理Error信号，则不再抛出
     */
    @Test
    public void onError1() {
        Flux.from(new Publisher<String>() {
            @Override
            public void subscribe(Subscriber<? super String> s) {
                s.onError(new RuntimeException("手动异常"));
            }
        }).subscribe(System.out::println,
                e -> System.out.println("error:" + e),
                () -> System.out.println("完成信号")
        );
    }
```

输出:

```tex
error:java.lang.RuntimeException: 手动异常
```

服务的代码:

```java
    private static Random rand = new Random();

    public static Flux<String> recommendedBooks(String userId) {
        return Flux.defer(() -> {
            if (rand.nextInt(10) < 5) {
                return Flux.<String>error(new RuntimeException("异常信息"))
                        //指定向后推移指定时间，元素发射频率不变
                        .delaySequence(Duration.ofMillis(100));
            } else {
                return Flux.just("JAVA编程思想", "重构")
                        .delayElements(Duration.ofMillis(50));
            }
        }).doOnSubscribe(item -> System.out.println("请求:" + userId));
    }
```

**onErrorReturn**

捕获异常，并用一个默认静态值或一个异常中计算出的值替换它。

```java
@Test
    public void onErrorReturn() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorReturn("代码大全")
                .subscribe(item -> System.out.println("next:" + item),
                        ex ->{
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号");
                            latch.countDown();
                        }
                );

        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

异常时输出：

```tex
请求:user-001
next:代码大全
完成信号
执行等待开始
执行等待结束
```



**onErrorResume**

捕获异常并执行备用工作流。

```java
    @Test
    public void onErrorResume() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);


        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorResume(event -> Flux.just("代码整洁之前"))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号");
                            latch.countDown();
                        }
                );

        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

执行完成：

```tex
请求:user-001
执行等待开始
next:JAVA编程思想
next:重构
完成信号
执行等待结束
```

发生异常时：

```tex
请求:user-001
next:代码整洁之前
完成信号
执行等待开始
执行等待结束
```

**onErrorMap**

获取并将其转换为另一个异常来更好地表现当前场景。

```java
    @Test
    public void OnErrorMap() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorMap(throwable -> {
                    if (throwable.getMessage().equals("异常信息")) {
                        return new Exception("转换异常");
                    } else {
                        return new Exception("未知");
                    }
                })
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号:");
                            latch.countDown();
                        }
                )
        ;
        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

输出：

```tex
请求:user-001
error:java.lang.Exception: 转换异常
执行等待开始
执行等待结束
```





**retry**

重新订阅该序列

```java
   @Test
    public void retry() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user).retry(3))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("处理完成");
                            latch.countDown();
                        }
                );
        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```



输出：

正常结束：

```tex
请求:user-001
请求:user-001
请求:user-001
执行等待开始
next:JAVA编程思想
next:重构
处理完成
执行等待结束
```

可以看出此处正常执行了一次失败了，然后重试了一次成功。

异常结束:

```tex
请求:user-001
请求:user-001
请求:user-001
请求:user-001
error:java.lang.RuntimeException: 异常信息
执行等待开始
执行等待结束
```

Project Reactor提供了丰富的工具集，可以帮助处理异常情况，从而提高应用程序的回弹性。



### 8.8 背压处理

尽管响应式流规范要求将背压构建到生产者和消费者之间的通信中，但这仍然可能使消费者溢出。

一些消费者可能无意识的请求无界队列，然后无法处理生成的负载。

另一些消费者则可能传入消息的速度有严格的限制。比如。数据库客户端每秒不能插入超过1000条记录。在这种情况下，事件批处理技术可能有所帮助。

可以通过以下配制流以处理背压情况：

1. `onBackPressureBuffer`操作符会请求无界需求并将返回的元素推送到下游，如果下游消费者无法跟上，元素将缓存在队列中。
2. `onBackPressureDrop`操作符也请求无界需求（Long.MAV_VALUE）并向下游推送数据，如果下游请求数量不足，那么元素会被丢弃。自定义处理程序可以用来处理已丢弃的元素。
3. `onBackPressureLast`操作符与`onBackPressureDrop`的工作方式类似。只是会记住最近收到的元素，并在需求出现时立即将其推向下游。
4. `onBackPressureError`操作符在尝试向下游推送数据时，请求无界需求。如果下游消费者无法跟上，则操作符会引发错误。
5. 背压管理的另外一种方法是速度限制，`limit(n)`操作符将下游需求拆分为不大于n的较小批次，可以保护脆弱的生产者免受来自下游消费者的不合理数据请求的破坏。`limitRate(n)`操作符会限制来自下游消费者的需求（总请求值）如，limitRequest(100)确保不会向生产者请求超过100个元素，发送100个事件后，操作符成功关闭流。

**onBackpressureBuffer**

会请求无界需求并将返回的元素推送到下游，如果下游消费者无法跟上，元素将缓存在队列中。

```java
    @Test
    public void OnBackpressureBuffer() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 100)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureBuffer(10)
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

如果超出缓存的数量无法处理，则出现异常：

```tex
等待开始
next:1
error:reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)
等待结束

```

修改产生的数量，变以10，让其能够处理：则输出：

```java
//修改：
Flux.range(1, 100)
// 变为    
Flux.range(1, 10)
```



```java
等待开始
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
next:10
完成：
等待结束
```



**onBackPressureDrop**

下游请求数量不足，那么元素会被丢弃

```java
    @Test
    public void onBackpressureDrop() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 100)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureDrop()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
......
next:30
next:31
next:32
完成：
等待结束
```

可以发现，32以后的元素都被丢弃。

**onBackpressureLast**

`onBackPressureDrop`的工作方式类似。只是会记住最近收到的元素

```java
    @Test
    public void onBackpressureLast() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 500)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureLatest()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
......
next:30
next:31
next:32
next:162
next:163
next:164
......
next:183
next:184
next:185
next:330
next:331
next:332
......
next:350
next:351
next:352
next:353
next:498
next:499
next:500
完成：
等待结束
```

可以发现，最新的无素都被收到，而老的元素，则被丢弃。



**onBackpressureError**

如果下游消费者无法跟上，则操作符会引发错误

```java
    @Test
    public void onBackpressureError() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 500)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureError()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
next:4
error:reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)
等待结束
```



**limit**

```java
    @Test
    public void limit() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 150)
                .delayElements(Duration.ofMillis(1))
                .limitRate(2)
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
next:4
next:5
......
next:144
next:145
next:146
next:147
next:148
next:149
next:150
完成：
等待结束
```

弹珠图

![image-20241208141925840](.\images\image-20241208141925840.png)



### 8.9 热数据与冷数据

冷发布者行为方式：无论订阅者何时出现，都为该订阅者生成所有序列数据，没有订阅者就不会生成数据。

**冷发布者**

```java
    @Test
    public void cold() {
        Flux<String> coldPublisher = Flux.defer(() -> {
            System.out.println("生成新的数据");
            return Flux.just(UUID.randomUUID().toString());
        });
        System.out.println("尚未收到新的数据");
        coldPublisher.subscribe(item -> System.out.println("next1:" + item));
        coldPublisher.subscribe(item -> System.out.println("next2:" + item));
        System.out.println("为两个订阅者生成了两次数据");
    }
```

输出：

```tex
尚未收到新的数据
生成新的数据
next1:966d48b6-edf2-4dda-aa7b-0ffe8d427234
生成新的数据
next2:79dac838-3b1b-4ae3-a8ea-8cb330fd703f
为两个订阅者生成了两次数据
```



每当订阅者出现的时候，都会有一个新的序列生成，而这些语义可以代表HTTP请求



**热发布者**

热发布者中的数据生成不依赖于订阅者而存在。因此，热发布者可能在第一个订阅者出现之前开始生成元素。

热发布者代表数据广播场景，如股价一旦发生变化，热发布者就可以向其订阅者广播有关的当前股票的最新的价格。当订阅者到达时，它仅接收未来的价格更新，而不接受先前价格历史。Reactor库中的大多数据热发布者扩展了Processor接口，但是,just工厂方法会生成 一个热发布者，因为它的值只在构建发布者时计算一次，并且订阅者到达时不会重新计算。

可以通过将just包装在defer中来将其转换为冷发布者。这样即使just在初始化时生成 值，这样初始化也只会在新订阅出现时发生。后一种行为由defer工厂方法决定。

**多播流元素**

通过响应式将冷发布者转换为热发布者。

一旦所有订阅者准备好生成 数据，希望在几个订阅者之间共享冷处理的结果，同时，我们又不希望为每个订阅者重新生成数据。Project Reactor为此目的提供了`ConectableFlux`

`ConectableFlux`,不仅可以生成数据以满足最急迫的需求，还会缓存数据，以便所有其他订阅者可以按照自己的速度处理数据。队列和超时的大小可以通过publish方法和replay方法进行配置。

此外,`ConnectableFlux`可以使用`connect`,`autoConnect(n)`,`refCount(n)`和`refCount(int,Duration)`等方法自动跟踪下游订阅者的数据，以便 在达到所需阈值时触发执行操作。

```java
    @Test
    public void ConnectableFlux() {
        Flux<Integer> source = Flux.range(0, 3)
                .doOnSubscribe(s -> System.out.println("对冷发布者的新订阅票据" + s));
        //由冷发布者转变为热发布者
        final ConnectableFlux<Integer> conn = source.publish();
        conn.subscribe(item -> System.out.println("next1:" + item));
        conn.subscribe(item -> System.out.println("next2:" + item));
        System.out.println("所有订阅都都准备好建立连接了");
        //激活为热数据开始执行。
        conn.connect();
    }
```

输出：

```tex
所有订阅都都准备好建立连接了
对冷发布者的新订阅票据reactor.core.publisher.FluxRange$RangeSubscription@675d3402
next1:0
next2:0
next1:1
next2:1
next1:2
next2:2
```



弹珠图

![image-20241208220701716](.\images\image-20241208220701716.png)



**缓存流元素**

使用`ConectableFlux`可以轻松实现不同的数据缓存策略。但是,Reactor已经以`cache`操作符的形式提供了用于事件缓存的API。

`cache`操作符使用`ConnectableFlux`,因为它的主要附加值是它所提供一个流式而直接的API。

可以调整缓存所容纳的数据量以及每个缓存项的到期时间。

```java
    @Test
    public void cache() throws InterruptedException {
        Flux<Integer> source = Flux.range(0,3)
                .doOnSubscribe(s -> System.out.println("冷发布者的新订阅票据"));
        final  Flux<Integer> cacheSource = source.cache(Duration.ofMillis(200));
        cacheSource.subscribe(item -> System.out.println("订阅者1-next:"+item));
        cacheSource.subscribe(item -> System.out.println("订阅者2-next:"+item));
        Thread.sleep(300);
        cacheSource.subscribe(item -> System.out.println("订阅者3-next:"+item));
    }
```

输出：

```tex
冷发布者的新订阅票据
订阅者1-next:0
订阅者1-next:1
订阅者1-next:2
订阅者2-next:0
订阅者2-next:1
订阅者2-next:2
冷发布者的新订阅票据
订阅者3-next:0
订阅者3-next:1
订阅者3-next:2
```

从过程中可以看出，订阅者1和订阅者2，都使用缓存的订阅数据，因为此时还只有一个订阅票据，而当缓存过期后，此时产生了一个新的订阅票据。也就是说缓存失效了，重新生成了订阅票据。重新生成了数据流。

弹珠图：

![image-20241208221619728](.\images\image-20241208221619728.png)



**共享流元素**

我们可以使用`ConnectableFlux`向几个订阅者多播事件。但是需要等待订阅者出现才能开始处理。

`share`操作符可以将冷发布者转换为热发布者。该操作符会为每个新的订阅者传播订阅者尚未错过的事件。

通过此可以做，什么时候订阅，什么时候给数据

```java
    @Test
    public void share() throws InterruptedException {
        Flux<Integer> source = Flux.range(0, 5)
                .delayElements(Duration.ofMillis(100))
                .doOnSubscribe(item -> System.out.println("冷发布者新的订阅票据" + item));
        Flux<Integer> cacheSource = source.share();
        cacheSource.subscribe(item -> System.out.println("订阅者1- next:" + item));
        Thread.sleep(400);
        cacheSource.subscribe(item -> System.out.println("订阅者2- next:" + item));
        Thread.sleep(1000);
    }
```

输出：

```tex
冷发布者新的订阅票据reactor.core.publisher.FluxConcatMap$ConcatMapImmediate@42e26948
订阅者1- next:0
订阅者1- next:1
订阅者1- next:2
订阅者1- next:3
订阅者2- next:3
订阅者1- next:4
订阅者2- next:4
```

通过观察可以发布，订阅者2，相比于订阅者1，晚执行了400毫秒，此时订阅者只收到了数据3和4，少了之前的数据。其于此实现了什么时候订阅，什么时候给最新的数据。

### 8.10 处理时间

响应式编程是异步的，因此它本身假定存在时序。

基于Project Reactor，可以使用`interval`操作符生成基于一定持续时间的事件，使用`delayElements`操作符生成延迟元素，并使用`delaySequence`操作符延迟所有信号。

Reactor的API使用能对一些与时间相关的事件做出响应。

`timestamp`操作符用于输出元素的时间戳。

`timeout`操作符用于指定消息时间间隔的大小。

`elapsed`操作符测量与上一个事件的时间间隔。

**interval操作符**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period )
```

指定元素之间的间隔。

```java
    @Test
    public void interval() throws InterruptedException {
        //指定每个元素之间的时间间隔
        Flux.interval(Duration.ofMillis(200))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        System.out.println("当前的线程名称:"+Thread.currentThread().getName());
        Thread.sleep(2000);

    }
```

输出：

```tex
当前的线程名称:main
parallel-1---->0
parallel-1---->1
parallel-1---->2
parallel-1---->3
parallel-1---->4
parallel-1---->5
parallel-1---->6
parallel-1---->7
parallel-1---->8
结束
parallel-1---->9
```

可发现订阅者是在另外的线程中运行。而非当前线程。

查看弹珠图：

![image-20241208224040167](.\images\image-20241208224040167.png)

**interval-2**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration delay,
    @NotNull  java.time.Duration period )
```

指定延迟时间及时间间隔



```java
    @Test
    public void interval2() throws InterruptedException {
        //参数1：指定第一个元素发送的时间与订阅时间的时间差。
        //参数2： 指定生成的序列元素之间的时间间隔。
        Flux.interval(Duration.ofSeconds(2), Duration.ofMillis(200))
                .subscribe(item -> System.out.println("onext:" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
onext:0
onext:1
onext:2
onext:3
onext:4
结束
onext:5
```

弹珠图:

![image-20241208224541205](.\images\image-20241208224541205.png)

**interval-3**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period,
    @NotNull  reactor.core.scheduler.Scheduler timer )
```

指定生成的序列以什么样的方式来运行。

```java
    @Test
    public void interval3() throws InterruptedException {
        Flux.interval(Duration.ofMillis(200), Schedulers.parallel())
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
parallel-1---->0
parallel-1---->1
parallel-1---->2
parallel-1---->3
parallel-1---->4
parallel-1---->5
parallel-1---->6
parallel-1---->7
parallel-1---->8
parallel-1---->9
parallel-1---->10
parallel-1---->11
parallel-1---->12
parallel-1---->13
结束
parallel-1---->14
```

**interval-4**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period,
    @NotNull  reactor.core.scheduler.Scheduler timer )
```

指定生成的序列在指定的线程中运行。

```java
    @Test
    public void interval4() throws InterruptedException {
        Flux.interval(Duration.ofMillis(200), Schedulers.newSingle("sch-"))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
sch--1---->0
sch--1---->1
sch--1---->2
sch--1---->3
sch--1---->4
sch--1---->5
sch--1---->6
sch--1---->7
sch--1---->8
sch--1---->9
sch--1---->10
sch--1---->11
sch--1---->12
sch--1---->13
结束
sch--1---->14
```



**delayElements**

```java
    @Test
    public void delayElements() throws InterruptedException {
        Flux.range(1, 10)
                //对每个元素之间的时间间隔进行指定时间
                .delayElements(Duration.ofSeconds(1))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(5000);
        System.out.println("结束");
    }
```

输出：

```tex
parallel-1---->1
parallel-2---->2
parallel-3---->3
parallel-4---->4
结束
```



![image-20241208230459540](.\images\image-20241208230459540.png)



**delaySequence操作符**

```java
    @Test
    public void delaySequence() throws InterruptedException {
        Flux.range(1, 10)
                //指定数据延迟发布的时间与第一个元素的时间间隔，即数据整体延迟3秒后全部发出
                .delaySequence(Duration.ofSeconds(3))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item + "<>" + LocalDateTime.now()));
        System.out.println("开始:" + LocalDateTime.now());
        Thread.sleep(5000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:2024-12-08T23:09:18.771
parallel-1---->1<>2024-12-08T23:09:21.770
parallel-1---->2<>2024-12-08T23:09:21.771
parallel-1---->3<>2024-12-08T23:09:21.771
parallel-1---->4<>2024-12-08T23:09:21.771
parallel-1---->5<>2024-12-08T23:09:21.771
parallel-1---->6<>2024-12-08T23:09:21.771
parallel-1---->7<>2024-12-08T23:09:21.771
parallel-1---->8<>2024-12-08T23:09:21.771
parallel-1---->9<>2024-12-08T23:09:21.772
parallel-1---->10<>2024-12-08T23:09:21.772
结束
```



**timeOut**

对响应流进行约束，响应流中的等待时间不能超过指定的时间

```java
    @Test
    public void timeOut() throws InterruptedException {
        Random rand = new Random();
        CountDownLatch latch = new CountDownLatch(1);
        Flux.interval(Duration.ofMillis(300))
                //时间超过指定毫秒后直接报异常
                .timeout(Duration.ofMillis(rand.nextInt(20) + 290))
                .subscribe(item -> System.out.println(item),
                        ex ->
                        {
                            System.out.println("ex:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("finish");
                            latch.countDown();
                        }
                );
        System.out.println("开始:");
        latch.await(3, TimeUnit.SECONDS);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
0
1
ex:java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 299ms in 'source(FluxInterval)' (and no fallback has been configured)
结束
```

弹珠图：

![image-20241208231808564](.\images\image-20241208231808564.png)



**timestamp操作符**

为响应式流的每个元素都生成一个时间戳

```java
    @Test
    public void timestamp() throws InterruptedException {

        Flux.interval(Duration.ofMillis(300))
                .timestamp()
                .subscribe(item -> {
                            Long timestamp = item.getT1();
                            long element = item.getT2();
                            System.out.println("元素：" + element + "的时间戳:" + timestamp);
                        }
                );
        System.out.println("开始:");
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
元素：0的时间戳:1733671378335
元素：1的时间戳:1733671378640
元素：2的时间戳:1733671378932
元素：3的时间戳:1733671379239
元素：4的时间戳:1733671379527
元素：5的时间戳:1733671379831
元素：6的时间戳:1733671380137
元素：7的时间戳:1733671380430
元素：8的时间戳:1733671380735
结束
元素：9的时间戳:1733671381038
```

弹珠图：

![image-20241208232658572](.\images\image-20241208232658572.png)

**elapsed操作符**

为响应式流中的每个元素与上一个元素的时间间隔

```java

    @Test
    public void elapsed() throws InterruptedException {
        Flux.interval(Duration.ofMillis(300))
                .elapsed()
                .subscribe(item -> {
                            Long interval = item.getT1();
                            long element = item.getT2();
                            System.out.println("元素：" + element + "与上一个元素的时间间隔:" + interval + "ms");
                        }
                );
        System.out.println("开始:");
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
元素：0与上一个元素的时间间隔:318ms
元素：1与上一个元素的时间间隔:295ms
元素：2与上一个元素的时间间隔:304ms
元素：3与上一个元素的时间间隔:288ms
元素：4与上一个元素的时间间隔:312ms
元素：5与上一个元素的时间间隔:287ms
元素：6与上一个元素的时间间隔:306ms
元素：7与上一个元素的时间间隔:309ms
元素：8与上一个元素的时间间隔:289ms
结束
元素：9与上一个元素的时间间隔:309ms
```

弹珠图：

![image-20241208232755236](.\images\image-20241208232755236.png)



### 8.11 组合和转换响应式流

当我们构建复杂的响应流工作流时，通常需要在几个不同的地方用相同的操作符序列。

`transform`操作符，可以将这些常见的部分提取到单独的对象中，并在需要时重用它们。

`transform`操作符，可以增强流结构本身。

```java
    @Test
    public void transform() {
        Function<Flux<String>, Flux<String>> logUserInfo = stream ->
                stream.index().doOnNext(
                        item -> System.out.println("时间戳:" + item.getT1() + ",元素：" + item.getT2())
                ).map(Tuple2::getT2);

        Flux.range(100, 3)
                .map(i -> "转换-" + i)
                .transform(logUserInfo)
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("finish")
                );
    }
```

输出：

```tex
时间戳:0,元素：转换-100
next:转换-100
时间戳:1,元素：转换-101
next:转换-101
时间戳:2,元素：转换-102
next:转换-102
finish
```

弹珠图:

![image-20241209121242109](D:\work\nullnull\learn\learn-md\webflex\images\image-20241209121242109.png)

`transform`操作符仅在流生命周期的组装阶段更新一次流行为，可以在响应式的应用程序中实现代码重用。



### 8.12 处理器

响应式流规范定了Processor接口，Processor既是Publisher也是Subscriber。

因此，即可以订阅Processor实例，也可以手动向它发送信号（onNext、onErro和OnComplete)。

Reactor的作者建议忽略处理器，因为他们很难用并且容易出错。

在大多数情况下，处理器可以被操作符的组合所取代。另外生成器工厂方法（push、create和generate）可能更适合适配外部API。

Reactor提出以下几种处理器：

- `Direct`处理器只能通过操作处理器的接收器来推送用户手动操作而产生的数据。
  - `DirectProcessor`和`UnicaseProcessor`是这组处理器的代表。
  - `DirectProcessor`不处理背压，可用于向多个订阅者发布事件。
  - `UnicastProcessor`使用内部队列处理背压，最多只能为一个`Subscriber`服务。
- `Synchronous`处理器
  - `EmitterProcessor`和 `replayProcessor`可以同时通过手动方式和订阅上游Publisher的方式来推送数据。
  - `EmitterProcessor`可以为多个订阅者提供服务并满足它们的需求，但仅能以同步方式消费单一Publisher产生的数据。
  - `ReplayProcessor`的行为类似于`EmitterProcessor`,但是它能使用几种策略来缓存传入的数据。
- Asynchronous处理器
  - `workQueueProcessor`和`TopicProcessor`可以推送从多个上游发布者处获得的下游数据。
  - 为了处理多个上游发布者，这些处理器使用RingBuffer的数据结构。这些处理器具有专用的构建器API，因为配置选项的数软件管家使它们很难初始化。
  - `WorkQueueProcessor`具有与`TopicProcessor`类似的特性，但是，它放宽了一个响应式流要求，这便它在运行时所使用的资源更少。



### 8.13 测试与调度Project Reactor

Reactor库附带了一个通用的测试框架。`io.projectreactor:reactor-test`库提供了测试Project Reactor所实现的响应式工作流所需的所有必要工具。

虽然响应式代码不那么容易调度，从早到晚 Project Reactor提供了能在需要时简化调试过程的技术。与任何基于回调的框架一样。Project Reactor中的栈跟踪信息量不大。它们没有在代码中给出发生异常情况的准确位置。Reactor库库具有面向调试的组装时检测功能。可使用：

```java
Hooks.onOperatorDebug();
```

示例程序

```java
    @Test
    public void onDebug()
    {
        Hooks.onOperatorDebug();

        Flux.range(1,10)
                .map(item -> "map-"+item)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .subscribe(System.out::println);
    }
```

输出：

```tex
map-1
map-2
map-3
map-4
map-5
map-6
map-7
map-8
map-9
map-10
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:19)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Assembly trace from producer [reactor.core.publisher.FluxError] :
	reactor.core.publisher.Flux.error(Flux.java:871)
	com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
Error has been observed at the following site(s):
	|_      Flux.error ⇢ at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
	|_ Flux.concatWith ⇢ at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
Stack trace:
		at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:19)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:568)
		at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
		at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
		at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
		at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
		at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
		at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
		at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
		at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
		at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
		at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
		at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
		at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
		at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
```

启用后，此功能开始收集将要组装的所有流的栈跟踪，稍后此信息可以基于组装信息扩展栈跟踪信息，从而帮助我们更快地现问题，但是创建栈跟踪的过程成本很高，因此作为最后的技术手段，它就只以受控的方法进行激活。



此外Project Reactor的Flux和Mono类型提供了一个被称为log的便捷方法。它能记录使用操作符的所有信号，即便在调试情况下，许多方法自定义实现也可以提供足够的自由度来跟踪所需的数据。

```java
    @Test
    public void onLog() {
        Flux.range(1,5)
                .map(item -> "map-"+item)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .log()
                .subscribe(System.out::println);
    }
```

输出：

```tex
[ INFO] (main) onSubscribe(FluxConcatArray.ConcatArraySubscriber)
[ INFO] (main) request(unbounded)
[ INFO] (main) onNext(map-1)
map-1
[ INFO] (main) onNext(map-2)
map-2
[ INFO] (main) onNext(map-3)
map-3
[ INFO] (main) onNext(map-4)
map-4
[ INFO] (main) onNext(map-5)
map-5
[ERROR] (main) onError(java.lang.RuntimeException: 手动异常)
[ERROR] (main)  - java.lang.RuntimeException: 手动异常
java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onLog(TestFluxDebug.java:28)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onLog(TestFluxDebug.java:28)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

### 8.14 Reactor插件

Project Reactor是一个通用且功能丰富的库，但是，它无法容纳所所有用的响应式工具，因此有一些项目在一个领域扩展了Reactor的功能，官方的Reactor插件为Reactor项目提供了几个模块。

`reactor-adapter`模块为Rxjava2响应式类型和调度程序提供桥接，此外，该模块还能与Akka进行集成。

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-adapter</artifactId>
    <version>3.4.0</version>
</dependency>
```

`reactor-logback`模块提供高速异步日志记录功能。它以logBack的AsyncAppender和LMAX Disruptor的RingBuffer为基础，其中后者通过Reactor的Processor实现

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-logback</artifactId>
    <version>3.2.6.RELEASE</version>
</dependency>
```

reactor-extra 模块包含用于高级需求的其他实用程序。例如，该模块包含 TupleUtils类，该类简 化了编写 Tuple 类的代码。此外，该模块具有 MathFlux类，可以从数字源中计算最小值和最大值，并 对它们求和或取平均。 ForkJoinPoolScheduler 类使 Java 的 ForkJoinPool 适配 Reactor 的  Scheduler。

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-extra</artifactId>
    <version>3.4.0</version>
</dependency>
```

此外，Project Reactor 生态系统还为流行的异步框架和消息代理服务器提供了响应式驱动程序。 Reactor RabbitMQ 模块使用熟悉的 Reactor API 为 RabbitMQ 提供了一个响应式 Java 客户端。 该模块不仅提供具有背压支持的异步非阻塞消息传递，还使应用程序能够通过使用 Flux和 Mono 类 型将 RabbitMQ 用作消息总线。

```xml
<dependency>
    <groupId>io.projectreactor.rabbitmq</groupId>
    <artifactId>reactor-rabbitmq</artifactId>
    <version>1.5.0</version>
</dependency>
```

Reactor Kafka 模块为 Kafka 消息代理服务器提供了类似的功能。

```xml
<dependency>
    <groupId>io.projectreactor.kafka</groupId>
    <artifactId>reactor-kafka</artifactId>
    <version>1.3.1</version>
</dependency>
```

另一个广受欢迎的 Reactor 扩展被称为 Reactor Netty。它使用 Reactor 的响应式类型来适配Netty  的 TCP/HTTP/UDP 客户端和服务器。Spring WebFlux 模块在内部使用 Reactor Netty 来构建非阻塞式  Web 应用程序。

```xml
<dependency>
    <groupId>io.projectreactor.netty</groupId>
    <artifactId>reactor-netty</artifactId>
    <version>1.0.2</version>
</dependency>
```





## 9 Project Reactor 高级

### 9.1 响应式流的生命周期

要理解多线程的工作原理以及Reactor中实现的各种内部优化，首先必须了解Reactor中响应式类型的生命周期。

**组装时**

流生命周期的第一部分是组装时（assembly-time）

Reactor提供了一个流式API，用于构建复杂的元素处理流程。

Reactor的API看起来像是一个组合流程中所选择操作符的构建器。

构建器不仅是可变的，还假设像build这样的终端操作会执行另一个对象的构建。

在响应式库中，构建执行流程的过程称为组装（assembing）。

如果从头开发，不考滤Reactor API,流组装的可能表现形式:

```java
Flux<Integer> sourceFlux = new FluxArray(1,20,300,4000);
Flux<String> mapFlux = new MapFlux(sourceFlux,String::valueOf);
Flux<String> filterFlux = new Flux(mapFlux,s -> s.length() > 1);
//...
```

在底层Flux对象是相互组合的。在组装过程中，就获得了一个Publishers链，每个新的Publisher包装前一个。

伪代码：

```java
FluxFilter(
	FluxMap(
    	FiluaArray(1,20,300,4000);
    )
)
```

在流生命周期中，该阶段着重要的作用，因为在流组装期间，可以通过检测流的类型来一个接一个地替换操作符。

```java
	public final Flux<T> concatWith(Publisher<? extends T> other) {
		if (this instanceof FluxConcatArray) {
			@SuppressWarnings({ "unchecked" })
			FluxConcatArray<T> fluxConcatArray = (FluxConcatArray<T>) this;

			return fluxConcatArray.concatAdditionalSourceLast(other);
		}
		return concat(this, other);
	}
```

如果是FluxConcatArray，则不创建新的流，直接加入到链中，以这种方式可以改善整体流性能。

此外在组装时，可以在组装过程中为流提供一些hooks，并启用一些额外的日志记录、跟踪、度量收集，以及其他在调试或者流监控期间可以有用的重要补充。

在该阶段，可以操作流的构建过程并应用不同的技术来优化、监控或者更好的进行流调试，这是构建响应流必不可少的部分。



**订阅时**

流执行生命周期的第二个重要阶段是订阅（subscription-time）

当调用指定的Publisher的subscribe方法时，就会发生订阅。

为了构建执行流程，对Publisher进行相互传递，因而产生了Publisher链。一旦调用 了顶层包装器subscribe方法，就开始了该链的订阅过程。

最终将得到一个订阅的相互包装链

```java
filterFlux.subscribe(Subscriber) {
    mapFlux.subscribe(new FilterSubscriber(Subscriber)) {
        arrayFlux.subscribe(new MapSubscriber(FilterSubscriber(Subscriber))) 
{
            // 在这里开始推送真正的元素
       }
   }
}
```



```java
ArraySubscriber(
 MapSubscriber(
   FilterSubscriber(
       Subscriber
       )
   )
)
```



订阅时的重要性在于：

1. 在该阶段中，可以执行与组装阶段相同的优化。
2. 其次在Reactor中启用多线程的一些操作符能更改订阅所发生的工作单元。



**运行时**

流执行的最后一步是运行是（runtime）阶段

在该阶段（Publisher）和（Subscriber）之前进行实际信号交换。

响应式流规范规定，Publisher和Subscriber交换的前两个信号是onSubscribe信号和request信号。



![image-20241209225123264](.\images\image-20241209225123264.png)



### 9.2 Reactor中线程调度模型

publisherOn操作符能将部分运行时操作的执行移动到指定的工作单元。

为了指定应该在运行时处理元素的工作单元，Reactor为此引入了一个特定的抽象，叫作Scheduler。Scheduler是一个接口，代表Project Reactor中的一个工作单元或工作单元池。

```java
Scheduler schedule = ...;
Flux.rang(1,100)
    .map(String::valueof)
    .filter(s -> s.length() > 1)
    .publishOn(scheduler)
    .map(this::calculateHash)
    .map(this::doBusinessLogic)
    .subscriber();
```

publishOn操作符之后的执行位于不同的Scheduler工作单元上。

执行模型：

![image-20241209225747171](.\images\image-20241209225747171.png)

publishOn操作符的重点是运行时执行，在底层，publishOn操作符会保留一个队列，并为该队列提供新元素，以便专用工作单元消费消息并逐个处理它们。

注意：响应式流中的甩胡元素都是逐个处理的（而不是同时处理的）因此可能始终为所有事件定义严格的顺序，此属性也被称为串行化。

**使用PublishOn操作符实现并行化**

![image-20241209230104341](.\images\image-20241209230104341.png)

如果在流程中放置一个PublishOn就可能加快处理速度：

![image-20241209230210024](.\images\image-20241209230210024.png)

**subscribeOn操作符**

Reactor中的多线程另一个要点是名为subscribeOn的操作符，与publishOn相比，subscribeOn使你能更改正在运行的订阅链的工作单元。

当从函数的执行过程中创建流的数据源时，此操作符很有用。

通常此类执行在订阅时进行，它会调用一个函数，该函数会提供执行.subscrbe方法的数据源。

左侧是订阅，右侧是消费

![image-20241209230547393](.\images\image-20241209230547393.png)

**并行操作符**

除了一些重要操作符（用于管理想要处理的执行流某些部分的线程），Reactor还提供了一种熟悉的并行技术。为此，Reactor有一个名为`parallel`的操作符，它能将流分割为并行子流并均衡它们之间的元素。

```java
    @Test
    public void parallel() throws InterruptedException {
        Random rand = new Random();
        CountDownLatch downLatch = new CountDownLatch(1);
        Flux.range(1, 32)
                .doOnNext((item) ->
                        System.out.println("parallel:" + Thread.currentThread().getName() + ",item --> " + item)
                )
                //轮询方式将元素交给保修处理器核心来处理，这里只是准备阶段，需要调度runOn真正调度执行。
                .parallel()
                //每个处理器一个执行单元，12c16t，线程名称：runOn:parallel-{1-16}
                .runOn(Schedulers.parallel())
                //执行转换操作
                .map(num -> num + rand.nextInt(10000))
                .doOnNext(item -> System.out.println("map:" + Thread.currentThread().getName()))
                //仅过滤也偶数信息
                .filter(num -> num % 2 == 0)
                .doOnNext((item) -> System.out.println("filter:" + Thread.currentThread().getName()))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "-" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            downLatch.countDown();
                        },
                        () -> {
                            System.out.println("finish线程:" + Thread.currentThread().getName());
                            downLatch.countDown();
                        }
                )
        ;


        System.out.println("等待开始:" + LocalDateTime.now());
        downLatch.await(5, TimeUnit.SECONDS);
        System.out.println("等待结束:" + LocalDateTime.now());
    }
```

输出：

```tex
parallel:main,item --> 1
parallel:main,item --> 2
parallel:main,item --> 3
parallel:main,item --> 4
parallel:main,item --> 5
parallel:main,item --> 6
parallel:main,item --> 7
parallel:main,item --> 8
parallel:main,item --> 9
parallel:main,item --> 10
parallel:main,item --> 11
parallel:main,item --> 12
parallel:main,item --> 13
parallel:main,item --> 14
parallel:main,item --> 15
parallel:main,item --> 16
parallel:main,item --> 17
parallel:main,item --> 18
parallel:main,item --> 19
parallel:main,item --> 20
parallel:main,item --> 21
parallel:main,item --> 22
parallel:main,item --> 23
map:parallel-16
map:parallel-14
map:parallel-6
map:parallel-3
filter:parallel-3
map:parallel-2
filter:parallel-2
map:parallel-10
map:parallel-7
parallel:main,item --> 24
map:parallel-9
parallel:main,item --> 25
filter:parallel-9
parallel-9-1328
map:parallel-9
filter:parallel-9
parallel-9-7224
map:parallel-11
map:parallel-13
map:parallel-15
filter:parallel-15
map:parallel-1
filter:parallel-1
parallel-15-1894
parallel:main,item --> 26
map:parallel-7
filter:parallel-7
parallel-2-2314
parallel-3-4848
map:parallel-2
map:parallel-12
filter:parallel-12
map:parallel-8
map:parallel-5
filter:parallel-6
map:parallel-4
parallel-6-6202
map:parallel-5
parallel:main,item --> 27
map:parallel-8
filter:parallel-8
parallel-12-3694
map:parallel-3
filter:parallel-3
parallel-3-1134
parallel-7-4446
parallel-1-1820
map:parallel-1
parallel:main,item --> 28
parallel-8-5714
map:parallel-6
map:parallel-4
parallel:main,item --> 29
parallel:main,item --> 30
parallel:main,item --> 31
parallel:main,item --> 32
map:parallel-12
map:parallel-15
map:parallel-16
map:parallel-13
map:parallel-11
finish线程:parallel-2
finish线程:parallel-3
finish线程:parallel-5
finish线程:parallel-9
finish线程:parallel-6
map:parallel-14
filter:parallel-14
finish线程:parallel-13
finish线程:parallel-7
finish线程:parallel-16
filter:parallel-15
filter:parallel-12
map:parallel-10
parallel-12-2016
parallel-15-6388
parallel-14-806
finish线程:parallel-8
finish线程:parallel-4
finish线程:parallel-11
finish线程:parallel-1
finish线程:parallel-14
finish线程:parallel-15
finish线程:parallel-10
finish线程:parallel-12
等待开始:2024-12-10T09:25:34.147238
等待结束:2024-12-10T09:25:34.148237400

```

`parallel`是FluxAPI的一部分，通过应用`parallel`操作符，开始在不同类型的Flux上执行操作，该Flux称为`ParallelFlux`。

`ParallelFlux`是一组Flux的抽象，其中源Flux中的元素是<font color="red">均衡</font>的，然后应用runOn操作符，可以将publishOn应用于内部Flux，并分配与元素（正在不同工作单元之彰进行处理）相关的工作。

**调度器**

调度器是一个接口，具有两个核心方法，即`Scheduler.schedlue`和`Scheduler.createWorker`.

`Scheduler.schedlue`可以调度Runable任务，

`Scheduler.createWorker`不仅为我们提供了Worker专用的实例，还可以以相同方式调度Runable任务。Scheduler接口和Worker接口之间的核心区别在于Scheduler接口表示工作单元池，而Worker是Thread或资源的专用抽象。

默认情况下，Reactor提供了3个核心调度程序接口实现：

1. `SingleSchedule`能为一个专用工作单元安排所有可能的任务。它具有时间性，因此可以延迟安排定期事件。此调度程序可以使用`Schedule.single()`调用进行引用。
2. `ParallelScheduler`适用于固定大小的工作单元池（默认情况下，其大小受CPU内核数限制），适合于CPU密集形任务。此外默认情况下，它也可以处理与时间相关的调度事件。此调度程序可以使用`Scheduler.parallel`调用进行引用。
3. `ElasticScheduler`可以动态创建工作单元并缓存线程池，由于其所创建的线程池没有最大数量限制，因此调度程序非常适用于I/O密集形调度，此调度程序可以使用`Schedule.elastic()`调用进行引用。

此外还可以实现具有所期望的特性的Scheduler。

**响应式上下文**

Reactor附带的另一个关键功能是Context。Context是沿数据流传递接口。

Context接口的核心思想是提供某些上下文信息的访问，因为这些信息可能在稍后运行阶段有用。

ThreadLocal在多线程环境中的问题

```java
    @Test
    public void threadLocal() throws InterruptedException {
        Random random = new Random();

        ThreadLocal<Map<Object, Object>> threadLocal = new ThreadLocal<>();
        threadLocal.set(new HashMap<>());
        Flux.range(0, 10)
                .doOnNext(item -> threadLocal.get().put(item, random.nextGaussian()))
                //多线程调度执行
                .publishOn(Schedulers.parallel())
                .map(key -> threadLocal.get().get(key))
                .blockLast();

        Thread.sleep(1000);
    }
```

输出：

```tex
java.lang.NullPointerException: Cannot invoke "java.util.Map.get(Object)" because the return value of "java.lang.ThreadLocal.get()" is null

	at com.nullnull.recator.TestFluxContext.lambda$threadLocal$1(TestFluxContext.java:27)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:113)
	at reactor.core.publisher.FluxPublishOn$PublishOnSubscriber.runAsync(FluxPublishOn.java:440)
	at reactor.core.publisher.FluxPublishOn$PublishOnSubscriber.run(FluxPublishOn.java:527)
	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)
	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99)
		at reactor.core.publisher.Flux.blockLast(Flux.java:2494)
		at com.nullnull.recator.TestFluxContext.threadLocal(TestFluxContext.java:28)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:568)
		at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
		at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
		at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
		at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
		at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
		at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
		at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
		at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
		at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
		at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
		at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
		at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
		at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
```

在多线程环境中使用ThreadLocal是非常危险的，并可能导致意外发生，尽管JavaAPI能将ThreadLocal从数据从一个线程传输到另外一个线程。但它并不保证传输的完全一致性。

Reactor的Context，解决了这个问题。

```java
    @Test
    public void context() {
        Random random = new Random();

        String key = "keys";

        Object lastValue = Flux.range(0, 10)
                .flatMap(k ->
                        Mono.subscriberContext()
                                .doOnNext(context -> {
                                    Map<Object, Object> map = context.get(key);

                                    map.put(k, random.nextGaussian());
                                }).thenReturn(k)
                )
                //并行化执行
                .publishOn(Schedulers.parallel())
                .flatMap(k ->
                        Mono.subscriberContext()
                                .map(context -> {
                                    Map<Object, Object> map = context.get(key);
                                    return map.get(k);
                                })
                )
                .subscriberContext(context -> context.put(key, new HashMap<>()))
                .blockLast();

        System.out.println("结果：" + lastValue);
    }
```

输出：

```tex
结果：-0.4618533277499057
```

翻看源码：

```java
	@Deprecated
	public static Mono<Context> subscriberContext() {
		return onAssembly(MonoCurrentContext.INSTANCE);
	}
```

查看MonoCurrentContext类

```java
final class MonoCurrentContext extends Mono<Context>
		implements Fuseable, Scannable {

	static final MonoCurrentContext INSTANCE = new MonoCurrentContext();

	@SuppressWarnings("unchecked")
	public void subscribe(CoreSubscriber<? super Context> actual) {
		Context ctx = actual.currentContext();
		actual.onSubscribe(Operators.scalarSubscription(actual, ctx));
	}

	@Override
	public Object scanUnsafe(Attr key) {
		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
		return null;
	}
}
```



既然Context接口具有与Map接口类型的方法，那为什么 需要使用Map来传输数据？

答案是：Context是不可变对象，一旦向它添加元素，它就实现了Context的新实例，这样的设计有利于多线程访问模型。

这意味着，这是向流中提供Context并动态提供某些数据的唯一方法。这些数据在组装或者订阅时的整个运行期间可用。如果在组装时提供了Context，那么所有订阅者将共享相同的静态上下文，但这在每个Subscriber具有其自身的Context的情况下可能没有用。因此可以向每个Subscriber提供其自身上下文的唯一生命周期时段的订阅时阶段。

```java
    @Test
    public void contextRun() {
        printCurrentContext("top")
                .subscriberContext(Context.of("top", "Context"))
                .flatMap(data -> printCurrentContext("middle"))
                .subscriberContext(Context.of("middle", "context"))
                .flatMap(data -> printCurrentContext("bottom"))
                .subscriberContext(Context.of("bottom", "context"))
                .flatMap(data -> printCurrentContext("initial"))
                .block();
    }

    private void print(String id, Context context) {
        System.out.println(id + "{");
        System.out.println(context);
        System.out.println("}");
    }


    Mono<Context> printCurrentContext(String id) {
        return Mono.subscriberContext()
                .doOnNext(context -> print(id, context));
    }
```

输出：

```tex
top{
Context3{bottom=context, middle=context, top=Context}
}
middle{
Context2{bottom=context, middle=context}
}
bottom{
Context1{bottom=context}
}
initial{
Context0{}
}
```



### 9.3 Project Reactor内幕

Project Reactor3最显著的改进就是：

响应流生命周期(Reactive Stream life-cycle)和操作符融合(operator fusion)。

**宏融合**

宏融合主要发生在组装时，其目的用一个操作符替换掉另一个操作符。



**微融合**

微融合(micro-fusion)是一种更复杂的优化，与运行时优化以及我不用共享资源有关，微融合的一个很好的例子是条件操作符：

![image-20241210123458991](.\images\image-20241210123458991.png)

商店订购了 n 件商品。过了一段时间，工厂用卡车将物品送到商店。 但是，为了最终到达商店，卡车必须通过检验部门，以确保所有商品质量合格。由于有些物品没有 仔细包装，因而只有部分订单到达了商店。在那之后，工厂准备了另一辆卡车，再次往商店送货。这种 情况反复发生，直到所有订购的商品到达商店。幸好，工厂意识到他们在使商品通过单独的检验部门上 花了太多的时间和金钱，并决定从检验部门雇用检验员到本地。

![image-20241210123539425](.\images\image-20241210123539425.png)

所有物品现在都可以在工厂进行检验后送到商店，而无须前往检验部门。

根据当前响应式库（例如RxJava 或 Reactor 3）的设计，request 操作有自己的额外 CPU 开销。  

根据 David Karnok 的研究，每个“对 request()的调用通常最终都在一个原子 CAS 循环中，而 每 21~45 个循环会掉落一个元素”。 

 这意味着条件操作符（如 filter 操作符）可能对整体性能产生重大影响！出于这个原因，出现了一 种被称为 ConditionalSubscriber 的微融合类型。 这种类型的优化使我们能在数据源端验证条件，并发送所需数量的元素而无须额外的 request 调 用。 



为了避免内存开销和性能开销，应该遵循响应式流规范的建议，切换通信协议。 

假设一个或多个边界内的元素链具有共享队列，那么可以切换整个操作符链以使用上游操作符作为 无须额外 request 调用的队列，这样可以显著提高整体性能。 

因此，下游可以从上游排出值，如果该值不可用于指示流的结束，则返回 null。



以下示例代码：

```java
Flux.just(1, 2, 3)
   .publishOn(Schedulers.parallel())
   .concatMap(i -> Flux.range(0, i).publishOn(Schedulers.parallel()))
   .subscribe();
```

![image-20241210123809645](.\images\image-20241210123809645.png)

优化后：

![image-20241210123907150](.\images\image-20241210123907150.png)

publishOn 和 concatMap 操作符可以被显著优化。在第一种情况下，因为没有必须 在主线程中执行的中间操作符，所以我们可以直接使用 just 操作符作为队列，并在单独的线程上从该队 列中执行 pull 操作。在 concatMap 的情况下，所有内部流也可以被视为队列，以在没有附加任何  request 调用的情况下排出每个流。 

 总之，Reactor 库的内部结构比看起来更复杂。通过强大的优化，Reactor 远远领先于 RxJava 1.x， 从而提供了更好的性能。





第三部分 Spring WebFlux高级实战

## 10 WebFlux作为响应式服务器基础

Spring 框架的整个基础设施都是围绕Servlet API 构建的，它们之间紧密耦合。

Spring框架所做的事情

![image-20241210124119353](.\images\image-20241210124119353.png)

Spring MVC的缺点： 

1. 不允许在整个请求声明周期中出现非阻塞操作。没有开箱即用的非阻塞HTTP客户端。 
2. WebMVC 抽象不能支持非阻塞 Servlet 3.1 的所有功能。 
3. 对于非 Servlet 服务器，重用 Spring Web 功能或变成模块不灵活。



### 10.1 响应式Web内核

响应式Web内核首先需要使用模拟接口和对请求进行处理的方法替换 javax.servlet.Servlet.service 方法。 

更改相关的类和接口 

增强和定制 Servlet API 对客户端请求和服务器响应的交互方式。

```java
/** 
  * 请求的封装。
  * 获取请求报文体的类型是Flux，表示具备响应式能力。
  * DataBuffer是针对字节缓冲区的抽象，便于对特定服务器实现数据交换。
  * 除了请求报文体，还有消息头、请求路径、cookie、查询参数等信息，可以在该接口或子接口中提
供。
  */
interface ServerHttpRequest {
    // ...
    Flux<DataBuffer> getBody();
    // ...
}
/**
   * 响应的封装。
   * writeWith方法接收的参数是Publisher，提供了响应式，并与特定响应式库解耦。
   * 返回值是Mono<Void>，表示向网络发送数据是一个异步的过程。
   * 即，只有当订阅Mono时才会执行发送数据的过程。
   * 接收服务器可以根据传输协议的流控支持背压。
   */
interface ServerHttpResponse {
    // ...
    Mono<Void> writeWith(Publisher<? extends DataBuffer> body);
    // ...
}
/**
  * HTTP请求-响应的容器。
  * 这是高层接口，除了HTTP交互，还可以保存框架相关信息。
  * 如请求的已恢复的WebSession信息等。
  *
  *
  */
interface ServerWebExchange {
    // ...
    ServerHttpRequest getRequest();
    ServerHttpResponse getResponse();
     // ...
    Mono<WebSession> getSession();
    // ...
}
```

上述三个接口类似于Servlet API 中的接口。 响应式接口旨在从交互模型的角度提供几乎相同的方法，同时提供开箱即用的响应式。

请求的处理程序和过滤器 API：

```java
/**
  * 对应于WebMVC中的DispatcherServlet
  *   查找请求的处理程序，使用视图解析器渲染视图，因此handle方法不需要返回任何结果。
  * 
  * 返回值Mono<Void>提供了异步处理。
  * 如果在指定的时间内没有信号出现，可以取消执行。
  */
interface WebHandler {
    Mono<Void> handle(ServerWebExchange exchange);
}
/**
  * 过滤器链
  */
interface WebFilterChain {
    Mono<Void> filter(ServerWebExchange exchange);
}
/**
  * 过滤器
  */
interface WebFilter {
    Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain);
}


/**
 * 需要为这些接口适配不同的服务器。
 * 即与ServerHttpRequest和ServerHttpResponse进行直接交互的组件。
 * 同时负责ServerWebExchange的构建，特定的会话存储、本地化解析器等信息的保存。
 *
 */
public interface HttpHandler {
    Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse 
response);
}
```

通过该适当的抽象，隐藏了服务器引擎的细节，具体服务器的工作方式对 Spring WebFlux 用户不 重要。



### 10.2 响应式WEB和MVC框架

Spring Web MVC 模块的关键特性 基于注解。因此，需要为响应式Web 栈提供相同的概念。

重用 WebMVC 的基础设施，用 Flux 、 Mono 和 Publisher 等响应式类型替换同步通信。  

保留与 Spring Web MVC 相同的 HandlerMapping 和 HandlerAdapter 链，使用基于 Reactor 的 响应式交互替换实时命令：

```java
interface HandlerMapping {
    /*
    HandlerExecutionChain getHandler(HttpServletRequest request)
    */
    Mono<Object> getHandler(ServerWebExchange exchange);
}
interface HandlerAdapter {
    
    boolean supports(Object handler);
    /*
    ModelAndView handle(HttpServletRequest request, HttpServletResponse 
response, Object handler);
    */
    Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);
}
```

响应式 HandlerMapping 中，两个方法整体上类似， 不同之处在于响应式返回Mono 类型支持响应式。 

 响应式HandlerAdapter 接口中，由于 ServerWebExchange 类同时组合了请求和响应，因此  handle 方法的响应式版本更简洁。 

该方法返回 HandlerResult 的 Mono 而不是 ModelAndView 。

得到最终的结构：

![image-20241210124709705](.\images\image-20241210124709705.png)



1. 传入请求，由底层服务器引擎处理。服务器引擎列表不限于基于ServletAPI 的服务器。每个服 务器引擎都有自己的响应式适配器，将 HTTP 请求和 HTTP 响应的内部表示映射到  ServerHttpRequest 和 ServerHttpResponse 。
2. HttpHandler 阶段，该阶段将给定的 ServerHttpRequest 、 ServerHttpResponse 、用户  Session 和相关信息组合到 ServerWebExchage 实例中。
3. WebFilterChain 阶段，它将定义的 WebFilter 组合到链中。然后， WebFilterChain 会 负责执行此链中每个 WebFilter 实例的 WebFilter#filter 方法，以过滤传入的 ServerWebExchange 。
4. 如果满足所有过滤条件， WebFilterChain 将调用 WebHandler 实例。 
5. 查找 HandlerMapping 实例并调用第一个合适的实例。可以是RouterFunctionMapping、也 可以是RequestMappingHandlerMapping 和HandlerMapping 资源。 RouterFunctionMapping，引入到WebFlux 之中，超越了纯粹的功能请求处理。
6. RequestMappingHandlerAdapter 阶段，与以前功能相同，使用响应式流来构建响应式流。

在WebFlux 模块中，默认服务器引擎是Netty。

Netty 服务器很适合作为默认服务器，因为它广泛用于响应式领域。

该服务器引擎还同时提供客户端和服务器异步非阻塞交互。 同时，可以灵活地选择服务器引擎。







### 10.3 基于WebFlux的纯函数式WEB

纯函数式web主要是函数式路由映射，通过函数式映射，可以生成轻量级应用。

函数式WEB框架允许在不启动整个Spring基础设施的情况下构建WEB应用程序。

首先还是导入maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-10-3-web</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-3-web</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

```



创建一个javaBean

```java
package com.nullnull.demo.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * @author nullnull
 * @since 2024/12/10
 */
public class PasswordDTO {

    private String raw;

    private String secured;

    @JsonCreator
    public PasswordDTO(
            @JsonProperty("raw")
            String raw,
            @JsonProperty("secured")
            String secured) {
        this.raw = raw;
        this.secured = secured;
    }

    public String getRaw() {
        return raw;
    }

    public String getSecured() {
        return secured;
    }

    public void setRaw(String raw) {
        this.raw = raw;
    }

    public void setSecured(String secured) {
        this.secured = secured;
    }
}

```

主服务

```java
package com.nullnull.demo;

import com.nullnull.demo.dto.PasswordDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.HttpHandler;
import org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.netty.DisposableServer;
import reactor.netty.http.server.HttpServer;

/**
 * @author nullnull
 * @since 2024/12/10
 */
public class StandaloneApplication {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(StandaloneApplication.class);

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        //调用routes方法，然后将routerFunction转换为HttpHandler.
        HttpHandler httpHandler = RouterFunctions.toHttpHandler(
                //BCtypt算法进行18轮散列，这可能需要几秒种来进行编码/匹配。
                routes(
                        new BCryptPasswordEncoder(18)
                ));
        //内置HttpHandler适配器
        ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = new ReactorHttpHandlerAdapter(httpHandler);
        //创建HttpServer实例，它是ReactorNettyAPI的一部分
        DisposableServer server = HttpServer.create()
                .host("127.0.0.1")
                .port(8080)
                .handle(reactorHttpHandlerAdapter)
                .bindNow();

        LOGGER.debug("Started is " + (System.currentTimeMillis() - start) + "ms");
        server.onDispose().block();


    }


    private static RouterFunction<ServerResponse> routes(PasswordEncoder passwordEncoder) {
        return RouterFunctions.route(RequestPredicates.POST("/password"),
                serverRequest ->
                        serverRequest
                                .bodyToMono(PasswordDTO.class)
                                //使用passwordEncoder检查已加密密码的原始密码
                                .map(p -> passwordEncoder.matches(p.getRaw(), p.getSecured()))
                                //如果密码与存储的密码匹配，则serverResponse状态将返回ok状态
                                //否则返回EXPECTATION_FAILED(417)
                                .flatMap(isMatched -> isMatched
                                        ? ServerResponse.ok().build()
                                        : ServerResponse.status(HttpStatus.EXPECTATION_FAILED).build()
                                )
        );
    }

}
```

启动服务:

```java
23:15:40.725 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework
23:15:41.029 [main] DEBUG org.springframework.web.server.adapter.HttpWebHandlerAdapter - enableLoggingRequestDetails='false': form data and headers will be masked to prevent unsafe logging of potentially sensitive data
23:15:41.055 [main] DEBUG io.netty.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework
23:15:41.056 [main] DEBUG io.netty.util.internal.PlatformDependent - Platform: Windows
23:15:41.059 [main] DEBUG io.netty.util.internal.PlatformDependent0 - -Dio.netty.noUnsafe: false
23:15:41.059 [main] DEBUG io.netty.util.internal.PlatformDependent0 - Java version: 8
23:15:41.060 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.theUnsafe: available
23:15:41.060 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.copyMemory: available
23:15:41.063 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Buffer.address: available
23:15:41.063 [main] DEBUG io.netty.util.internal.PlatformDependent0 - direct buffer constructor: available
23:15:41.064 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true
23:15:41.064 [main] DEBUG io.netty.util.internal.PlatformDependent0 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9
23:15:41.064 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.DirectByteBuffer.<init>(long, int): available
23:15:41.064 [main] DEBUG io.netty.util.internal.PlatformDependent - sun.misc.Unsafe: available
23:15:41.065 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.tmpdir: C:\Users\liujun\AppData\Local\Temp (java.io.tmpdir)
23:15:41.065 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.bitMode: 64 (sun.arch.data.model)
23:15:41.066 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.maxDirectMemory: 28631367680 bytes
23:15:41.066 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.uninitializedArrayAllocationThreshold: -1
23:15:41.066 [main] DEBUG io.netty.util.internal.CleanerJava6 - java.nio.ByteBuffer.cleaner(): available
23:15:41.067 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.noPreferDirect: false
23:15:41.096 [main] DEBUG io.netty.util.ResourceLeakDetector - -Dio.netty.leakDetection.level: simple
23:15:41.096 [main] DEBUG io.netty.util.ResourceLeakDetector - -Dio.netty.leakDetection.targetRecords: 4
23:15:41.116 [main] DEBUG io.netty.util.NetUtil - -Djava.net.preferIPv4Stack: false
23:15:41.116 [main] DEBUG io.netty.util.NetUtil - -Djava.net.preferIPv6Addresses: false
23:15:41.835 [main] DEBUG io.netty.util.NetUtilInitializations - Loopback interface: lo (Software Loopback Interface 1, 127.0.0.1)
23:15:41.836 [main] DEBUG io.netty.util.NetUtil - Failed to get SOMAXCONN from sysctl and file \proc\sys\net\core\somaxconn. Default: 200
23:15:41.845 [main] DEBUG reactor.netty.tcp.TcpResources - [http] resources will use the default LoopResources: DefaultLoopResources {prefix=reactor-http, daemon=true, selectCount=32, workerCount=32}
23:15:41.845 [main] DEBUG reactor.netty.tcp.TcpResources - [http] resources will use the default ConnectionProvider: reactor.netty.resources.DefaultPooledConnectionProvider@740773a3
23:15:41.847 [main] DEBUG reactor.netty.resources.DefaultLoopKQueue - Default KQueue support : false
23:15:42.694 [main] DEBUG reactor.netty.resources.DefaultLoopEpoll - Default Epoll support : false
23:15:42.700 [main] DEBUG io.netty.channel.MultithreadEventLoopGroup - -Dio.netty.eventLoopThreads: 64
23:15:42.721 [main] DEBUG io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024
23:15:42.721 [main] DEBUG io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096
23:15:42.727 [main] DEBUG io.netty.channel.nio.NioEventLoop - -Dio.netty.noKeySetOptimization: false
23:15:42.727 [main] DEBUG io.netty.channel.nio.NioEventLoop - -Dio.netty.selectorAutoRebuildThreshold: 512
23:15:42.736 [main] DEBUG io.netty.util.internal.PlatformDependent - org.jctools-core.MpscChunkedArrayQueue: available
23:15:42.794 [main] DEBUG io.netty.channel.DefaultChannelId - -Dio.netty.processId: 15908 (auto-detected)
23:15:43.607 [main] DEBUG io.netty.channel.DefaultChannelId - -Dio.netty.machineId: 6c:0b:84:ff:fe:67:68:79 (auto-detected)
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numHeapArenas: 64
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numDirectArenas: 64
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.pageSize: 8192
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxOrder: 11
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.chunkSize: 16777216
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.smallCacheSize: 256
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.normalCacheSize: 64
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxCachedBufferCapacity: 32768
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.cacheTrimInterval: 8192
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.cacheTrimIntervalMillis: 0
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.useCacheForAllThreads: true
23:15:43.634 [main] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxCachedByteBuffersPerChunk: 1023
23:15:43.652 [main] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.allocator.type: pooled
23:15:43.652 [main] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.threadLocalDirectBufferSize: 0
23:15:43.652 [main] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.maxThreadLocalCharBufferSize: 16384
23:15:43.792 [reactor-http-nio-1] DEBUG reactor.netty.transport.ServerTransport - [id: 0x19759892, L:/127.0.0.1:8080] Bound new server
23:15:43.792 [main] DEBUG com.nullnull.demo.StandaloneApplication - Started is 3281ms

```

可以看出时间大约为3秒2



再加载整个SpringBoot容器的版本

服务类

```java
package com.nullnull.demo.service;

import com.nullnull.demo.dto.PasswordDTO;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.HandlerFunction;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

/**
 * @author nullnull
 * @since 2024/12/10
 */
@Component
public class PasswordHandlerFunction implements HandlerFunction {

    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(18);

    @Override
    public Mono<Void> handle(ServerRequest serverRequest) {
        return serverRequest
                .bodyToMono(PasswordDTO.class)
                .map(p -> passwordEncoder.matches(p.getRaw(), p.getSecured()))
                .flatMap(isMatched -> isMatched
                        ? ServerResponse.ok().build()
                        : ServerResponse.status(HttpStatus.EXPECTATION_FAILED).build()
                ).then(Mono.empty());
    }
}

```

主启动类:

```java
package com.nullnull.demo;

import com.nullnull.demo.service.PasswordHandlerFunction;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.security.web.server.SecurityWebFilterChain;;

/**
 * @author nullnull
 * @since 2024/12/10
 */
@SpringBootApplication
public class WebFluxSprintBootApplication {
    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

    @Bean
    public static RouterFunction<ServerResponse> routes(PasswordHandlerFunction handlerFunction) {
        return RouterFunctions.route(RequestPredicates.POST("/password"), handlerFunction);
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity serverHttpSecurity) {
        return serverHttpSecurity.csrf().disable().build();
    }
}
```

启动输出：

```tex
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.4.0)

2024-12-10 23:19:20.789  INFO 13836 --- [           main] c.m.datack.WebFluxSprintBootApplication  : Starting WebFluxSprintBootApplication using Java 1.8.0_301 on jun-station with PID 13836 (D:\java\myself\learn\learn-md\webflex\webflux\webflux-10-3-web\target\classes started by liujun in D:\java\myself\learn\learn-md\webflex\webflux)
2024-12-10 23:19:20.792  INFO 13836 --- [           main] c.m.datack.WebFluxSprintBootApplication  : No active profile set, falling back to default profiles: default
2024-12-10 23:19:22.530  INFO 13836 --- [           main] ctiveUserDetailsServiceAutoConfiguration : 

Using generated security password: aaef5bda-2fab-42a6-bb1c-8a6f242e6d65

2024-12-10 23:19:24.458  INFO 13836 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
2024-12-10 23:19:24.467  INFO 13836 --- [           main] c.m.datack.WebFluxSprintBootApplication  : Started WebFluxSprintBootApplication in 4.046 seconds (JVM running for 4.549)

```

启动完整容器的时间大约为4秒。

通过切换到函数式路由声明，

1. 可以在一个位置维护所有路由配置，并使用响应式方法对传入请求进行处理。
2. 在访问传入的请求参数、路径变量和请求的其他重要组件方面，函数式路由的灵活性与基于注 解的常规方法几乎相同。 
3. 函数式路由不但能避免运行整个Spring 框架基础设施，并且在路由设置方面同样灵活，让应用 程序的启动更快。





### 10.4 基于WebClient的非阻塞跨服务通信

从本质上来讲，WebClient 是旧 RestTemplate 的响应式替代品。

WebClient 中有一个函数式API，并提供内置的到 Project Reactor 类型（如 Flux 或 Mono ）的映 射。

WebClient 遵循响应式流规范中描述的行为。 只有通过 subscribe 方法， WebClient 才会建立连接并开始发送数据到远程服务器。

构建一个对密码检查服务的调用，并使用WebClient API以自定义方式处理响应状态：

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-10-3-web</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-3-web</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.0</version>
            </plugin>
        </plugins>
    </build>
</project>

```

主启动类

```java
package com.nullnull.demo;

import com.nullnull.demo.service.PasswordHandlerFunction;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.security.web.server.SecurityWebFilterChain;;

@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

    @Bean
    public static RouterFunction<ServerResponse> routes(PasswordHandlerFunction handlerFunction) {
        return RouterFunctions.route(RequestPredicates.POST("/password"), handlerFunction);
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity serverHttpSecurity) {
        return serverHttpSecurity.csrf().disable().build();
    }

}
```

处理类

```java
package com.nullnull.demo.service;

import com.nullnull.demo.dto.PasswordDTO;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.HandlerFunction;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;


@Component
public class PasswordHandlerFunction implements HandlerFunction {

    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(5);

    @Override
    public Mono<Void> handle(ServerRequest serverRequest) {
        return serverRequest
                .bodyToMono(PasswordDTO.class)
                .map(p -> {
                            System.out.println("收到数据：" + p.getRaw() + "," + p.getSecured());
                            boolean matchRsp = passwordEncoder.matches(p.getRaw(), p.getSecured());
                            System.out.println("收到数据：" + p.getRaw() + "," + p.getSecured() + ",rsp:" + matchRsp);
                            return matchRsp;
                        }
                )
                .log()
                .flatMap(isMatched ->
                        {
                            System.out.println("结果：" + isMatched);
                            Mono<ServerResponse> rsp = isMatched
                                    ? ServerResponse.ok().build()
                                    : ServerResponse.status(HttpStatus.EXPECTATION_FAILED).build();
                            rsp.doOnNext(item -> System.out.println("rsp11" + item.statusCode().name()));
                            return rsp;
                        }
                )
                .then(Mono.empty());
    }
}
```

实体信息

```java
package com.nullnull.demo.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class PasswordDTO {

    private String raw;

    private String secured;

    @JsonCreator
    public PasswordDTO(
            @JsonProperty("raw")
            String raw,
            @JsonProperty("secured")
            String secured) {
        this.raw = raw;
        this.secured = secured;
    }

    public String getRaw() {
        return raw;
    }

    public String getSecured() {
        return secured;
    }

    public void setRaw(String raw) {
        this.raw = raw;
    }

    public void setSecured(String secured) {
        this.secured = secured;
    }
}
```

启动服务端

```java
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.4.0)

2024-12-11 18:43:25.028  INFO 33096 --- [           main] c.m.datack.WebFluxSprintBootApplication  : Starting WebFluxSprintBootApplication using Java 1.8.0_291 on DESKTOP-FAALJC1 with PID 33096 (D:\work\nullnull\learn\learn-md\webflex\webflux\webflux-10-3-web\target\classes started by nullnull in D:\work\nullnull\learn\learn-md\webflex\webflux)
2024-12-11 18:43:25.030  INFO 33096 --- [           main] c.m.datack.WebFluxSprintBootApplication  : No active profile set, falling back to default profiles: default
2024-12-11 18:43:26.373  INFO 33096 --- [           main] ctiveUserDetailsServiceAutoConfiguration : 

Using generated security password: 591cc2aa-1e73-48d6-af0c-87f1182a099a

2024-12-11 18:43:27.697  INFO 33096 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
2024-12-11 18:43:27.704  INFO 33096 --- [           main] c.m.datack.WebFluxSprintBootApplication  : Started WebFluxSprintBootApplication in 2.924 seconds (JVM running for 3.249)

```



编写客户端

服务接口

```java
package com.nullnull.demo.client;

import reactor.core.publisher.Mono;

public interface PasswordVerificationService {

    /**
     * 检查密码接口
     *
     * @param raw
     * @param encoded
     * @return
     */
    Mono<Void> check(String raw, String encoded);
}

```

服务实现

```java
package com.nullnull.demo.client;

import com.nullnull.demo.dto.PasswordDTO;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public class DefaultPasswordVerificationService implements PasswordVerificationService {


    /**
     * client操作
     */
    private final WebClient webClient;


    public DefaultPasswordVerificationService(WebClient.Builder weBuilder) {
        this.webClient = weBuilder
                .baseUrl("http://localhost:8080")
                .build();
    }

    @Override
    public Mono<Void> check(String raw, String encoded) {
        return webClient
                //使用post请求
                .post()
                .uri("/password")
                .body(BodyInserters.fromPublisher(
                        Mono.just(new PasswordDTO(raw, encoded)),
                        PasswordDTO.class
                ))
                .retrieve()
                .toEntityFlux(ResponseEntity.class)
                .flatMap(response -> {
                    System.out.println("接收到的数据:" + response.getStatusCodeValue());
                    if (response.getStatusCode().is2xxSuccessful()) {
                        return Mono.empty();
                    } else if (response.getStatusCode() == HttpStatus.EXPECTATION_FAILED) {
                        return Mono.error(new BadCredentialsException("EXPECTATION_FAILED"));
                    }
                    return Mono.error(new IllegalArgumentException("default error"));
                });

    }
}

```

服务的验证:

```java
package com.nullnull.demo.client;

import org.junit.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.test.StepVerifier;

import java.time.Duration;


public class TestStandaloneService {

    @Test
    public void checkApplicationRunning() {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(5);
        DefaultPasswordVerificationService server = new DefaultPasswordVerificationService(WebClient.builder());
        StepVerifier.create(server.check("test", encoder.encode("test")))
                .expectSubscription()
                .expectComplete()
                .verify(Duration.ofSeconds(20));
    }

}

```

启动单元测试运行checkApplicationRunning方法

检查服务的运行

```tex
18:46:16.325 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework
18:46:16.343 [main] DEBUG io.netty.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework
18:46:16.343 [main] DEBUG io.netty.util.internal.PlatformDependent - Platform: Windows
18:46:16.345 [main] DEBUG io.netty.util.internal.PlatformDependent0 - -Dio.netty.noUnsafe: false
18:46:16.345 [main] DEBUG io.netty.util.internal.PlatformDependent0 - Java version: 8
18:46:16.346 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.theUnsafe: available
18:46:16.347 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.copyMemory: available
18:46:16.347 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Buffer.address: available
18:46:16.347 [main] DEBUG io.netty.util.internal.PlatformDependent0 - direct buffer constructor: available
18:46:16.348 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true
......
18:46:18.953 [reactor-http-nio-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.maxCapacityPerThread: 4096
18:46:18.953 [reactor-http-nio-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.maxSharedCapacityFactor: 2
18:46:18.953 [reactor-http-nio-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.linkCapacity: 16
18:46:18.953 [reactor-http-nio-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.ratio: 8
18:46:18.953 [reactor-http-nio-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.delayedQueue.ratio: 8
18:46:18.972 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] onStateChange(POST{uri=/password, connection=PooledConnection{channel=[id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080]}}, [request_sent])
18:46:18.979 [reactor-http-nio-2] DEBUG reactor.netty.http.client.HttpClientOperations - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] Received response (auto-read:false) : [Cache-Control=no-cache, no-store, max-age=0, must-revalidate, Pragma=no-cache, Expires=0, X-Content-Type-Options=nosniff, X-Frame-Options=DENY, X-XSS-Protection=1 ; mode=block, Referrer-Policy=no-referrer, content-length=0]
18:46:18.980 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] onStateChange(POST{uri=/password, connection=PooledConnection{channel=[id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080]}}, [response_received])
18:46:18.982 [reactor-http-nio-2] DEBUG org.springframework.web.reactive.function.client.ExchangeFunctions - [a4add54] Response 200 OK
接收到的数据:200
18:46:18.992 [reactor-http-nio-2] DEBUG reactor.netty.http.client.HttpClientOperations - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] Received last HTTP packet
18:46:18.992 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] onStateChange(POST{uri=/password, connection=PooledConnection{channel=[id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080]}}, [response_completed])
18:46:18.992 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] onStateChange(POST{uri=/password, connection=PooledConnection{channel=[id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080]}}, [disconnecting])
18:46:18.992 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] Releasing channel
18:46:18.994 [reactor-http-nio-2] DEBUG reactor.netty.resources.DefaultPooledConnectionProvider - [id: 0xef321870, L:/127.0.0.1:8541 - R:localhost/127.0.0.1:8080] Channel cleaned, now 0 active connections and 1 inactive connections
```

再次查看服务端输出：

```tex
2024-12-11 18:47:50.109  INFO 33096 --- [oundedElastic-2] reactor.Mono.Map.4                       : onSubscribe(FluxMap.MapSubscriber)
2024-12-11 18:47:50.109  INFO 33096 --- [oundedElastic-2] reactor.Mono.Map.4                       : request(unbounded)
收到数据：test,$2a$05$roIbJHFzvgmATrzaJNHp.O6p0ev6CJiqIaTgSfDtfLrQUA0P6PR9y
收到数据：test,$2a$05$roIbJHFzvgmATrzaJNHp.O6p0ev6CJiqIaTgSfDtfLrQUA0P6PR9y,rsp:true
2024-12-11 18:47:50.112  INFO 33096 --- [ctor-http-nio-5] reactor.Mono.Map.4                       : onNext(true)
结果：true
2024-12-11 18:47:50.113  INFO 33096 --- [ctor-http-nio-5] reactor.Mono.Map.4                       : onComplete()
```



### 10.5 响应式模板引擎

Spring 5.x 和 WebFlux 模块已经放弃支持包括Apache Velocity 在内的许多技术。

Spring WebFlux 与 Web MVC 拥有相同的视图渲染技术。

以渲染一个用户列表为例

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-10-5-list</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-5-list</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-freemarker</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.0</version>
            </plugin>
        </plugins>
    </build>
</project>

```



controller

```java
package com.nullnull.demo.controller;

import com.nullnull.demo.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;


@Controller
public class UserController {

    @RequestMapping("/user-list-view-ftl")
    public Mono<String> getUserList(final Model model) {
        List<User> dataList = new ArrayList<>(5);
        for (int i = 0; i < 5; i++) {
            User user = new User();
            user.setName("name:" + i);
            user.setAge(i);
            user.setAddress("地址：" + i);
            dataList.add(user);
        }

        final Flux<User> userListStream = Flux.fromIterable(dataList);
        return userListStream.collectList()
                .doOnNext(list -> model.addAttribute("userList", list))
                .then(Mono.just("/freemarker/user-list-view"));
    }

}
```

实体信息

```java
package com.nullnull.demo.entity;

/**
 * 用户信息
 *
 * @author nullnull
 * @since 2024/12/11
 */
public class User {
    private String name;
    private Integer age;
    private String address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("User{");
        sb.append("name='").append(name).append('\'');
        sb.append(", age=").append(age);
        sb.append(", address='").append(address).append('\'');
        sb.append('}');
        return sb.toString();
    }
}

```

模板文件配制

src/main/resources/templates/freemarker/user-list-view.ftl

```tex
<!DOCTYPE html>
<html>
<body>
<head>
  <meta charset="UTF-8"/>
  <title>用户列表-freemarker</title>
</head>
<table border="1">
  <thead>
  </thead>
  <tbody>
  <#list userList as e>
  <tr>
    <td>${e.name}</td>
    <td>${e.age}</td>
    <td>${e.address}</td>
  </tr>
  </#list>
  </tbody>
</table>
</body>
</html>
```

系统配制

```java
package com.nullnull.demo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.config.EnableWebFlux;
import org.springframework.web.reactive.config.ViewResolverRegistry;
import org.springframework.web.reactive.config.WebFluxConfigurer;
import org.springframework.web.reactive.result.view.freemarker.FreeMarkerConfigurer;

@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // 使用".ftl"后缀注册一个FreeMarkerViewResolver
        registry.freeMarker();
    }

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        final FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}
```

系统启动类

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }
}

```

打开浏览器进行访问

http://127.0.0.1:8080/user-list-view-ftl

使用看到数据

![image-20241211192111854](.\images\image-20241211192111854.png)



FreeMarker 不支持数据的响应式呈现和非阻塞呈现，必须将所有信息收集到列表中并将收集的数据全部放入Model 中。

此freemarker只能将数据完整渲染后，再返回。现在采用另外一种模板引擎进行渲染动态数据：Thymeleaf

Thymeleaf 支持响应式WebFlux，并为异步和流模板渲染提供更多可能性。 

Thymeleaf 提供与FreeMarker 类似的功能，并允许编写相同的代码来呈现UI。 

Thymeleaf 能够将响应式类型用作模板内的数据源，并在流中的新元素可用时呈现模板的一部分。

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.maxwell.datack</groupId>
    <artifactId>webflux-10-5-thymeleaf2</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-5-thymeleaf2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.0</version>
            </plugin>
        </plugins>
    </build>
</project>

```

controller

```java
package com.nullnull.demo.controller;

import com.nullnull.demo.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.thymeleaf.spring5.context.webflux.ReactiveDataDriverContextVariable;
import reactor.core.publisher.Flux;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * 用户操作
 *
 * @author nullnull
 * @since 2024/12/11
 */
@Controller
public class UserController {

    @RequestMapping("/user-list-view-ftl")
    public String getUserList(final Model model) {
        List<User> dataList = new ArrayList<>(5);
        for (int i = 0; i < 5; i++) {
            User user = new User();
            user.setName("name:" + i);
            user.setAge(i);
            user.setAddress("地址：" + i);
            dataList.add(user);
        }

        final Flux<User> userListStream = Flux.fromIterable(dataList).delayElements(Duration.ofMillis(1000));
        model.addAttribute("userList",
                new ReactiveDataDriverContextVariable(userListStream, 1, 1)
        );
        return "thymeleaf/user-list-view";
    }
}
```

实体信息

```java
package com.nullnull.demo.entity;

public class User {

    /**
     * 用户名
     */
    private String name;


    /**
     * 年龄
     */
    private Integer age;

    /**
     * 地址
     */
    private String address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("User{");
        sb.append("name='").append(name).append('\'');
        sb.append(", age=").append(age);
        sb.append(", address='").append(address).append('\'');
        sb.append('}');
        return sb.toString();
    }
}
```

模板文件

src/main/resources/templates/thymeleaf/user-list-view.html

```html
<!DOCTYPE html>
<html>
<body>
<head>
    <meta charset="UTF-8"/>
    <title>用户列表-freemarker</title>
</head>
<table border="1">
     <thead>
    </thead>
     <tbody>
       <tr th:each="e : ${userList}">
       <td th:text="${e.name}">...</td>
       <td th:text="${e.age}">...</td>
       <td th:text="${e.address}">...</td>
     </tr>
 </tbody>
</table>
</body>
</html>
```





启动入口

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }
}

```

启动服务,浏览器中输入

http://127.0.0.1:8080/user-list-view-ftl

便可看到以每秒一个速度输出用户列表信息了

Thymeleaf 的渲染引擎开始将数据流传输到客户端，而不必等待最后一个元素被发射。 

它支持渲染无限的元素流。这可以通过添加对 Transfer-Encoding:chunked 的支持来实现。

 Thymeleaf 不会渲染内存中的整个模板，而会首先渲染可用的部分，然后在新元素可用时以块的形 式异步发送模板的其余部分。



### 10.6 响应式WEB安全

Spring Web的SpringSecurity 模块通过在任何控制器和Web 处理程序调用之前提供Filter 来设置安 全的Web应用程序。

为了支持响应式和非阻塞交互，Spring Security的响应式栈，使用WebFilter并依赖Project  Reactor上下文。

首先还是maven坐标

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <artifactId>webflux-10-6-security</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-6-security</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.0</version>
            </plugin>
        </plugins>
    </build>
</project>

```

controller

```java
package org.example.webflux.controller;

import org.example.webflux.entity.Profile;
import org.example.webflux.service.ProfileService;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;


@RestController
@RequestMapping("api/v1")
public class SecurityProfileController {


    private final ProfileService profileService;

    public SecurityProfileController(ProfileService profileService) {
        this.profileService = profileService;
    }

    /**
     * @PreAuthorize 注解用于访问控制，检查Authentication 是否具有所需的角色。
     * @return
     */
    @GetMapping("/profiles")
    @PreAuthorize("hasRole('admin')")
    public Mono<Profile> getProfile() {
        return ReactiveSecurityContextHolder
                //访问当前的SecurityContext
                .getContext()
                //从SecurityContext中获取认证信息
                .map(SecurityContext::getAuthentication)
                //访问用户个人信息
                .flatMap(auth -> profileService.getByUser(auth.getName()));
    }

}

```

实体信息

```java
package org.example.webflux.entity;

public class Profile {

    /**
     * 名称
     */
    private String name;
    /**
     * 描述
     */
    private String desc;


    public Profile(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}
```

服务接口

```java
package org.example.webflux.service;

import org.example.webflux.entity.Profile;
import reactor.core.publisher.Mono;


public interface ProfileService {


    /**
     * 查询信息
     *
     * @param name 用户名
     * @return 信息
     */
    Mono<Profile> getByUser(String name);
}

```

实现:

```java
package org.example.webflux.service;

import org.example.webflux.entity.Profile;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Service
public class ProfileServiceImpl implements ProfileService {

    @Override
    public Mono<Profile> getByUser(String name) {
        return Mono.just(new Profile(name, name + "的描述信息"));
    }
}

```

配制信息 

```java
package org.example.webflux.config;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.core.userdetails.MapReactiveUserDetailsService;
import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.server.SecurityWebFilterChain;


@SpringBootApplication
//该注解导入所需的配制，以启用特定的带注解methodInterceptor
@EnableReactiveMethodSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity httpSecurity) {
        return httpSecurity
                //配制基于表单的认证
                .formLogin()
                //继续往下执行
                .and()
                //配制授权
                .authorizeExchange()
                //禁用授权
                .anyExchange()
                //需要有认证的用户
                .authenticated()
                //继续向下配制
                .and()
                .build();
    }

    @Bean
    public ReactiveUserDetailsService userDetailsService() {
        User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
        UserDetails user1 = userBuilder.username("nullnull")
                .password("123456")
                .roles("admin")
                .build();

        UserDetails user2 = userBuilder.username("lisi")
                .password("123456")
                .roles("none")
                .build();
        return new MapReactiveUserDetailsService(user1,user2);
    }

}

```

启动类：

```java
package org.example.webflux;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

}

```



启动服务，进行浏览器的访问

http://127.0.0.1:8080/api/v1/profile

会打开输入用户名和密码的界面:

输入：lisi/123456

```tex
Denied
```

http://127.0.0.1:8080/logout



再次输入：http://127.0.0.1:8080/api/v1/profiles

使用 nullnull/123456 登录

此时可以看到页面提示：

```tex
{"name":"nullnull","desc":"nullnull的描述信息"}
```





在内部， ReactiveSecurityContextHolder 依赖于Reactor Context API。 有关登录用户的当前信息保存在Context 接口的实例中。

源码：

```java
	/**
	 * Gets the {@code Mono<SecurityContext>} from Reactor {@link Context}
	 * @return the {@code Mono<SecurityContext>}
	 */
	public static Mono<SecurityContext> getContext() {
		// @formatter:off
		return Mono.subscriberContext()
				.filter(ReactiveSecurityContextHolder::hasSecurityContext)
				.flatMap(ReactiveSecurityContextHolder::getSecurityContext);
		// @formatter:on
	}

	/**
	 * 判断是否包含安全上下文
	 */
	private static boolean hasSecurityContext(Context context) {
		return context.hasKey(SECURITY_CONTEXT_KEY);
	}
	/**
	 * 获取对应的安全上下文
	 */
	private static Mono<SecurityContext> getSecurityContext(Context context) {
		return context.<Mono<SecurityContext>>get(SECURITY_CONTEXT_KEY);
	}
```





### 10.7 与其他响应库的交互

WebFlux 使用Project Reactor 3 作为核心构建块，同时，WebFlux 也允许使用其他响应式库。 

为了实现跨库互操作性，WebFlux 中的大多数操作基于响应式流规范中的接口。

案例

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.maxwell.datack</groupId>
    <artifactId>webflux-10-7-rxjava</artifactId>
    <packaging>jar</packaging>

    <name>webflux-10-7-rxjava</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>io.reactivex.rxjava2</groupId>
            <artifactId>rxjava</artifactId>
            <version>2.2.20</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

```

controller

```java
package com.nullnull.demo.controller;

import com.nullnull.demo.entity.User;
import io.reactivex.Observable;
import io.reactivex.ObservableSource;
import io.reactivex.functions.Function;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
public class AlbumsController {

    final ReactiveAdapterRegistry adapterRegistry;

    public AlbumsController(ReactiveAdapterRegistry adapterRegistry) {
        this.adapterRegistry = adapterRegistry;
    }

    @PostMapping("/info-by-user")
    public Observable<User> findByUserInfo(@RequestBody Mono<String> nameMono) {
        //将Mono转换为Observable类型
        Observable<String> observable = (Observable<String>) adapterRegistry.getAdapter(Observable.class)
                .fromPublisher(nameMono);

        return observable.flatMap(new Function<String, ObservableSource<? extends User>>() {
            @Override
            public ObservableSource<? extends User> apply(String s) throws Exception {
                return Observable.just(new User(s + "-用户名", 18, "地址信息"));
            }
        });
    }
}
```

user

```java
package com.nullnull.demo.entity;

public class User {

    /**
     * 用户名
     */
    private String name;


    /**
     * 年龄
     */
    private Integer age;

    /**
     * 地址
     */
    private String address;

    public User(String name, Integer age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("User{");
        sb.append("name='").append(name).append('\'');
        sb.append(", age=").append(age);
        sb.append(", address='").append(address).append('\'');
        sb.append('}');
        return sb.toString();
    }
}
```

启动类

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

}

```

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="jquery-1.9.1.js"></script>
    <script type="text/javascript">
        $(function () {
          $("#btn").click(function () {
            if ($("#userName").val() == '') {
              alert("请输入用户名称")
              $("#userName").focus()
              return
            }
            $.ajax({
              url: "/info-by-user",
              data: $("#userName").val(),
              contentType: "application/json;charset=utf-8",
              cache: false,
              method: "post",
              success: function (data) {
                alert(JSON.stringify(data))
              },
              error: function () {
                alert("通信异常")
              }
            })
          })
        })
    </script>
</head>
<body>
<input type="text" id="userName" placeholder="请输入用户名称">
<input id="btn" type="button" value="获取数据">
</body>
</html>
```

启动服务，在浏览器访问：http://127.0.0.1:8080/index.html

此样例输入nullnull,便可提示： 

```json
[{"name":"nullnull-用户名","age":18,"address":"地址信息"}]
```



## 11 Spring WebFlux与SpringWebMvc的对比

使用Spring MVC还是WebFlux？ Spring MVC和Spring WebFlux并不是分立的。

它们都扩展了开发的可用选项。 

两者设计的目标就是彼此的连续性和一致性，可以一起使用，发挥各自优势。

![image-20241212091856589](.\images\image-20241212091856589.png)

- 具体如何使用，考虑如下： 如果现存的项目是基于Spring MVC的并且没有问题，就别更改了。命令式编程开发、阅读、 debug都是最简单的。同时可选择的库也很多，只不过大多数都是阻塞式的。
- 如果项目的技术栈是非阻塞的，则使用WebFlux可以使用与环境相同的模型来执行，WebFlux 也提供了服务器的选项（Netty、Tomcat、Jetty、Undertow以及Servlet 3.1及以上的容 器），提供了编程模型的选项（基于注解的控制器和函数式web端点），以及响应式库的选项 （Reactor、RxJava以及其他的）。
- 如果希望发挥java8 lambda或Kotlin的优势，使用轻量级、函数式的web框架，则可以使用 Spring WebFlux函数式web端点的编程模型。Spring WebFlux非常适合小型的应用或没有复 杂需求的微服务。
- 在微服务架构中，可以同时使用Spring WebFlux和Spring MVC，或者将Spring WebFlux作为 函数式端点来使用。由于它们基于相同的注解编程模型，可以很方便的做到在正确的场合使用 正确的工具。
- 一个简单的评估应用的方式是检查应用的依赖。如果使用的是阻塞式的持久化API（JPA， JDBC）或者阻塞式的网络API，Spring MVC基本上是最好的选择。技术上Reactor和RxJava也 可以使用分立的线程支持阻塞式的操作，但无法发挥非阻塞web技术栈的全部优势。
- 如果Spring MVC应用需要调用远程服务，可以使用响应式的 WebClient 。可以让Spring MVC 控制器的方法直接返回响应式类型（Reactor、RxJava或其他的）数据。每个远程调用的延迟越大，各个远程调用之间的依赖越大，响应式模型的优势发挥的越明显。当然，Spring MVC 的控制器也可以调用其他响应式组件。
- 如果开发团队很大，就要考虑到转向非阻塞、函数式、声明式编程模型的陡峭的学习曲线。最佳实践是先使用响应式 WebClient 做部分转向。然后在小的模块中使用并评估响应式模型带 来的优势。一般对于整个项目，没必要全部转向响应式模型。如果不确定响应式编程带来的优 势，可以先学习一下非阻塞I/O的工作流程（例如单线程Node.js的并发）以及效果。



## 12 使用SpringBoot

### 12.1 spring Core中的响应式

Spring 生态系统的核心模块是Spring Core 模块。 

Spring 5.x 引入对响应式流和响应式库的原生支持，其中，响应式库包含RxJava 1/2 和Project  Reactor 3。

**响应式类型转换支持**

为了支持响应式流规范所进行的最全面的改进之一是引入了 ReactiveAdapter 和  ReactiveAdapterRegistry 。 

ReactiveAdapter 类为响应式类型转换提供了两种基本方法，用于将任何类型转换为  Publisher 并将其转换回 Object 。 

org.springframework.core.ReactiveAdapter#toPublisher

org.springframework.core.ReactiveAdapter#fromPublisher

```java
	/**
	 * Adapt the given instance to a Reactive Streams {@code Publisher}.
	 * @param source the source object to adapt from; if the given object is
	 * {@code null}, {@link ReactiveTypeDescriptor#getEmptyValue()} is used.
	 * @return the Publisher representing the adaptation
	 */
	@SuppressWarnings("unchecked")
	public <T> Publisher<T> toPublisher(@Nullable Object source) {
		if (source == null) {
			source = getDescriptor().getEmptyValue();
		}
		return (Publisher<T>) this.toPublisherFunction.apply(source);
	}

	/**
	 * Adapt from the given Reactive Streams Publisher.
	 * @param publisher the publisher to adapt from
	 * @return the reactive type instance representing the adapted publisher
	 */
	public Object fromPublisher(Publisher<?> publisher) {
		return this.fromPublisherFunction.apply(publisher);
	}
```

**响应式IO**

Spring Core 模块在 byte 缓冲区实例上引入了一个称为 DataBuffer 的抽象。 

之所以避免使用 java.nio.ByteBuffer ，主要是为了提供一个既可以支持不同字节缓冲区，又不 需要在它们之间进行任何额外的转换的抽象。

例如，为了将 io.netty.buffer.ByteBuf 转换为 ByteBuffer ，必须访问所存储的字节，而这 些字节可能需要从堆外空间被拉入到堆中。这可能破坏Netty 提供的高效内存使用和缓冲区回收（重用 相同的字节缓冲区）。

Spring DataBuffer 提供特定实现的抽象，能以通用方式使用底层实现。 

DataBuffer 的 PooledDataBuffer 子接口，还启用了引用计数功能，并支持开箱即用的高效内 存管理。

此外，Spring Core 的第五版引入了 DataBufferUtils 类，能以响应式流的形式与I/O 进行交互 （与网络、资源、文件等交互）。

DataBufferUtils.read 返回一个 DataBuffer 实例的 Flux 。

因此，可以使用 Reactor 的所有功 能读取文件内容。  

最后，与Spring Core 中响应式相关的最后一个意义重大且不可或缺的特性是响应式编解码器 （reactive codecs）。 

响应式编解码器提供了一种将 DataBuffer 实例流 和 对象流 进行相互转换的简便方式。

 Encoder 和 Decoder 接口即用于此目的，并提供以下用于编码/解码数据流的API：

```java
package org.springframework.core.codec;

......
/**
 * Strategy to encode a stream of Objects of type {@code <T>} into an output
 * stream of bytes.
 *
 * @author Sebastien Deleuze
 * @author Rossen Stoyanchev
 * @since 5.0
 * @param <T> the type of elements in the input stream
 */
public interface Encoder<T> {
......
	/**
	 * Encode a stream of Objects of type {@code T} into a {@link DataBuffer}
	 * output stream.
	 * @param inputStream the input stream of Objects to encode. If the input should be
	 * encoded as a single value rather than as a stream of elements, an instance of
	 * {@link Mono} should be used.
	 * @param bufferFactory for creating output stream {@code DataBuffer}'s
	 * @param elementType the expected type of elements in the input stream;
	 * this type must have been previously passed to the {@link #canEncode}
	 * method and it must have returned {@code true}.
	 * @param mimeType the MIME type for the output content (optional)
	 * @param hints additional information about how to encode
	 * @return the output stream
	 */
	Flux<DataBuffer> encode(Publisher<? extends T> inputStream, 
                            DataBufferFactory bufferFactory,
                            ResolvableType elementType, 
                            @Nullable MimeType mimeType, 
                            @Nullable Map<String, Object> hints);
......
}
```

decoder

```java
package org.springframework.core.codec;

......

/**
 * Strategy for decoding a {@link DataBuffer} input stream into an output stream
 * of elements of type {@code <T>}.
 *
 * @author Sebastien Deleuze
 * @author Rossen Stoyanchev
 * @since 5.0
 * @param <T> the type of elements in the output stream
 */
public interface Decoder<T> {
......
	/**
	 * Decode a {@link DataBuffer} input stream into a Flux of {@code T}.
	 * @param inputStream the {@code DataBuffer} input stream to decode
	 * @param elementType the expected type of elements in the output stream;
	 * this type must have been previously passed to the {@link #canDecode}
	 * method and it must have returned {@code true}.
	 * @param mimeType the MIME type associated with the input stream (optional)
	 * @param hints additional information about how to do encode
	 * @return the output stream with decoded elements
	 */
	Flux<T> decode(Publisher<DataBuffer> inputStream, 
                   ResolvableType elementType,
                   @Nullable MimeType mimeType,
                   @Nullable Map<String, Object> hints);
	/**
	 * Decode a {@link DataBuffer} input stream into a Mono of {@code T}.
	 * @param inputStream the {@code DataBuffer} input stream to decode
	 * @param elementType the expected type of elements in the output stream;
	 * this type must have been previously passed to the {@link #canDecode}
	 * method and it must have returned {@code true}.
	 * @param mimeType the MIME type associated with the input stream (optional)
	 * @param hints additional information about how to do encode
	 * @return the output stream with the decoded element
	 */
	Mono<T> decodeToMono(Publisher<DataBuffer> inputStream, 
                         ResolvableType elementType,
                         @Nullable MimeType mimeType, 
                         @Nullable Map<String, Object> hints);
......
}
```

两个接口都与响应式流中的 Publisher 一起运行，并能将 DataBuffer 实例流 编码/解码 为对象。 它以非阻塞的方式，将序列化数据转换为java对象，将java对象序列化为序列化数据。

这种编码/解码数据的方式可以减少处理延迟，这是因为响应式流在本质上支持独立的元素处理，而 不必等到最后一个字节才开始解码整个数据集。



### 12.2 响应式WEB

Spring Boot 2 引入了 WebFlux，支持高吞吐量、低延迟。 

Spring WebFlux建立在 响应式流适配器 之上，可以与 Netty 和 Undertow 以及基于 Servlet 3.1 的 传统服务器等集成。

Spring WebFlux 作为非阻塞的基础，将响应式流作为业务逻辑代码和服务器交互的中心抽象。

>注意，Servlet API 3.1 的适配器提供了与Web MVC 适配器不同的纯异步和非阻塞集成。 
>
>Spring Web MVC 模块也支持Servlet API 4.0，后者支持HTTP/2。

Spring WebFlux 将 Project Reactor 3 作为一等公民并广泛使用。

响应式编程可以开箱即用，还可以在 Netty 上运行Web 应用程序。

Spring WebFlux 模块提供内置的背压支持，可以确保 I/O 不会变得不堪重负。

Spring WebFlux 的 WebClient 类，实现非阻塞的客户端交互。

旧Web MVC 模块还获得了对响应式流的一些支持。 从框架的第五版开始，Servlet API 3.1 成为 Web MVC 模块的基线。意味着 Web MVC 现在支持  Servlet 规范提出的非阻塞I/O。Web MVC 模块的设计在适当级别的非阻塞 I/O 方面没有太大变化。

尽管如此，Servlet 3.0 的异步行为已经正确实现了一段时间。Spring Web MVC 为  ResponseBodyEmitterReturnValueHandler 类提供了升级。

由于Publisher 类可能被视为无限的事件流，因此在不破坏 Web MVC 模块的整个基础结构的情况 下，Emitter 处理程序是放置响应式处理逻辑的适当位置。为此，Web MVC 模块引入了  ReactiveTypeHandler 类，它负责正确处理 Flux 和 Mono 等响应式类型。

为了在客户端获得非阻塞行为，除了支持服务器端响应式类型的变更，还可以使用 WebFlux 模块所 提供的 WebClient 。  

Spring Boot 可以提供基于类路径中可用类的复杂环境管理行为。因此，通过提供Web  MVC（spring-boot-starter-web）模块以及 WebFlux，我们可以从 WebFlux 模块获得 Web MVC 环境 和非阻塞响应式 WebClient 。

最后，当将这两个模块作为响应式管道进行比较时，得到的结构如下图所示：

![image-20241212093754949](.\images\image-20241212093754949.png)

在 Web MVC 或 WebFlux 这两种用法中，得到了几乎相同的基于响应式流的编程模型。

这两个模块之间的显著差异之一是 Web MVC 需要在与源自旧模块设计的 Servlet API 集成时进行阻 塞式写入或阻塞式读取。该缺陷导致响应式流内的相互作用模型退化，使其降级为普通的拉模型。

同时，Web MVC 现在使用内部专用于所有阻塞读/写的线程池。因此，应该合理配置它以避免意外 行为。

WebFlux 通信模型取决于网络吞吐量以及可定义其自身控制流的底层传输协议。 

总而言之，Spring 5 引入了一个强大的工具，用于使用响应式流规范和 Project Reactor 构建响应 式非阻塞应用程序。

 此外，Spring Boot 支持强大的依赖管理和自动配置，可以保护我们免受依赖地狱的侵害。



### 12.3 响应式的Spring Data

Spring Data 主要提供对底层存储区域的同步阻塞访问。

 现在，Spring Data 框架提供了 ReactiveCrudRepository 接口，该接口暴露了Project Reactor 的响应式类型。

Spring Data 还提供了几个通过扩展 ReactiveCrudRepository 接口而与存储方法集成的模块。

- 基于 Spring Data Mongo 响应式模块的 MongoDB：与NoSQL 数据库之间的完全响应式非阻 塞交互，同时也包含背压控制。
- 基于 Spring Data Cassandra 响应式模块的 Cassandra：与Cassandra 数据存储的异步非阻 塞交互，支持基于TCP 流控制的背压。 
- 基于 Spring Data Redis 响应式模块的 Redis：通过Lettuce Java 客户端实现的与 Redis 之间 的响应式集成。
- 基于 Spring Data Couchbase 响应式模块的 Couchbase：通过基于 RxJava 的驱动程序实现 的与 Couchbase 数据库之间的响应式Spring Data 集成。

此外，Spring Boot 提供了额外的启动器模块，可以与所选的存储方法实现平滑集成。

除了NoSQL 数据库，Spring Data 还引入了 Spring Data JDBC ，与 JDBC 轻量级集成，快速提供响 应式 JDBC 连接。

其他 Spring 框架模块的大多数改进以 WebFlux 的响应式能力或响应式 Spring Data 模块为基础。



### 12.4 响应式Spring Session

Spring 框架中与Spring Web 模块相关的另一个重要更新是 Spring Session 模块中的响应式支持。

Spring Session 引入了 ReactiveSessionRepository，可以使用 Reactor 的 Mono 类型对存储的会 话进行异步非阻塞访问。

除此之外，作为响应式 Spring Data 的会话存储，Spring Session 还提供与 Redis 的响应式集成。

可以通过包含以下依赖项来实现分布式 WebSession：

```xml
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>
```

为了实现响应式 Redis WebSession 管理，必须将这3 个依赖项组合在一个地方。 

同时，Spring Boot 负责提供 bean 的精确组合并生成合适的自动配置，以便顺利地运行 Web 应用 程序。



### 12.5 响应式的Spring Security

旧的Spring Security 使用 ThreadLocal 作为 SecurityContext 实例的存储方法。在单个Thread 内 执行时，该技术很有效，在任何时候，都可以访问存储在ThreadLocal 中的SecurityContext。

但是，在执行异步通信时，该技术就会出现问题。这时，必须提供额外的工作来将 ThreadLocal 内 容传输到另一个Thread，并为Thread 实例之间的每个切换实例执行此操作。

尽管Spring 框架通过使用一个额外的 ThreadLocal 扩展简化了 Threads 之间的 SecurityContext  传输，但在基于 Project Reactor 或类似的响应式库应用响应式编程范例时，仍然会有问题。

新一代 Spring Security 采用了 Reactor 上下文功能，以便在 Flux 或 Mono 流中传输安全上下 文。通过这种方式，即使在运作着不同执行线程的复杂响应式流中，我们也可以安全地访问安全上下 文。



### 12.6 响应式的Spring Cloud

首先，响应式影响了分布式系统的入口点，即网关（gateway）。

很长一段时间，唯一能够将应用程序作为网关运行的 Spring 模块是 Spring Cloud Netflix Zuul 模 块。Netflix Zuul 基于使用阻塞同步请求路由的 Servlet API。使处理请求获得更好性能的唯一方法是调 整底层服务器线程池。

这种模型的伸缩性无法与响应式方法相比。

Spring Cloud 引入了新的 Spring Cloud Gateway 模块，该模块构建于 Spring WebFlux 之上，并 在 Project Reactor 3 的支持下提供异步和非阻塞路由。

除了新的网关模块，Spring Cloud Streams 还获得了Project Reactor 的支持，并且引入了更加细 粒度的流模型。

为了简化响应式系统的开发，Spring Cloud 引入了一个名为 Spring Cloud Function 的新模块，该 模块旨在为构建我们自己的函数即服务（function as a service ，FaaS）解决方案提供必要的组件。

如果没有适当的附加基础设施，Spring Cloud Function 模块将无法应用在普通开发中。Spring  Cloud Data Flow 不仅提供了这种可能性，还包含了Spring Cloud Function 的部分功能。



### 12.7 响应式Spring Test

Spring 生态系统提供了改进后的 Spring Test 和 Spring Boot Test 模块，它们扩展了一系列用于测 试响应式 Spring 应用程序的附加功能。

Spring Test 提供了一个 WebTestClient 来测试基于 WebFlux 的 Web 应用程序，同时，Spring  Boot Test 使用普通的注解来处理测试套件的自动配置。

同时，为了测试响应式流的 Publisher，Project Reactor 提供了Reactor-Test 模块，它与 Spring  Test 和 Spring Boot Test 模块相结合，可以为使用响应式Spring 实现的业务逻辑编写完整的验证套 件。



### 12.8 响应式监控

基于 Project Reactor 和响应式 Spring 框架构建的面向生产的响应式系统应该暴露所有重要的运维 指标。

首先，Project Reactor 本身具有内置指标。它提供 Flux#metrics() 方法，可以跟踪响应式流中 的不同事件。

Spring 框架生态系统提供了更新后的 Spring Boot Actuator 模块，该模块支持应用程序监控和故障 排除的主要指标。

新一代SpringActuator 提供与 WebFlux 的完全集成，并使用其异步、非阻塞编程模型，以便有效 地暴露指标端点。

Spring Cloud Sleuth 模块提供了监控和跟踪应用程序的最终选项。该模块提供开箱即用的分布式跟 踪，它的一个显著优点是支持 Project Reactor 的响应式编程，因此应用程序中的所有响应式工作流都可 以被正确跟踪。

Spring 生态系统不仅改进了内核框架的响应性，还负责面向生产的功能，而且支持详细的应用程序 监控（这种监控甚至包括这些功能的响应式解决方案）。



## 13 WebFlux的应用

### 13.1 基于微服务的系统

WebFlux 的第一个应用是微服务系统。 

微服务系统最显著的特点是大量的I/O 通信。

I/O 的存在，尤其是阻塞式I/O，会降低整体系统延迟和吞吐量。



**微服务网关(Spring Cloud Gateway)**

Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技 术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方 式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL，其不仅 提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限 流等。

Spring Cloud Gateway 功能特征

- 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0
- 动态路由
- Predicates 和 Filters 作用于特定路由
- 集成 Hystrix 断路器
- 集成 Spring Cloud DiscoveryClient
- 易于编写的 Predicates 和 Filters
- 限流
- 路径重写

![image-20241212122150710](.\images\image-20241212122150710.png)

客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相 匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到实 际服务执行业务逻辑，然后返回。

过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（ pre ）或之后（ post ）执行业 务逻辑。



### 13.2 大文件上传

maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-13-2-bigfile</artifactId>
    <packaging>jar</packaging>

    <name>webflux-13-2-bigfile</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.0</version>
            </plugin>
        </plugins>
    </build>
</project>

```

controller

```java
package com.nullnull.demo.controller;

import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.List;

@RestController
public class FileController {

    @RequestMapping("/single")
    public Mono<String> singleFile(@RequestPart("file") Mono<FilePart> file) {
        return file.map(filePart -> {
                    Path tmpFile = null;
                    try {
                        tmpFile = Files.createTempFile("file-", filePart.filename());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println("文件路径：" + tmpFile.toAbsolutePath());
                    AsynchronousFileChannel channel = null;
                    try {
                        channel = AsynchronousFileChannel.open(tmpFile, StandardOpenOption.WRITE);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    DataBufferUtils.write(filePart.content(), channel, 0)
                            .doOnNext(System.out::println)
                            .doOnComplete(() -> {
                                System.out.println("文件拷贝完成");
                            })
                            .subscribe();
                    return tmpFile;
                }).map(tmp -> tmp.toFile())
                .flatMap(fileSingle -> file.map(FilePart::filename));
    }

    @RequestMapping(value = "/multi")
    public Mono<List<String>> multiFiles(@RequestPart("file") Flux<FilePart> filePartFlux) {
        return filePartFlux.map(filePart -> {
                    Path tmpFile = null;
                    try {
                        tmpFile = Files.createTempFile("m-file-", filePart.filename());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println("m-文件路径：" + tmpFile.toAbsolutePath());
                    //对每个filePart执行写文件操作，零拷贝操作
                    filePart.transferTo(tmpFile.toFile());
                    //返回Path对象
                    return tmpFile;
                })
                .map(mfile -> mfile.toFile())
                .flatMap(fileSingle -> filePartFlux.map(FilePart::filename))
                .collectList();
    }

}

```

src/main/resources/static/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>大文件上传</title>
</head>
<body>
<form action="/single" method="post" enctype="multipart/form-data">
    <input type="file" name="file"/>
    <input type="submit" value="单文件上传">
</form>

<form action="/multi" method="post" enctype="multipart/form-data">
    <input type="file" name="file"/>
    <input type="file" name="file"/>
    <input type="file" name="file"/>
    <input type="submit" value="多文件上传">
</form>
</body>
</html>
```

启动入口

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }
}

```

启动程序

访问页面： http://127.0.0.1:8080/index.html

可以分别测试单文件上传与多文件上传

可以看到控制台输出：

单文件:

```tex
文件路径：C:\Users\Maxwell\AppData\Local\Temp\file-5354389810824008590utc-config.tar.gz
DefaultDataBuffer (r: 0, w: 18580, c: 18580)
文件拷贝完成
```

多文件：

```tex
m-文件路径：C:\Users\Maxwell\AppData\Local\Temp\m-file-3452588913649272045data.txt
m-文件路径：C:\Users\Maxwell\AppData\Local\Temp\m-file-1492168297634793458list-file.txt
m-文件路径：C:\Users\Maxwell\AppData\Local\Temp\m-file-7095852952379149659thread.data
文件路径：C:\Users\Maxwell\AppData\Local\Temp\file-3795965543622293995
DefaultDataBuffer (r: 0, w: 0, c: 0)
文件拷贝完成
```



### 13.3 处理端连接速度慢的系统

WebFlux 的第二个应用是构建系统，而这些系统的目标是在缓慢或不稳定网络连接条件下适用于移 动设备客户端。要理解为什么WebFlux 在这个领域有用，就要回想一下在处理一个慢速连接时会发生什 么。问题在于，将数据从客户端传输到服务器可能花费大量时间，并且相应的响应也可能花费大量时 间。在使用单连接单线程模型的情况下，已连接客户端数量越多，系统崩溃的可能性越大。例如，黑客 能很容易的通过使用拒绝服务（Denial-of-Service，DoS）攻击使我们的服务器不可用。

相比之下，WebFlux 使我们能在不阻塞工作线程的情况下接受连接。这样，慢速连接不会导致任何 问题。在等待传入请求体时，WebFlux 将继续接收其他连接而不会阻塞。响应式流抽象使我们能在需要 时消费数据。这意味着服务器可以根据网络的就绪情况控制事件消费。



### 13.4 流系统或实时系统

WebFlux 的另一个有用的应用是实时流系统。要了解WebFlux 为什么能在这一点上提供帮助，就要 回想实时流系统是什么。

首先，这些系统的特点是低延迟和高吞吐量。在流系统中，大多数数据是从服务器端传出的，因此 客户端扮演消费者的角色。通常来自于客户端的事件少于来自于服务器端的事件。但是，在在线游戏等 实时系统中，传入数据量等于传出数据量。

使用非阻塞通信可以实现低延迟和高吞吐量。正如前文所述，非阻塞异步通信可以实现高效的资源 利用，而基于Netty 或类似框架的系统可以实现最高的吞吐量和最低的延迟。然而，这种响应式框架有 其自身的缺点，即使用通道和回调的复杂交互模型。

尽管如此，响应式编程仍然可以巧妙地解决这两个问题。正如第4 章所述，响应式编程，尤其是响 应式库（如Reactor 3）可以帮助我们构建一个异步的非阻塞流而只需要很少的开销。这些开销来自基础 代码复杂性和可接受的学习曲线。这两种解决方案都包含在WebFlux中。使用Spring框架可以让我们轻 松构建这样的系统。



## 14 Spring WebFlux 数据库访问

### 14.1 响应式持久化库的工作原理

Spring Data 中的响应式存储库通过适配底层数据库驱动来工作。

ReactiveMongoRepository 继承了 ReactiveSortingRepository 和  ReactiveQueryByExampleExecutor 等更多通用接口。

ReactiveQueryByExampleExecutor 接口可以使用 QBE 语言执行查询。

ReactiveSortingRepository 接口扩展了 ReactiveCrudRepository 接口；并添加了  findAll 方法，该方法能对请求查询结果进行排序。

ReactiveCrudRepository 声明了用于保存、查找和删除实体的方法。

- Mono save(T entity) 方法保存 entity ，然后返回所保存的实体。保存操作可能更改 整个实体对象。
- Mono findById(ID id) 操作实体的 id 并返回包装在 Mono 中的结果。
- findAllById 方法有两个重载方法，其中一个重载方法以 Iterable集合的形式消费 ID， 另一个则采用Publisher的形式。
- ReactiveCrudRepository 和 CrudRepository 之间唯一值得注意的区别在于  ReactiveCrudRepository 没有分页且不能进行事务操作。

**分页支持**

Spring Data 故意省略分页，因为同步存储库中使用的实现方案不适合响应式。

因为：

1. 要计算下一页的参数，需要知道前一个结果的返回记录数。
2.  要计算分页总数，需要查询记录总数。

这两个方面都不符合响应式非阻塞范式。

另外，通过查询数据库计算总行数不仅相当消耗资源，还在实际数据处理之前增加了延迟。

但是，通过将 Pageable 对象传递到存储库，仍然可以获取数据块，如下所示：

```java
pubic interface ReactiveBookRepository extends ReactiveSortingRepository<Book, Long> {
    Flux<Book> findByAuthor(String author, Pageable pageable);
}

//所以，现在请求结果的第二页（索引从 0 开始），其中每页包含 5 个元素：调用
Flux<Book> result = reactiveBookRepository.findByAuthor("Andy Weir", PageRequest.of(1, 5));
```



ReactiveMongoRepository实现细节

Spring Data MongoDB Reactive 模块只有一个针对 ReactiveMongoRepository 接口的实现，即 SimpleReactiveMongoRepository 类：

1. 它为 ReactiveMongoRepository 的所有方法提供实现； 
2.  并使用 ReactiveMongoOperations 接口处理所有较低级别的操作。

```java
package org.springframework.data.mongodb.repository.support;

......

/**
 * Reactive repository base implementation for Mongo.
 *
 * @author Mark Paluch
 * @author Oliver Gierke
 * @author Christoph Strobl
 * @author Ruben J Garcia
 * @since 2.0
 */
public class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {

......
    
	/**
	 *  批量用户查询操作，使用Stream流将id的迭代器錾为不可变集合，一批发送
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#findAllById(java.lang.Iterable)
	 */
	@Override
	public Flux<T> findAllById(Iterable<ID> ids) {

		Assert.notNull(ids, "The given Iterable of Id's must not be null!");

		return findAll(new Query(new Criteria(entityInformation.getIdAttribute())
				.in(Streamable.of(ids).stream().collect(StreamUtils.toUnmodifiableList()))));
	}

	/*
	 * 从Publisher接收到一个元素就发送一个元素，此为一个一个查询操作
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#findAllById(org.reactivestreams.Publisher)
	 */
	@Override
	public Flux<T> findAllById(Publisher<ID> ids) {

		Assert.notNull(ids, "The given Publisher of Id's must not be null!");

		return Flux.from(ids).buffer().flatMap(this::findAllById);
	} 
......
    
    
	/*
	 * 通过流将元素转换为集合，进行一次批量的插入操作
	 * (non-Javadoc)
	 * @see org.springframework.data.mongodb.repository.ReactiveMongoRepository#insert(java.lang.Iterable)
	 */
	@Override
	public <S extends T> Flux<S> insert(Iterable<S> entities) {

		Assert.notNull(entities, "The given Iterable of entities must not be null!");

		List<S> source = Streamable.of(entities).stream().collect(StreamUtils.toUnmodifiableList());

		return source.isEmpty() ? Flux.empty() : Flux.from(mongoOperations.insertAll(source));
	}

	/*
	 * 从Publisher处订阅，然后一条一条的发送至数据库。
	 * (non-Javadoc)
	 * @see org.springframework.data.mongodb.repository.ReactiveMongoRepository#insert(org.reactivestreams.Publisher)
	 */
	@Override
	public <S extends T> Flux<S> insert(Publisher<S> entities) {

		Assert.notNull(entities, "The given Publisher of entities must not be null!");

		return Flux.from(entities).flatMap(entity -> mongoOperations.insert(entity, entityInformation.getCollectionName()));
	}
......
    
	/*
	 * 在所有实体都是新的情况下，只发出一个查询。
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#saveAll(java.lang.Iterable)
	 */
	@Override
	public <S extends T> Flux<S> saveAll(Iterable<S> entities) {

		Assert.notNull(entities, "The given Iterable of entities must not be null!");

		Streamable<S> source = Streamable.of(entities);

		return source.stream().allMatch(entityInformation::isNew) ? //
				mongoOperations.insert(source.stream().collect(Collectors.toList()), entityInformation.getCollectionName()) : //
				Flux.fromIterable(entities).flatMap(this::save);
	}

	/*
	 * 为每个实体发出查询
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#saveAll(org.reactivestreams.Publisher)
	 */
	@Override
	public <S extends T> Flux<S> saveAll(Publisher<S> entityStream) {

		Assert.notNull(entityStream, "The given Publisher of entities must not be null!");

		return Flux.from(entityStream).flatMap(entity -> entityInformation.isNew(entity) ? //
				mongoOperations.insert(entity, entityInformation.getCollectionName()).then(Mono.just(entity)) : //
				mongoOperations.save(entity, entityInformation.getCollectionName()).then(Mono.just(entity)));
	}    
......
	/*
	 * 总是为每个实体发出一个查询
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#deleteAll(java.lang.Iterable)
	 */
	@Override
	public Mono<Void> deleteAll(Iterable<? extends T> entities) {

		Assert.notNull(entities, "The given Iterable of entities must not be null!");

		return Flux.fromIterable(entities).flatMap(this::delete).then();
	}

	/*
	 * 方法总是为每个实体发出一个查询，即使所有实体在 Iterable 容器中都可用并且不需要等待元素异步显示也是如此。
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.reactive.ReactiveCrudRepository#deleteAll(org.reactivestreams.Publisher)
	 */
	@Override
	public Mono<Void> deleteAll(Publisher<? extends T> entityStream) {

		Assert.notNull(entityStream, "The given Publisher of entities must not be null!");

		return Flux.from(entityStream)//
				.map(entityInformation::getRequiredId)//
				.flatMap(this::deleteById)//
				.then();
	}
......

}
```

RepositoryFactorySupport 为 ReactiveCrudRepository 生成适当的代理。

 当使用 @Query 注解修饰方法时， ReactiveStringBasedMongoQuery 类用于生成查询。 

ReactivePartTreeMongoQuery 类用于基于方法名称约定的查询生成。 

将 ReactiveMongoTemplate 的日志级别设置为 DEBUG 时，可以跟踪发送到 MongoDB 的所有查 询。



在底层， ReactiveMongoTemplate 使用 ReactiveMongoDatabaseFactory 接口来获取响应式  MongoDB 连接的实例。 它使用 MongoConverter 接口的实例将实体转换为文档，反之亦然。 MongoConverter 也适用于同步 MongoTemplate 。

使用响应式驱动程序（MongoDB）

Spring Data 中的响应式 MongoDB 连接基于 MongoDB 响应式流 Java 驱动程序构建。 

该驱动程序提供具有非阻塞背压的异步流处理。

此外，响应式驱动程序构建在 MongoDB 异步 Java驱动程序之上。

异步驱动程序是低级别的，并且具有基于回调的 API，因此它不像较高级别的响应式流驱动程序那 样易于使用。

除了 MongoDB 响应式流 Java 驱动程序，还有 MongoDB RxJava 驱动程序，而后者基于同一个异 步 MongoDB 驱动程序。

因此，针对MongoDB 连接，Java 生态系统准备了一个同步驱动程序、一个异步驱动程序和两个响 应式驱动程序。



![image-20241213090828141](.\images\image-20241213090828141.png)



### 14.2 响应式事务

对于同步处理的情况，事务对象通常保存在 ThreadLocal 容器中。 

但是 ThreadLocal 不适合用于响应式处理方式，因为用户无法控制线程切换。 

事务需要将底层资源绑定到物化数据流。 

在 Project Reactor 中，可以通过 Reactor 上下文来实现这一目标。



### 14.2.1 基于MongoDB 4的响应式事务

MongoDB 从 4.0 版开始支持多文档事务（multi-document transactions）。

Spring Data 没有任何在服务或存储库级别应用响应式事务的功能。但是，可以使用 ReactiveMongoOperations 级别（由 ReactiveMongoTemplate 实现）的事务进行操作。

首先，多文档事务是 MongoDB 的一项新功能。它仅适用于使用 WiredTiger 存储引擎的非分片副 本集。在 MongoDB 4.0 中，没有其他配置支持多文档事务。

其次，某些 MongoDB 功能在事务中不可用，如，发出元命令和创建集合或索引都是不可能的。同 时，隐式创建集合在事务中不起作用。因此，需要设置所需的数据库结构以防止错误。

此外，某些命令的行为可能有所不同。

以转账场景为例，进行事务验证：

要将一笔款项从账户 A 转账到账户 B，应该执行以下操作：

1. 启动新事务。

2. 加载账户 A 的钱包。 

3.  加载账户 B 的钱包。

4. 检查账户 A 的钱包中是否有足够的资金。 

5. 提取转账金额并计算账户 A 的新余额。

6.  存入转账金额并计算账户 B 的新余额。 

7. 保存账户 A 的钱包。 

8. 保存账户 B 的钱包。 

9. 提交事务。

   准备MongoDB数据库：

**1. mongo数据库搭建**

安装mongoDB

```sh
#准备压缩包半上传服务器
# 压缩包下载地址：https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.8.tgz

# 解压缩
tar -zxf mongodb-linux-x86_64-rhel70-4.2.8.tgz -C /opt/

# 配制环境变量,添加
vi /etc/profile

export MONGO_HOME=/opt/mongodb-linux-x86_64-rhel70-4.2.8
export PATH=${PATH}:${MONGO_HOME}/bin

# 生效环境变量
source /etc/profile

# 查看环境变量
 echo $PATH
 # 出现mongo的目录即为成功
....../opt/mongodb-linux-x86_64-rhel70-4.2.8/bin
```

配制集群

cd /opt/mongodb-linux-x86_64-rhel70-4.2.8

vi mongo_37017.conf

```properties
dbpath=/data/mongo/data/server17
bind_ip=0.0.0.0
port=37017
fork=true
logpath=/data/mongo/logs/server17.log
replSet=nullnullCluster
```

vi mongo_37018.conf

```properties
dbpath=/data/mongo/data/server18
bind_ip=0.0.0.0
port=37018
fork=true
logpath=/data/mongo/logs/server18.log
replSet=nullnullCluster
```

vi mongo_37019.conf

```properties
dbpath=/data/mongo/data/server19
bind_ip=0.0.0.0
port=37019
fork=true
logpath=/data/mongo/logs/server19.log
replSet=nullnullCluster
```

执行目录的创建

```sh
mkdir -p /data/mongo/data/server17 /data/mongo/data/server18 /data/mongo/data/server19 /data/mongo/logs
```

启动monodb

```sh
mongod -f mongo_37017.conf
mongod -f mongo_37018.conf
mongod -f mongo_37019.conf

# 打开防火墙
firewall-cmd --permanent --zone=public --add-port=37017/tcp
firewall-cmd --permanent --zone=public --add-port=37018/tcp
firewall-cmd --permanent --zone=public --add-port=37019/tcp
firewall-cmd --reload  
```

查看进程

```sh
ps aux | grep mongo
ss -nelp | grep mongo
```

当启动完成，可以查看到进程状态:

```sh
[root@standone-os mongodb-linux-x86_64-rhel70-4.2.8]# ps aux | grep mongo
root      5286  1.0  0.1 1570660 82760 ?       Sl   11:20   0:00 mongod -f mongo_37017.conf
root      5324  1.3  0.1 1569636 77992 ?       Sl   11:20   0:00 mongod -f mongo_37018.conf
root      5370  3.0  0.1 1569624 83112 ?       Sl   11:21   0:00 mongod -f mongo_37019.conf
root      5407  0.0  0.0 112812   972 pts/0    S+   11:21   0:00 grep --color=auto mongo
[root@standone-os mongodb-linux-x86_64-rhel70-4.2.8]# ss -nelp | grep mongo
u_str  LISTEN     0      128    /tmp/mongodb-37019.sock 36853                 * 0                   users:(("mongod",pid=5370,fd=10)) <->
u_str  LISTEN     0      128    /tmp/mongodb-37017.sock 40122                 * 0                   users:(("mongod",pid=5286,fd=10)) <->
u_str  LISTEN     0      128    /tmp/mongodb-37018.sock 36846                 * 0                   users:(("mongod",pid=5324,fd=10)) <->
tcp    LISTEN     0      128       *:37017                 *:*                   users:(("mongod",pid=5286,fd=11)) ino:40123 sk:ffff9073d0a0be00 <->
tcp    LISTEN     0      128       *:37018                 *:*                   users:(("mongod",pid=5324,fd=11)) ino:36847 sk:ffff9073d0ae5540 <->
tcp    LISTEN     0      128       *:37019                 *:*                   users:(("mongod",pid=5370,fd=11)) ino:36854 sk:ffff9073d0ae5d00 <->
[root@standone-os mongodb-linux-x86_64-rhel70-4.2.8]# 
```



初始化配制

配制host

vi /etc/hosts

```sh
192.168.5.16 node16
```



```sh
# 进入mongo，进行配制
mongo -port 37017

var cfg = {"_id":"nullnullCluster", "protocolVersion":1, "members":[
   {"_id":1, "host":"node16:37017", "priority":10},
   {"_id":2, "host":"node16:37018"},
   {"_id":3, "host":"node16:37019"}
]}

rs.initiate(cfg)
rs.status()
```

节点检查

```sh
# 启用slave节点的读
rs.slaveOk()
# 查看状态
rs.status()
# 增加节点
rs.add("node2:37019")
# 删除节点
rs.remove("node2:37019")
```

节点说明： 

PRIMARY节点：可以查询和新增数据 

SECONDARY节点：只能查询，不能新增，基于priority权重可以被选为主节点 

ARBITER节点：不能查询数据和新增数据，不能变为主节点



maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-14-2-mongo-tx</artifactId>
    <packaging>jar</packaging>

    <name>webflux-14-2-mongo-tx</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
        </dependency>
        <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
             <version>30.1-jre</version>
        </dependency>
        <dependency>
             <groupId>org.testcontainers</groupId>
             <artifactId>testcontainers</artifactId>
             <version>1.15.1</version>
             <scope>test</scope>
        </dependency>
        <dependency>
             <groupId>org.projectlombok</groupId>
             <artifactId>lombok</artifactId>
             <optional>true</optional>
        </dependency>
        <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-test</artifactId>
             <scope>test</scope>
        </dependency>
        <dependency>
             <groupId>io.projectreactor</groupId>
             <artifactId>reactor-test</artifactId>
             <scope>test</scope>
        </dependency>
        
    </dependencies>
</project>

```

实体信息

```java
package com.nullnull.demo.entity;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Document("wallet")
@Getter
@Setter
@ToString
public class Wallet {

    @Id
    private ObjectId id;

    private String owner;

    /**
     * 余额
     */
    private int balance;

    /**
     * 入账笔数
     */
    private int depositOperations;

    /**
     * 转账笔数
     */
    private int withdrawOperations;

    public Wallet(
            ObjectId id, String owner, int balance, int depositOperations, int withdrawOperations) {
        this.id = id;
        this.owner = owner;
        this.balance = balance;
        this.depositOperations = depositOperations;
        this.withdrawOperations = withdrawOperations;
    }

    /**
     * 余额检查
     *
     * @param amount
     * @return
     */
    public boolean hasEnoughFunds(int amount) {
        return balance >= amount;
    }

    /**
     * 扣除余额
     *
     * @param amount
     */
    public void withDraw(int amount) {
        if (!hasEnoughFunds(amount)) {
            throw new RuntimeException("Not enough founds!");
        }

        this.balance = this.balance - amount;
        this.withdrawOperations += 1;
    }

    /**
     * 增加余额
     *
     * @param amount
     */
    public void deposit(int amount) {
        this.balance = this.balance + amount;
        this.depositOperations += 1;
    }

    public static Wallet wallet(String owner, int balance) {
        return new Wallet(new ObjectId(), owner, balance, 0, 0);
    }

}

```

存储层的接口

```java
package com.nullnull.demo.reporitory;

import com.nullnull.demo.entity.Wallet;
import org.bson.types.ObjectId;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

@Repository
public interface WalletRepository extends ReactiveMongoRepository<Wallet, ObjectId> {

  /**
   * 查询用户的钱包
   *
   * @param owner
   * @return
   */
  Mono<Wallet> findByOwner(Mono<String> owner);
}

```

服务层的接口

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Wallet;
import lombok.ToString;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface WalletService {

    /**
     * 生成指定的个数的账户信息
     *
     * @param number         账户个数
     * @param defaultBalance 默认的余额
     * @return 返回账户的名称信息
     */
    Flux<String> generateClients(Integer number, Integer defaultBalance);

    /**
     * 转账操作
     *
     * @return
     */
    Mono<TxResult> transferMoney(Mono<String> fromOwner, Mono<String> toOwner, Mono<Integer> amount);

    /**
     * 钱包的统计操作
     *
     * @return
     */
    Mono<Statistics> reportAllWallets();

    /**
     * 移除所有数据
     *
     * @return
     */
    Mono<Void> removeAllClients();

    enum TxResult {
        SUCCESS,
        NOT_ENOUGH_FOUNDS,
        TX_CONFLICT
    }

    @ToString
    class Statistics {

        /**
         * 总的转账笔数
         */
        private long totalAccounts;

        /**
         * 转账的总金额
         */
        private long totalBalance;

        /**
         * 总入帐
         */
        private long totalDeposits;

        /**
         * 总出账
         */
        private long totalWithdraws;

        public Statistics() {
        }

        public Statistics(
                long totalAccounts, long totalBalance, long totalDeposits, long totalWithdraws) {
            this.totalAccounts = totalAccounts;
            this.totalBalance = totalBalance;
            this.totalDeposits = totalDeposits;
            this.totalWithdraws = totalWithdraws;
        }

        public Statistics withWallet(Wallet w) {
            return new Statistics(
                    this.getTotalAccounts() + 1,
                    this.getTotalBalance() + w.getBalance(),
                    this.getTotalDeposits() + w.getDepositOperations(),
                    this.totalWithdraws + w.getWithdrawOperations());
        }

        public long getTotalAccounts() {
            return totalAccounts;
        }

        public long getTotalBalance() {
            return totalBalance;
        }

        public long getTotalDeposits() {
            return totalDeposits;
        }

        public long getTotalWithdraws() {
            return totalWithdraws;
        }
    }
}
```

服务层的基类

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Wallet;
import com.nullnull.demo.reporitory.WalletRepository;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Comparator;


@Slf4j
public abstract class BaseWalletService implements WalletService {

    protected final WalletRepository walletRepository;

    public BaseWalletService(WalletRepository walletRepository) {
        this.walletRepository = walletRepository;
    }

    @Override
    public Flux<String> generateClients(Integer number, Integer defaultBalance) {

        return walletRepository
                .saveAll(
                        // 生成指定数量的值
                        Flux.range(1, number)
                                // 将id转换为字符串名称
                                .map(id -> String.format("client-%05d", id))
                                // 转换为钱包对象
                                .map(owner -> Wallet.wallet(owner, defaultBalance)))
                // 返回包的用户
                .map(Wallet::getOwner);
    }


    @Override
    public Mono<Statistics> reportAllWallets() {
        return walletRepository
                //查询所有的账户信息
                .findAll()
                //按用户排序
                .sort(Comparator.comparing(Wallet::getOwner))
                //执行副作用，打印日志
                .doOnNext(
                        item ->
                                log.info(
                                        String.format(
                                                "%10s: %7d$ (d:%5s | w: %5s)",
                                                item.getOwner(),
                                                item.getBalance(),
                                                item.getDepositOperations(),
                                                item.getWithdrawOperations())))
                //将所有的用户账户归结一个统计对象返回
                .reduce(new Statistics(), Statistics::withWallet);
    }

    @Override
    public Mono<Void> removeAllClients() {
        return walletRepository.deleteAll();
    }
}

```

服务层的实现

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Wallet;
import com.nullnull.demo.reporitory.WalletRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.mongodb.core.ReactiveMongoContext;
import org.springframework.data.mongodb.core.ReactiveMongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.time.Instant;

@Slf4j
@Component
public class TransactionalWalletService extends BaseWalletService {

    private final ReactiveMongoTemplate mongoTemplate;

    public TransactionalWalletService(
            WalletRepository walletRepository, ReactiveMongoTemplate mongoTemplate) {
        super(walletRepository);
        this.mongoTemplate = mongoTemplate;
    }

    @Override
    public Mono<TxResult> transferMoney(
            Mono<String> fromOwner, Mono<String> toOwner, Mono<Integer> amount) {
        return Mono
                //订阅上游3个元素，等所有都到达后，送给下游
                .zip(fromOwner, toOwner, amount)
                //订阅上游流元素，进行数据转换
                .flatMap(
                        data -> {
                            //记录下开始时间
                            Instant start = Instant.now();
                            //执行转账操作
                            return doTransferMoney(data.getT1(), data.getT2(), data.getT3())
                                    //错误时返回,TX_CONFLICT
                                    .onErrorReturn(TxResult.TX_CONFLICT)
                                    //成功时记录下日志
                                    .doOnSuccess(
                                            result ->
                                                    log.info(
                                                            "transaction result: {} took: {}",
                                                            result,
                                                            Duration.between(start, Instant.now())));
                        });
    }

    private Mono<TxResult> doTransferMoney(String from, String to, Integer amount) {
        return mongoTemplate
                //开启事务
                .inTransaction()
                //执行操作,传入回调函数,回调函数的参数的会话对象
                .execute(
                        session ->
                                session
                                        //查找转帐的账号信息
                                        .findOne(queryForOwner(from), Wallet.class)
                                        //订阅并执行钱包操作
                                        .flatMap(
                                                fromWallet ->
                                                        session
                                                                //查找接收账号信息
                                                                .findOne(queryForOwner(to), Wallet.class)
                                                                //订阅并执行转换逻辑
                                                                .flatMap(
                                                                        toWallet -> {
                                                                            //检查钱包余额是否足够,如果足够执行转账
                                                                            if (fromWallet.hasEnoughFunds(amount)) {
                                                                                //扣除原始账户的余额
                                                                                fromWallet.withDraw(amount);
                                                                                //增加目标账号的余额
                                                                                toWallet.deposit(amount);

                                                                                return session
                                                                                        //保存原始钱包信息
                                                                                        .save(fromWallet)
                                                                                        //保存目标钱包信息
                                                                                        .then(session.save(toWallet))
                                                                                        //获取session对象，则返回成流
                                                                                        .then(ReactiveMongoContext.getSession())
                                                                                        //执行副作用，打印日志
                                                                                        .doOnNext(tx -> log.info(
                                                                                                "current session: {}"
                                                                                                , tx))
                                                                                        //返回转账成功
                                                                                        .then(Mono.just(TxResult.SUCCESS));
                                                                            }
                                                                            //不足则返回余额不足
                                                                            else {
                                                                                return Mono.just(TxResult.NOT_ENOUGH_FOUNDS);
                                                                            }
                                                                        })))
                //如果转账发生错误，则返回包装异常返回
                .onErrorResume(e -> Mono.error(new RuntimeException("Conflict")))
                .last();
    }

    /**
     * 查询方法
     *
     * @param owner
     * @return
     */
    private Query queryForOwner(String owner) {
        return Query.query(new Criteria("owner").is(owner));
    }
}

```

服务启动入口:

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }
}

```

配制文件:

application.yml

```yml
spring:
  data:
   mongodb:
     uri: "mongodb://node16:37017,node16:37018,node16:37019/wallet"
    #host: "192.168.5.16"
    #port: 37017
    #database: "wallet"
#   username: "root"
#   password: "123456"
#   authentication-database: "admin"

logging:
  level:
   reactor.core.publisher.FluxUsingWhen: ERROR
#  org.springframework.data.mongodb.core.ReactiveMongoTemplate: DEBUG
```



单元测试基类:

```java
package com.nullnull.demo;

import com.nullnull.demo.service.WalletService;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;
import reactor.core.scheduler.Schedulers;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Random;

@SuppressWarnings("Duplicates")
@Slf4j
@DataMongoTest
public class TestBaseWalletService {


    /**
     * 转账测试工具类
     *
     * @param walletService
     * @return
     */
    protected Tuple2<Long, Long> simulateOperations(WalletService walletService) {
        //账号数量
        int accounts = 500;
        //每个账号的金额
        int defaultBalance = 1000;
        //操作次数
        int iterations = 1000;
        //并行操作数量
        int parallelism = 200;

        //清除所有数据，在清除完成前，进行等待状态
        walletService.removeAllClients().block();

        //创建指定个数的账号，并返回账号的名称
        List<String> clients = walletService
                //创建账号信息
                .generateClients(accounts, defaultBalance)
                //执行副作用
                .doOnNext(name -> log.info("create wallet for : {}", name))
                //收到一个List集合
                .collectList()
                //阻塞直到最后完成
                .block();

        //并行操作的调度器
        Scheduler mongoScheduler = Schedulers.newParallel("MongoOperations", parallelism);

        //记录当前时间
        Instant startTime = Instant.now();

        OperationalSimulation simulation = OperationalSimulation.builder()
                //设置转账的钱包的服务
                .walletService(walletService)
                //设置全部用户名
                .clients(clients)
                //设置默认的余额
                .defaultBalance(defaultBalance)
                //操作转账次数
                .iterations(iterations)
                //并行的调度线程
                .simulationScheduler(mongoScheduler)
                .build();

        OperationStats operations = simulation
                //执行事务操作
                .runSimulation()
                //等待所有的事务完成
                .block();

        log.info("-------result--------------------------------------------");
        //收集所有账户的报告
        WalletService.Statistics statistsics = walletService.reportAllWallets().block();

        log.info("Expected/actual total balance : {} $/ {}$ | Took : {}",
                accounts * defaultBalance,
                statistsics.getTotalAccounts(),
                Duration.between(startTime, Instant.now())
        );
        log.info("{}", statistsics);
        log.info("{}", operations);


        log.info("Clean up database");

        //移除所有账户信息
        walletService.removeAllClients().block();

        return Tuples.of((long) accounts * defaultBalance, statistsics.getTotalBalance());
    }

    @Builder
    @RequiredArgsConstructor
    @ToString
    public static class OperationalSimulation {
        private final WalletService walletService;
        private final List<String> clients;
        private final int defaultBalance;
        private final int iterations;
        private final Scheduler simulationScheduler;
        private final Random random = new Random();

        public Mono<OperationStats> runSimulation() {
            return Flux
                    //指定的转账操作次数
                    .range(0, iterations)
                    //转换,以异步的方式，允许交错操作
                    .flatMap(i ->
                            Mono
                                    //操作延迟10毫秒
                                    .delay(Duration.ofMillis(random.nextInt(10)))
                                    //订阅原始响应流
                                    .publishOn(simulationScheduler)
                                    //数据被订阅，并且不允许交错
                                    .flatMap(item -> {
                                        //转账账户
                                        String fromOwner = randomOwner();
                                        //接收账户
                                        String toOwner = randomOwnerExcept(fromOwner);
                                        //转账的金额
                                        int amount = randomTransferAmount();

                                        //执行转账操作
                                        return walletService.transferMoney(Mono.just(fromOwner),
                                                Mono.just(toOwner),
                                                Mono.just(amount)
                                        );
                                    })
                    )
                    //将所有转账的数据进行归结操作
                    .reduce(OperationStats.start(), OperationStats::countTxResult);
        }

        /**
         * 转账的金额
         *
         * @return
         */
        private int randomTransferAmount() {
            return random.nextInt(defaultBalance);
        }

        /**
         * 转账的账户
         *
         * @return
         */
        private String randomOwner() {
            int from = random.nextInt(clients.size());
            return clients.get(from);
        }

        /**
         * 接收方账号,要求接收账号不能是自己
         *
         * @param fromOwner
         * @return
         */
        private String randomOwnerExcept(String fromOwner) {
            String toOwner;
            do {
                int to = random.nextInt(clients.size());
                toOwner = clients.get(to);
            } while (fromOwner.equals(toOwner));
            return toOwner;
        }
    }

    @ToString
    @RequiredArgsConstructor
    public static class OperationStats {
        private final int successFul;
        private final int notEnoughFounds;
        private final int conflict;

        /**
         * 针对转账结果进行统计
         *
         * @param result
         * @return
         */
        public OperationStats countTxResult(WalletService.TxResult result) {
            switch (result) {
                //如果成功，则成功的笔数加1
                case SUCCESS:
                    return new OperationStats(successFul + 1, notEnoughFounds, conflict);
                //余额不足，则不足的笔记加1
                case NOT_ENOUGH_FOUNDS:
                    return new OperationStats(successFul, notEnoughFounds + 1, conflict);
                //失败，则失败的笔记加1
                case TX_CONFLICT:
                    return new OperationStats(successFul, notEnoughFounds, conflict + 1);
                default:
                    throw new RuntimeException("unexpected status" + result);
            }
        }


        public static OperationStats start() {
            return new OperationStats(0, 0, 0);
        }
    }
}
```

转账单元测试:

```java
package com.nullnull.demo;

import com.nullnull.demo.reporitory.WalletRepository;
import com.nullnull.demo.service.TransactionalWalletService;
import lombok.extern.slf4j.Slf4j;
import org.junit.Assert;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.data.mongodb.core.ReactiveMongoTemplate;
import reactor.util.function.Tuple2;


@Slf4j
@DataMongoTest
public class TestTransactionWalletService extends TestBaseWalletService {


    @Test
    @DisplayName("Reactive transaction for data transfer")
    public void testReactiveTransactionApproach(@Autowired WalletRepository walletRepository,
                                                @Autowired ReactiveMongoTemplate mongoTemplate) {
        //1, 创建事务对象
        TransactionalWalletService walletService = new TransactionalWalletService(walletRepository, mongoTemplate);
        Tuple2<Long, Long> expectedActual = simulateOperations(walletService);

        //事务执行完成后，两个账户余额应该相同
        Assert.assertEquals(expectedActual.getT1(), expectedActual.getT2());
    }

}
```

日志输出:

```tex
2024-12-14 14:35:39.401  INFO 25120 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@724b939e from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37018] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:1, serverValue:144}] to node16:37018
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:6, serverValue:1781}] to node16:37017
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37019] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:3, serverValue:118}] to node16:37019
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37019] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:2, serverValue:119}] to node16:37019
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37017, type=REPLICA_SET_PRIMARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=44262300, setName='nullnullCluster', canonicalAddress=node16:37017, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=7fffffff0000000000000001, setVersion=1, topologyVersion=null, lastWriteDate=Sat Dec 14 14:35:36 CST 2024, lastUpdateTimeNanos=20827615654600}
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37018] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37018, type=REPLICA_SET_SECONDARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=44279100, setName='nullnullCluster', canonicalAddress=node16:37018, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=null, setVersion=1, topologyVersion=null, lastWriteDate=Sat Dec 14 14:35:36 CST 2024, lastUpdateTimeNanos=20827615778800}
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:4, serverValue:1782}] to node16:37017
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37018] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:5, serverValue:143}] to node16:37018
2024-12-14 14:35:39.855  INFO 25120 --- ['}-node16:37019] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37019, type=REPLICA_SET_SECONDARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=44192200, setName='nullnullCluster', canonicalAddress=node16:37019, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=null, setVersion=1, topologyVersion=null, lastWriteDate=Sat Dec 14 14:35:36 CST 2024, lastUpdateTimeNanos=20827615654800}
2024-12-14 14:35:39.856  INFO 25120 --- ['}-node16:37019] org.mongodb.driver.cluster               : Discovered cluster type of REPLICA_SET
2024-12-14 14:35:39.857  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.cluster               : Setting max election id to 7fffffff0000000000000001 from replica set primary node16:37017
2024-12-14 14:35:39.857  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.cluster               : Setting max set version to 1 from replica set primary node16:37017
2024-12-14 14:35:39.857  INFO 25120 --- ['}-node16:37017] org.mongodb.driver.cluster               : Discovered replica set primary node16:37017
2024-12-14 14:35:39.875  INFO 25120 --- [ntLoopGroup-2-7] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:7, serverValue:1783}] to node16:37017
2024-12-14 14:35:39.929  INFO 25120 --- [ntLoopGroup-2-7] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00001
2024-12-14 14:35:39.931  INFO 25120 --- [ntLoopGroup-2-8] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:8, serverValue:1784}] to node16:37017
2024-12-14 14:35:39.932  INFO 25120 --- [ntLoopGroup-2-7] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00003
2024-12-14 14:35:39.933  INFO 25120 --- [ntLoopGroup-2-8] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00002
2024-12-14 14:35:39.934  INFO 25120 --- [tLoopGroup-2-10] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:10, serverValue:1786}] to node16:37017
2024-12-14 14:35:39.934  INFO 25120 --- [ntLoopGroup-2-9] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:9, serverValue:1785}] to node16:37017
2024-12-14 14:35:39.934  INFO 25120 --- [ntLoopGroup-2-7] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00007
2024-12-14 14:35:39.934  INFO 25120 --- [tLoopGroup-2-11] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:11, serverValue:1787}] to node16:37017
2024-12-14 14:35:39.936  INFO 25120 --- [tLoopGroup-2-10] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00005
2024-12-14 14:35:39.936  INFO 25120 --- [tLoopGroup-2-10] com.nullnull.demo.TestBaseWalletService  : create wallet for : client-00004
......
2024-12-14 14:35:40.996  INFO 25120 --- [tLoopGroup-2-18] c.n.d.s.TransactionalWalletService       : transaction result: SUCCESS took: PT0.086S
2024-12-14 14:35:40.996  INFO 25120 --- [tLoopGroup-2-32] c.n.d.s.TransactionalWalletService       : transaction result: SUCCESS took: PT0.086S
2024-12-14 14:35:41.225  INFO 25120 --- [tLoopGroup-2-16] c.n.d.s.TransactionalWalletService       : transaction result: SUCCESS took: PT0.319S
2024-12-14 14:35:41.225  INFO 25120 --- [           main] com.nullnull.demo.TestBaseWalletService  : -------result--------------------------------------------
2024-12-14 14:35:41.262  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00001:    1469$ (d:    1 | w:     0)
2024-12-14 14:35:41.263  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00002:    1000$ (d:    0 | w:     0)
2024-12-14 14:35:41.263  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00003:     801$ (d:    1 | w:     1)
2024-12-14 14:35:41.263  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00004:    1392$ (d:    1 | w:     0)
......
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00493:     226$ (d:    1 | w:     2)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00494:    1547$ (d:    1 | w:     1)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00495:    1326$ (d:    2 | w:     2)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00496:     771$ (d:    0 | w:     1)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00497:    1238$ (d:    2 | w:     2)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00498:      90$ (d:    0 | w:     3)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00499:     743$ (d:    1 | w:     1)
2024-12-14 14:35:41.272  INFO 25120 --- [tLoopGroup-2-16] c.n.demo.service.BaseWalletService       : client-00500:    1260$ (d:    3 | w:     3)
2024-12-14 14:35:41.272  INFO 25120 --- [           main] com.nullnull.demo.TestBaseWalletService  : Expected/actual total balance : 500000 $/ 500$ | Took : PT1.034S
2024-12-14 14:35:41.272  INFO 25120 --- [           main] com.nullnull.demo.TestBaseWalletService  : WalletService.Statistics(totalAccounts=500, totalBalance=500000, totalDeposits=601, totalWithdraws=601)
2024-12-14 14:35:41.272  INFO 25120 --- [           main] com.nullnull.demo.TestBaseWalletService  : TestBaseWalletService.OperationStats(successFul=601, notEnoughFounds=166, conflict=233)
2024-12-14 14:35:41.272  INFO 25120 --- [           main] com.nullnull.demo.TestBaseWalletService  : Clean up database

```

基于事务引用正确的会话可以通过使用 Reactor 上下文实现。

ReactiveMongoTemplate.inTransaction 方法启动一个新事务并将其放入上下文中。

因此，在响应流中的任何位置都可以获得用 com.mongodb.reactivestreams.client.ClientSession  接口表示的事务的会话。

ReactiveMongoContext.getSession()辅助方法可以帮助获取会话实例。

因此，在前面的模拟中，我们进行了 10 00 次转账操作，其中601次成功，399次由于资金不 足而失败。此外，我们的重试策略解决了所有事务冲突，因为没有任何事务以TX_CONFLICT 状态完成。 从日志中可以明显看出，系统保持了总余额不变，即模拟前后系统中的总金额是相同的。因此，我们通 过应用 MongoDB 的响应式事务来实现并发资金转账中的系统完整性。 

现在，对副本集的多文档事务的支持能使用 MongoDB 作为主数据存储来实现全新的应用程序集。 当然，未来版本的 MongoDB 可能支持跨分片部署的事务，并提供各种隔离级别来处理事务。但是，我 们应该注意到，与简单的文档写入相比，多文档事务会产生更高的性能成本和更长的响应延迟。



**基于 SAGA 模式的分布式事务**

分布式事务可以以不同方式实现。当然，对于使用响应式范式实现的持久层，这种说法也成立。但 是，鉴于 Spring Data 仅支持 MongoDB 4 的响应式事务，并且前面提到的事务支持与 Java 事务  API（Java Transaction API，JTA）不兼容，在响应式微服务中实现分布式事务的唯一可行选择是 SAGA  模式。此外，与其他需要分布式事务的可选模式相比，SAGA 模式具有良好的可伸缩性，更适合响应式流。





### 14.3 Spring Data响应式连接器

Spring Data为 4 个 NoSQL 数据库准备了数据库连接器，即 MongoDB、Cassandra、Couchbase  和 Redis。

Spring Data 也可能支持其他数据存储，特别是那些利用 Spring WebFlux WebClient 基于 HTTP 进 行通信的数据存储。



**1. 响应式 MongoDB 连接器**

可以使用 spring-boot-starter-data-mongodb-reactive Spring Boot 启动器模块启用 Spring Data  Reactive MongoDB模块。

响应式 MongoDB 支持提供了一个响应式存储库和 ReactiveMongoRepository 接口定义基本存 储库契约。

存储库继承了 ReactiveCrudRepository 的所有功能，并添加了对 QBE的支持。

MongoDB 存储库支持使用@Query 注解的自定义查询以及带有@Meta 注解的其他查询配置。

如果 MongoDB 存储库遵循命名约定，则它支持从方法名称生成查询。

MongoDB 存储库的另一个显著特性是支持尾游标（tailable cursor）。

默认情况下，数据库会在消费了所有结果时自动关闭查询游标。

但是，MongoDB 有固定集合（capped collections），这些集合大小固定，支持高吞吐量操作。文 档检索基于插入顺序。固定集合的工作方式与循环缓冲区类似。

固定集合也支持一个尾游标。客户端消费初始查询的所有结果后，此光标保持打开状态，当有人将 新文档插入到固定集合中时，尾游标将返回新文档。

在 ReactiveMongoRepository 中，由 @Tailable 注解标记的方法会返回由 Flux 类型 表示的尾游标。

ReactiveMongoOperations 接口和它的实现类 ReactiveMongoTemplate 级别更低，可以更精细 地访问 MongoDB 通信。

除此之外，ReactiveMongoTemplate 还支持 MongoDB 的多文档事务。此功能仅适用于  WiredTiger 存储引擎的非分片副本集。

响应式 Spring Data MongoDB 模块构建于响应式流 MongoDB 驱动程序之上，后者实现了响应式 规范并在内部使用 Project Reactor。

MongoDB 响应式流 Java 驱动程序基于 MongoDB异步 Java 驱动程序构建。



**2. 响应式 Redis 连接器**

Spring Data Reactive Redis 模块可以通过导入 spring-boot-starter-data-redis-reactive启动器来 启用。

Redis 连接器不提供响应式存储库。

ReactiveRedisTemplate 类成为响应式 Redis 数据访问的核心抽象。

ReactiveRedisTemplate 实现 ReactiveRedisOperations 接口，并提供所有必需的序列化/反序列化 过程。

ReactiveRedisConnection 能在与 Redis 通信时使用原始字节缓冲区。

ReactiveRedisTemplate 还能订阅 Pub-Sub通道。例如，convertAndSend(String destination, V  message)方法将给定消息发布到给定通道，并返回接收消息的客户端数。

listenToChannel(String...channels)方法返回一个 Flux，其中包含来自感兴趣通道的消息。

因此，响应式 Redis 连接器不仅可以实现响应式数据存储，还可以提供消息传递机制。

Spring Data Redis 目前集成了 Lettuce 驱动程序。它是 Redis 唯一的响应式 Java 连接器。

Lettuce 4.x 版本使用 RxJava 进行底层实现。但是，该库的 5.x 分支切换到了 Project Reactor。

除 Couchbase 外的所有响应式连接器都具有响应式健康指标。因此，数据库运行状况检查也不应 浪费任何服务器资源。



### 14.4 响应式关系型数据库连接

响应式关系型数据库连接（Reactive Relational Database Connectivity，R2DBC）是一项探索完 全响应式数据库 API 的倡议。

Spring Data 团队领导 R2DBC 倡议，并使用它在响应式应用程序内的响应式数据访问环境中探测和 验证想法。

R2DBC 在 Spring OnePlatform 2018 会议上被公开，其目标是定义具有背压支持的响应式数据库 访问 API。Spring Data 团队在响应式 NoSQL 持久化方面获得了一些先进经验，因此决定提出对真正响 应式语言级数据访问 API的愿景。

R2DBC 项目包括以下部分。

- R2DBC 服务提供程序接口（Service Provider Interface，SPI）定义了实现驱动程序的简约  API，便于彻底减少驱动程序实现者必须遵守的 API。SPI 不适合在应用程序代码中直接使用， 需要专用的客户端库。
- R2DBC 客户端提供了人性化的 API 和帮助类，可将用户请求转换为 SPI 级别。R2DBC 客户端 对R2DBC SPI 的作用与 Jdbi 库对 JDBC 的作用相同。
- R2DBC PostgreSQL 实现为 PostgreSQL 提供了 R2DBC 驱动程序。使用 Netty 框架通过  PostgreSQL 连接协议进行异步通信。背压既可以通过 TCP 流控制，也可以通过被称为门户 （portal）的 PostgreSQL 特性来实现，后者实际上是一个查询内的光标。门户能完美地转换 为响应式流。

并非所有关系型数据库都具有正确背压传播所需的连接协议功能。但 TCP 流控制在所有情况 下都可用。

**基于 Spring Data R2DBC 使用 R2DBC**

Spring Data JDBC 模块中提供了基于R2DBC的 ReactiveCrudRepository 接口。

SimpleR2dbcRepository 类使用R2DBC 实现 ReactiveCrudRepository 接口。

SimpleR2dbcRepository 类不使用默认的 R2DBC 客户端，而是定义自己的客户端以使用 R2DBC  SPI。  背压问题在 R2DBC SPI 级别得到了解决。



**使用R2DBC操作PostgreSQL案例：**



使用docker安装postgresql13

```sh
docker run -d --name pgsql-13 \
 --network bridge \
 --restart always \
 -p 5432:5432 \
 -e POSTGRESQL_USERNAME=nullnull \
 -e POSTGRESQL_PASSWORD=123456 \
 -v /data/pgsql:/var/lib/postgresql/data:z \
bitnami/postgresql:13.1.0

# 如果需要移除重装可使用：docker stop pgsql-13 && docker rm pgsql-13

# 开放端口
firewall-cmd --permanent --zone=public --add-port=5432/tcp
firewall-cmd --reload
```

如果使用rpm包安装可参考

```sh
# 安装postgre的共享库
sudo rpm -ivh postgresql13-libs-13.1-1PGDG.rhel7.x86_64.rpm
# 安装依赖
sudo yum install libicu -y
# 安装postgre客户端
sudo rpm -ivh postgresql13-13.1-1PGDG.rhel7.x86_64.rpm
# 安装postgre的服务端
sudo rpm -ivh postgresql13-server-13.1-1PGDG.rhel7.x86_64.rpm
# 修改postgres用户的密码
# 指定postgres的数据目录
# 在postgres家目录创建data目录
-bash-4.2$ mkdir data
# /var/lib/pgsql/data
# pg用户操作：初始化数据库
bash-4.2$ /usr/pgsql-13/bin/initdb -D /var/lib/pgsql/data
-bash-4.2$ vim /var/lib/pgsql/data/postgresql.conf
# 添加内容：listen_addresses='*'
-bash-4.2$ vim /var/lib/pgsql/data/pg_hba.conf
# 添加内容：host all postgres 192.168.100.1/32 trust
# 启动postgresql
bash-4.2$ /usr/pgsql-13/bin/pg_ctl -D /var/lib/pgsql/data -l logfile start
# 登录数据库
bash-4.2$ /usr/pgsql-13/bin/psql
psql (13.1)
Type "help" for help.
# 退出数据库登录
postgres=# \q
# 停止postgresql
bash-4.2$ /usr/pgsql-13/bin/pg_ctl stop -m fast -D /var/lib/pgsql/data
```



使用spring data r2dbc执行插入的时候，如果设置了主键，则认为该数据存在，需要执行的是更 新。

如果没有设置主键，则需要使用自增主键，此时插入数据的时候不设置主键值，系统认为是数据的 插入。

```sql
-- drop table  computer;

CREATE TABLE computer
(
id SERIAL primary key ,
name varchar(64),
money int,
make_year int
);


-- 自动创建名为users_id_seq的序列，且MAXVALUE=9223372036854775807
-- 先创建序列，然后设置字段的自增
CREATE SEQUENCE users_id_seq
START WITH 1
INCREMENT BY 1
NO MINVALUE
NO MAXVALUE
CACHE 1;
 
alter table computer alter column id set default nextval('users_id_seq');
```



PostgreSQL字段名称一定不要使用大写字母！

maven引入

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-14-4-postgres</artifactId>
    <packaging>jar</packaging>

    <name>webflux-14-4-postgres</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-r2dbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>io.r2dbc</groupId>
            <artifactId>r2dbc-postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

```



实体信息

```java
package com.nullnull.demo.entity;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

/**
 * 电脑信息
 *
 * @author nullnull
 * @since 2024/12/14
 */
@Table("computer")
@Data
public class Computer {

  /**
   * @Id 仅针对自增长序列
   */
  @Id private Integer id;

  @Column("name")
  private String name;

  @Column("money")
  private Integer money;

  /** 制造年份 */
  @Column("make_year")
  private Integer makeYear;

  public Computer(String name, Integer money, Integer makeYear) {
    this.name = name;
    this.money = money;
    this.makeYear = makeYear;
  }

  public Computer() {
    this(null, null, null);
  }
}

```



存储接口

```java
package com.nullnull.demo.reposiroty;

import com.nullnull.demo.entity.Computer;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

/**
 * 电脑的存储类
 *
 * @author nullnull
 * @since 2024/12/14
 */
public interface ComputerRepository extends ReactiveCrudRepository<Computer, Integer> {

  /**
   * 查找最新制造的电脑
   *
   * @return
   */
  @Query("select * from computer where make_year = (select max(make_year) from computer)")
  Flux<Computer> findNewComputer();
}

```

存储的事务实现

```java
package com.nullnull.demo.reposiroty;

import java.util.UUID;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;


@Repository
public class TransferComputerRepository {

  private final DatabaseClient client;

  public TransferComputerRepository(DatabaseClient client) {
    this.client = client;
  }

  public Mono<Void> insertRows() {
    String uuid = UUID.randomUUID().toString();

    int i = 0;

    StringBuilder value = new StringBuilder();
    value.append("values(");
    value.append("'联想-1'").append(",");
    value.append("8500").append(",");
    value.append("2023");
    value.append(")");

    uuid = UUID.randomUUID().toString();
    StringBuilder value2 = new StringBuilder();
    value2.append("values(");
    value2.append("'HP-1'").append(",");
    value2.append("5600").append(",");
    value2.append("2022");
    value2.append(")");

    return client
        .sql("insert into computer (name,money,make_year) " + value.toString())
        .fetch()
        .rowsUpdated()
        .doOnNext(
            item -> {
              int a = 10 / i;
            })
        .then(client.sql("insert into computer (name,money,make_year) " + value2.toString()).then())
        .then();
  }
}

```

服务接口

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Computer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;


public interface ComputerService {

  Mono<Computer> saveComputer(Computer computer);

  Flux<Computer> findComputerAll();
}

```

服务实现

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Computer;
import com.nullnull.demo.reposiroty.ComputerRepository;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class ComputerServiceImpl  implements ComputerService {

    private final ComputerRepository repository;

    public ComputerServiceImpl(ComputerRepository repository) {
        this.repository = repository;
    }

    @Override
    public Mono<Computer> saveComputer(Computer computer) {
        Mono<Computer> save = repository.save(computer);
        int i = 1 / 0;
        return save;
    }

    @Override
    public Flux<Computer> findComputerAll() {
        return repository.findAll();
    }
}

```



启动入口程序:

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }
}
```



配制文件:

```yaml
spring:
  r2dbc:
   username: nullnull
   password: 123456
   url: r2dbc:postgres://192.168.5.16:5432/nullnull
```

单元测试

```java
package com.nullnull.demo.service;

import com.nullnull.demo.entity.Computer;
import com.nullnull.demo.reposiroty.ComputerRepository;
import com.nullnull.demo.reposiroty.TransferComputerRepository;
import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;

/**
 * 测试服务
 *
 * @author nullnull
 * @since 2024/12/15
 */
@SpringBootTest
public class TestComputerServiceImpl {

  @Test
  public void testSave(@Autowired ComputerRepository repository) throws InterruptedException {
    Assert.assertNotNull(repository);
    CountDownLatch latch = new CountDownLatch(1);

    Mono<Computer> thinkStation = repository.save(new Computer("thinkstation", 18000, 1994));
    thinkStation.subscribe(
        item -> System.out.println("onnext:" + item),
        ex -> {
          ex.printStackTrace();
          System.err.println("error:" + ex);
          latch.countDown();
        },
        () -> {
          System.out.println("finish");
          latch.countDown();
        });

    latch.await();
  }

  @Test
  public void testFindLastComputer(@Autowired ComputerRepository repository)
      throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);

    Flux<Computer> newComputer = repository.findNewComputer();
    newComputer.subscribe(
        item -> {
          System.out.println("newComputer" + item);
          latch.countDown();
        });
    latch.await();
  }

  @Test
  public void testInsertComputer(@Autowired ComputerRepository repository)
      throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);

    Mono<Computer> thinkStation = repository.save(new Computer("联想", 5000, 2014));
    thinkStation.subscribe(
        item -> System.out.println("onnext:" + item),
        ex -> {
          System.err.println("error:" + ex);
          latch.countDown();
        },
        () -> {
          System.out.println("finish");
          latch.countDown();
        });

    latch.await();
  }

  @Test
  public void testFindAll(@Autowired ComputerRepository repository) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);

    Flux<Computer> newComputer = repository.findAll();
    newComputer.subscribe(
        item -> {
          System.out.println("findAll" + item);
          latch.countDown();
        });
    latch.await();
  }

  @Test
  public void testServerSave(@Autowired ComputerService computerService)
      throws InterruptedException {
    computerService.saveComputer(new Computer("戴尔", 15000, 2013)).block(Duration.ofSeconds(5));
  }

  @Test
  public void testServiceFindAll(@Autowired ComputerService computerService)
      throws InterruptedException {
    computerService.findComputerAll().subscribe(System.out::println);
    Thread.sleep(5000);
  }

  @Test
  public void testTransferInsert(@Autowired TransferComputerRepository computerRepository)
      throws InterruptedException {
    computerRepository.insertRows().subscribe(System.out::println);
    Thread.sleep(5000);
  }
}
```

输出：

```properties
# 运行testSave方法
onnext:Computer(id=1, name=thinkstation, money=18000, makeYear=1994)
finish

# 调用查询方法testFindLastComputer
newComputerComputer(id=1, name=thinkstation, money=18000, makeYear=1994)


# 再次调用插入方法testInsertComputer
onnext:Computer(id=2, name=联想, money=5000, makeYear=2014)
finish

#调用查询方法testFindAll
findAllComputer(id=1, name=thinkstation, money=18000, makeYear=1994)
findAllComputer(id=2, name=联想, money=5000, makeYear=2014)


# 再调用服务的保存方法testServerSave
java.lang.ArithmeticException: / by zero

	at com.nullnull.demo.service.ComputerServiceImpl.saveComputer(ComputerServiceImpl.java:30)
	at com.nullnull.demo.service.TestComputerServiceImpl.testServerSave(TestComputerServiceImpl.java:97)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
......
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
	
# 调用服务的查询方法：testServiceFindAll，可以发现插入失败，事务回滚未插入新数据
Computer(id=1, name=thinkstation, money=18000, makeYear=1994)
Computer(id=2, name=联想, money=5000, makeYear=2014)

# 测试事务： testTransferInsert 插入失败，数据回滚
2024-12-16 22:26:45.937 ERROR 29380 --- [actor-tcp-nio-1] reactor.core.publisher.Operators         : Operator called default onErrorDropped

reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.ArithmeticException: / by zero
Caused by: java.lang.ArithmeticException: / by zero
	at com.nullnull.demo.reposiroty.TransferComputerRepository.lambda$insertRows$0(TransferComputerRepository.java:49) ~[classes/:na]
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:184) [reactor-core-3.4.0.jar:3.4.0]
	

```





### 14.5 Spring Data R2DBC集成MYSQL

使用docker启动mysql

```sh
docker run -d -p 3306:3306 \
--name mysql --privileged=true \
-v /data/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
mysql:8.4.3

```

创建脚本

```sql
CREATE DATABASE `spring_r2dbc`;

use spring_r2dbc;

CREATE TABLE `student` (
  `id` int(11) COMMENT '编号',
  `code` varchar(50) NOT NULL COMMENT '学号',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `gender` char(1) NOT NULL COMMENT '姓名:M男，F女',
  `birthday` date NOT NULL COMMENT '生日',
  `address` varchar(300) NULL COMMENT '家庭住址',
  `remark` varchar(1000) NULL COMMENT '备注',
  `active` tinyint NOT NULL DEFAULT 1 COMMENT '有效标识，默认为1',
  `createdAt` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `createdBy` varchar(50) NOT NULL COMMENT '创建人',
  `updatedAt` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  `updatedBy` varchar(50) NOT NULL COMMENT '更新人',
  PRIMARY KEY (`id`) ,
  UNIQUE INDEX `idx_main`(`code`)
);



insert into student(id,code, name, gender, birthday, address, createdBy,updatedBy)
values
  (1,'S0001', 'Tom', 'M', '2001-03-05', null, 'TEST', 'TEST'),
  (2,'S0002', 'Ted', 'M', '2001-06-12', null, 'TEST', 'TEST'),
  (3,'S0003', 'Mary', 'F', '2001--9-12', 'Chicago', 'TEST', 'TEST')
;

```



实体类：

```java
package org.nullnull.demo.entity;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.ReadOnlyProperty;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
public class Student {
  @Id
  private Long id;
  private String code;
  private String name;
  private String gender;
  private LocalDate birthday;
  private String address;
  private String remark;
  private boolean active;
  @ReadOnlyProperty
  private LocalDateTime createdAt;
  private String createdBy;
  @ReadOnlyProperty
  private LocalDateTime updatedAt;
  private String updatedBy;
}

```



存储层的接口：

```java
package org.nullnull.demo.reposity;

import org.nullnull.demo.entity.Student;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

public interface StudentRepository extends ReactiveCrudRepository<Student,Long> {

}

```

controller:

```java
package org.nullnull.demo.controller;

import org.nullnull.demo.entity.Student;
import org.nullnull.demo.reposity.StudentRepository;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;


@RestController
@RequestMapping("/api/students")
public class StudentController {

  private final StudentRepository studentRepository;

  public StudentController(StudentRepository studentRepository) {
    this.studentRepository = studentRepository;
  }

  @GetMapping
  public Flux<Student> findAll() {
    return studentRepository.findAll();
  }
}

```

启动入口 

```java
package org.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

}

```



配制文件：

```yaml
spring:
  r2dbc:
   url: r2dbc:mysql://192.168.5.16:3306/spring_r2dbc
   username: root
   password: 123456
```



启动浏览器访问：

http://127.0.0.1:8080/api/students

如果一切正常将得到：

```json
[
	{
		"id": 1,
		"code": "S0001",
		"name": "Tom",
		"gender": "M",
		"birthday": "2001-03-05",
		"address": null,
		"remark": null,
		"active": true,
		"createdAt": null,
		"createdBy": null,
		"updatedAt": null,
		"updatedBy": null
	},
	{
		"id": 2,
		"code": "S0002",
		"name": "Ted",
		"gender": "M",
		"birthday": "2001-06-12",
		"address": null,
		"remark": null,
		"active": true,
		"createdAt": null,
		"createdBy": null,
		"updatedAt": null,
		"updatedBy": null
	},
	{
		"id": 3,
		"code": "S0003",
		"name": "Mary",
		"gender": "F",
		"birthday": "2001-09-12",
		"address": "Chicago",
		"remark": null,
		"active": true,
		"createdAt": null,
		"createdBy": null,
		"updatedAt": null,
		"updatedBy": null
	}
]
```



### 14.6 SpringWebFlux 集成MongoDB

从Spring Framework 5.2 M2开始，Spring通过 ReactiveTransactionManager SPI 支持响应式 事务管理。

ReactiveTransactionManager 是使用事务资源的响应式和非阻塞集成的事务管理抽象。它是一 个会返回 Publisher 的响应式 @Transactional 方法元注解，使用 TransactionalOperator 实现可 编程的事务管理。



两个响应式事务管理器实现是： 

R2DBC通过Spring Data R2DBC

MongoDB通过Spring Data MongoDB



启动mongoDB

```sh
mongod -f mongo_37017.conf
mongod -f mongo_37018.conf
mongod -f mongo_37019.conf
```

maven坐标：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-14-6-mongodb2</artifactId>
    <packaging>jar</packaging>

    <name>webflux-14-6-mongodb2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>

```

实体类:

```java
package com.nullnull.demo.entity;

import lombok.Data;
import lombok.NoArgsConstructor;
import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.util.Arrays;
import java.util.List;


@Document(collection = "book")
@Data
@NoArgsConstructor
public class Book {
    @Id
    private ObjectId id;

    @Indexed
    private String title;

    @Field("pubYear")
    private int publishingYear;

    @Indexed
    private List<String> authors;


    public Book(String title, int publishingYear, String... authors) {
        this.title = title;
        this.publishingYear = publishingYear;
        this.authors = Arrays.asList(authors);
    }
}
```

存储接口:

```java
package com.nullnull.demo.repository;

import com.nullnull.demo.entity.Book;
import org.bson.types.ObjectId;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;


@Repository
public interface BookSpringDataMongoRepository extends ReactiveMongoRepository<Book, ObjectId> {

    Flux<Book> findByAuthorsOrderByPublishingYearDesc(String... authors);

    @Query("{'authors.1': { $exists: true }}")
    Flux<Book> booksWithFewAuthors();
}

```



启动入口 :

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

}

```

配制文件:

```yaml
spring:
  data:
    mongodb:
      uri: "mongodb://node16:37017,node16:37018,node16:37019/test-db"

logging:
  level:
    reactor.core.publisher.FluxUsingWhen: ERROR
#  org.springframework.data.mongodb.core.ReactiveMongoTemplate: DEBUG
```

注意需要配制host

单元测试：

```java
package com.nullnull.demo;


import com.nullnull.demo.entity.Book;
import com.nullnull.demo.repository.BookSpringDataMongoRepository;
import org.bson.types.ObjectId;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import reactor.core.publisher.Flux;

import java.util.concurrent.CountDownLatch;



@SpringBootTest
public class WebFluxApplicationTests {

    private static final Logger log = LoggerFactory.getLogger(WebFluxApplicationTests.class);

    @Test
    public void contextLoader(@Autowired BookSpringDataMongoRepository bookRepo) {
        bookRepo.saveAll(Flux.just(
                new Book("java编程思想", 2011, "不记得了"),
                new Book("java并发编程", 2012, "也不记得"),
                new Book("代码整洁之道", 2012, "bob"),
                new Book("代码整洁之道：程序员的职业素养", 2011, "bob"),
                new Book("UML：Java程序员指南", 2013, "bob")
        )).blockLast();

        log.info("books save in db");

        //打印保存的停下
        bookRepo.findAll()
                .doOnNext(book -> System.out.println(book))
                .blockLast();

        System.out.println("----------------------------------");
        System.out.println();

        bookRepo.findByAuthorsOrderByPublishingYearDesc("bob")
                .doOnNext(book -> System.out.println(book))
                .blockLast();
        System.out.println("----------------------------------");
        System.out.println();

        bookRepo.booksWithFewAuthors()
                .doOnNext(System.out::println)
                .blockLast();
        System.out.println("application finish successfully!");
    }

    public String toString(Iterable<Book> books) {
        StringBuilder sb = new StringBuilder();

        books.iterator().forEachRemaining(b ->
                sb.append(" - ").append(b.toString()).append("\n")
        );

        return sb.toString();
    }

    @Test
    public void testInsert(@Autowired ReactiveMongoRepository template) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Book book = new Book("敏捷软件开发：原则、模式和实践", 2011, "bob");
        template.insert(book)
                .doOnNext(book1 -> System.out.println(book1))
                .flatMap(book1 -> template.findById(book.getId()))
                .doOnNext(book1 -> System.out.println("找到:" + book1))
                .doOnTerminate(() -> latch.countDown())
                .subscribe();

        latch.await();
    }

    @Test
    public void testDelete(@Autowired ReactiveMongoRepository repository) throws InterruptedException {
        ObjectId id = new ObjectId("676171cae4985b230996cc3e");
        repository.findById(id)
                .doOnNext(book -> System.out.println("删除之前:" + book))
                .then(repository.deleteById(id))
                .map(book -> repository.findById(id))
                .doOnNext(book -> System.out.println("删除之后:" + book))
                .doOnTerminate(() -> System.out.println("运行结束"))
                .block();
    }
}

```

一个方法以一个方法的运行
contextLoader方法的输出：

```java
2024-12-17 20:43:47.621  INFO 36416 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@b791a81 from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-17 20:43:47.622  INFO 36416 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@71e7adbb from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-17 20:43:47.623  INFO 36416 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@7c40ffef from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-17 20:43:47.623  INFO 36416 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@286855ea from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-17 20:43:47.624  INFO 36416 --- [           main] org.mongodb.driver.cluster               : No server chosen by com.mongodb.internal.async.client.ClientSessionHelper$1@64aeaf29 from cluster description ClusterDescription{type=UNKNOWN, connectionMode=MULTIPLE, serverDescriptions=[ServerDescription{address=node16:37019, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37018, type=UNKNOWN, state=CONNECTING}, ServerDescription{address=node16:37017, type=UNKNOWN, state=CONNECTING}]}. Waiting for 30000 ms before timing out
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37019] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:3, serverValue:51}] to node16:37019
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37018] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:6, serverValue:45}] to node16:37018
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37019] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:4, serverValue:50}] to node16:37019
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:2, serverValue:107}] to node16:37017
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:5, serverValue:106}] to node16:37017
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37018] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:1, serverValue:44}] to node16:37018
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37018] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37018, type=REPLICA_SET_SECONDARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=47553200, setName='nullnullCluster', canonicalAddress=node16:37018, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=null, setVersion=1, topologyVersion=null, lastWriteDate=Tue Dec 17 20:43:44 CST 2024, lastUpdateTimeNanos=42925857101800}
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37017, type=REPLICA_SET_PRIMARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=47550100, setName='nullnullCluster', canonicalAddress=node16:37017, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=7fffffff0000000000000002, setVersion=1, topologyVersion=null, lastWriteDate=Tue Dec 17 20:43:44 CST 2024, lastUpdateTimeNanos=42925857214500}
2024-12-17 20:43:48.663  INFO 36416 --- ['}-node16:37019] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=node16:37019, type=REPLICA_SET_SECONDARY, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=47575700, setName='nullnullCluster', canonicalAddress=node16:37019, hosts=[node16:37017, node16:37018, node16:37019], passives=[], arbiters=[], primary='node16:37017', tagSet=TagSet{[]}, electionId=null, setVersion=1, topologyVersion=null, lastWriteDate=Tue Dec 17 20:43:44 CST 2024, lastUpdateTimeNanos=42925857101700}
2024-12-17 20:43:48.664  INFO 36416 --- ['}-node16:37019] org.mongodb.driver.cluster               : Discovered cluster type of REPLICA_SET
2024-12-17 20:43:48.664  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.cluster               : Setting max election id to 7fffffff0000000000000002 from replica set primary node16:37017
2024-12-17 20:43:48.664  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.cluster               : Setting max set version to 1 from replica set primary node16:37017
2024-12-17 20:43:48.664  INFO 36416 --- ['}-node16:37017] org.mongodb.driver.cluster               : Discovered replica set primary node16:37017
2024-12-17 20:43:48.684  INFO 36416 --- [ntLoopGroup-2-8] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:8, serverValue:109}] to node16:37017
2024-12-17 20:43:48.684  INFO 36416 --- [ntLoopGroup-2-7] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:7, serverValue:108}] to node16:37017
2024-12-17 20:43:48.684  INFO 36416 --- [tLoopGroup-2-10] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:10, serverValue:110}] to node16:37017
2024-12-17 20:43:48.684  INFO 36416 --- [tLoopGroup-2-11] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:11, serverValue:111}] to node16:37017
2024-12-17 20:43:48.684  INFO 36416 --- [ntLoopGroup-2-9] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:9, serverValue:112}] to node16:37017
2024-12-17 20:43:48.708  INFO 36416 --- [           main] c.nullnull.demo.WebFluxApplicationTests  : books save in db
Book(id=67616f805e991641fe69bd42, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67616f805e991641fe69bd3e, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=67616f805e991641fe69bd3f, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=67616f805e991641fe69bd41, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67616f805e991641fe69bd40, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67616fdd819eb22b00f745e2, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67616fdd819eb22b00f745df, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=67616fdd819eb22b00f745e3, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67616fdd819eb22b00f745e1, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67616fdd819eb22b00f745e0, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=67617119d0a60630ebc62dba, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67617119d0a60630ebc62dbb, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67617119d0a60630ebc62db8, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=67617119d0a60630ebc62dbc, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67617119d0a60630ebc62db9, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=676171a09d3b5c1ac195d743, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171a09d3b5c1ac195d744, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=676171a09d3b5c1ac195d742, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=676171a09d3b5c1ac195d741, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=676171a09d3b5c1ac195d745, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171ab01423436aab76689, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171ab01423436aab76687, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=676171ab01423436aab76688, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=676171ab01423436aab7668b, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171ab01423436aab7668a, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=676171ac01423436aab7668c, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
Book(id=676171cae4985b230996cc3f, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171cae4985b230996cc3b, title=java编程思想, publishingYear=2011, authors=[不记得了])
Book(id=676171cae4985b230996cc3c, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=676171cae4985b230996cc3d, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171cce4985b230996cc40, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
Book(id=67617203b955f013da99d0a4, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67617203b955f013da99d0a1, title=java并发编程, publishingYear=2012, authors=[也不记得])
Book(id=67617203b955f013da99d0a2, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67617203b955f013da99d0a3, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67617203b955f013da99d0a0, title=java编程思想, publishingYear=2011, authors=[不记得了])
----------------------------------

Book(id=67616f805e991641fe69bd42, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67616fdd819eb22b00f745e3, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67617119d0a60630ebc62dbc, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171a09d3b5c1ac195d745, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171ab01423436aab7668b, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=676171cae4985b230996cc3f, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67617203b955f013da99d0a4, title=UML：Java程序员指南, publishingYear=2013, authors=[bob])
Book(id=67616f805e991641fe69bd40, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67616fdd819eb22b00f745e1, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67617119d0a60630ebc62dba, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171a09d3b5c1ac195d743, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171ab01423436aab76689, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=676171cae4985b230996cc3d, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67617203b955f013da99d0a2, title=代码整洁之道, publishingYear=2012, authors=[bob])
Book(id=67616f805e991641fe69bd41, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67616fdd819eb22b00f745e2, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=67617119d0a60630ebc62dbb, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=676171a09d3b5c1ac195d744, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=676171ab01423436aab7668a, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
Book(id=676171ac01423436aab7668c, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
Book(id=676171cce4985b230996cc40, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
Book(id=67617203b955f013da99d0a3, title=代码整洁之道：程序员的职业素养, publishingYear=2011, authors=[bob])
----------------------------------

application finish successfully!

```



testInsert方法输出：

```java
Book(id=67617204b955f013da99d0a5, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
找到:Book(id=67617204b955f013da99d0a5, title=敏捷软件开发：原则、模式和实践, publishingYear=2011, authors=[bob])
```



testDelete输出：

```tex
删除之前:Book(id=676173b05fe88d21e06a7171, title=代码整洁之道, publishingYear=2012, authors=[bob])
运行结束
```

### 14.7 SpringWebFlux集成Redis

案例

maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.nullnull.demo</groupId>
    <artifactId>webflux-14-7-redis</artifactId>
    <packaging>jar</packaging>

    <name>webflux-14-7-redis</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF8</project.reporting.outputEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

```

配制文件：

application.yml

```yaml
spring:
  redid:
    host: 127.0.0.1
    port: 6379
    timeout: 5000
```

实体对象

```java
package com.nullnull.demo.entity;

import lombok.Data;
import org.springframework.data.annotation.Id;

import java.io.Serializable;

@Data
public class User implements Serializable {

    private static final long serialVersionUID = -1L;

    @Id
    private Long id;

    /**
     * 用户编号
     */
    private String code;

    /**
     * 用户所在的城市
     */
    private String addressCity;

    /**
     * 备注
     */
    private String remark;
}

```



配制类

```java
package com.nullnull.demo.config;

import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

public class RedisConfig extends CachingConfigurerSupport {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        GenericJackson2JsonRedisSerializer jsonRedisSerializer =
                new GenericJackson2JsonRedisSerializer();

        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(factory);
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setValueSerializer(jsonRedisSerializer);

        return redisTemplate;
    }


    @Bean
    public ReactiveRedisTemplate<String, Object> reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
        RedisSerializer serializer = new StringRedisSerializer();
        GenericJackson2JsonRedisSerializer valueSerializer = new GenericJackson2JsonRedisSerializer();

        RedisSerializationContext<String, Object> context =
                RedisSerializationContext.newSerializationContext()
                        .key(serializer)
                        .value(valueSerializer)
                        .hashKey(serializer)
                        .hashValue(valueSerializer)
                        .build();

        ReactiveRedisTemplate<String, Object> reactiveRedisTemplate = new ReactiveRedisTemplate<>(factory,
                context);

        return reactiveRedisTemplate;
    }

}

```

异步操作

```java
package com.nullnull.demo.controller;

import com.nullnull.demo.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/user/reactive")
public class UserReactiveTemplateController {

    /**
     * 使用异步的RedisTemplate来操作
     */
    @Autowired
    private ReactiveRedisTemplate reactiveRedisTemplate;


    /**
     * 前缀信息
     */
    private static final String PREFIX = "user_";

    /**
     * 添加用户
     *
     * @param user
     */
    @PostMapping
    public Mono<User> addUser(@RequestBody User user) {
        return reactiveRedisTemplate.opsForValue().getAndSet(PREFIX + user.getId(), user);
    }

    /**
     * 删除用户
     *
     * @param id
     * @return
     */
    @DeleteMapping(value = "/{id}")
    public Mono<Long> deleteUser(@PathVariable("id") Long id) {
        String key = PREFIX + id;
        return reactiveRedisTemplate.opsForValue().delete(key);
    }

    /**
     * 查询用户
     *
     * @param id
     * @return
     */
    @GetMapping(value = "/{id}")
    public Mono<User> queryById(@PathVariable("id") Long id) {
        String key = PREFIX + id;

        return reactiveRedisTemplate.opsForValue().get(key);
    }


}

```

同步

```java
package com.nullnull.demo.controller;

import com.nullnull.demo.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.concurrent.TimeUnit;

/**
 * 用户操作
 *
 * @author nullnull
 * @since 2024/12/18
 */
@RestController
@RequestMapping("/user/template")
public class UserTemplateController {

    /**
     * 使用同步的RedisTemplate来操作
     */
    @Autowired
    private RedisTemplate redisTemplate;


    /**
     * 前缀信息
     */
    private static final String PREFIX = "user_";

    /**
     * 添加用户
     *
     * @param user
     */
    @PostMapping
    public Mono<User> addUser(@RequestBody User user) {
        redisTemplate.opsForValue().set(PREFIX + user.getId(), user, 120, TimeUnit.SECONDS);
        return Mono.create(monoSink -> monoSink.success(user));
    }

    /**
     * 删除用户
     *
     * @param id
     * @return
     */
    @DeleteMapping(value = "/{id}")
    public Mono<Long> deleteUser(@PathVariable("id") Long id) {
        String key = PREFIX + id;
        Boolean deleteRsp = redisTemplate.delete(key);
        return Mono.create(monoSink ->
                {
                    if (deleteRsp) {
                        monoSink.success(id);
                    } else {
                        monoSink.success(null);
                    }
                }
        );
    }

    /**
     * 查询用户
     *
     * @param id
     * @return
     */
    @GetMapping(value = "/{id}")
    public Mono<User> queryById(@PathVariable("id") Long id) {
        String key = PREFIX + id;
        ValueOperations<String, User> operations = redisTemplate.opsForValue();
        User user = operations.get(key);
        if (null != user) {
            return Mono.create(userMonoSink -> userMonoSink.success(user));
        }
        return Mono.create(userMonoSink -> userMonoSink.success(null));
    }

}

```

启动入口

```java
package com.nullnull.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class WebFluxSprintBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxSprintBootApplication.class, args);
    }

}

```

启动服务，使用Curl命令来验证

同步方式运行的案例

```sh
# 查询，以检查是否存在
curl http://192.168.5.3:8080/user/template/210

# 插入操作
curl -H "Content-Type: application/json" \
    -d '{"id":210,"code": "user-001","addressCity":"shanghai","remark":"remark"}' \
    --request POST http://192.168.5.3:8080/user/template
    
# 查询，以检查插入结果
curl http://192.168.5.3:8080/user/template/210
    
curl -XDELETE http://192.168.5.3:8080/user/template/210

# 查询，以检查删除的结果
curl http://192.168.5.3:8080/user/template/210
```

操作输出：

```sh
[root@standone-os ~]# curl http://192.168.5.3:8080/user/template/210
[root@standone-os ~]# curl -H "Content-Type: application/json" \
>     -d '{"id":210,"code": "user-001","addressCity":"shanghai","remark":"remark"}' \
>     --request POST http://192.168.5.3:8080/user/template
{"id":210,"code":"user-001","addressCity":"shanghai","remark":"remark"}
[root@standone-os ~]# curl http://192.168.5.3:8080/user/template/210
{"id":210,"code":"user-001","addressCity":"shanghai","remark":"remark"}
[root@standone-os ~]# curl -XDELETE http://192.168.5.3:8080/user/template/210
210
[root@standone-os ~]# curl http://192.168.5.3:8080/user/template/210
[root@standone-os ~]# 
```



异步方式运行的案例

```sh
# 查询，以检查是否存在
curl http://192.168.5.3:8080/user/reactive/210

# 插入操作
curl -H "Content-Type: application/json" \
-d '{"id":210,"code": "user-001","addressCity":"shanghai","remark":"remark"}' \
--request POST http://192.168.5.3:8080/user/reactive
    
# 查询，以检查插入结果
curl http://192.168.5.3:8080/user/reactive/210
    
curl -XDELETE http://192.168.5.3:8080/user/reactive/210

# 查询，以检查删除的结果
curl http://192.168.5.3:8080/user/reactive/210
```

输出：

```sh
[root@standone-os ~]# curl http://192.168.5.3:8080/user/reactive/210
[root@standone-os ~]# 
[root@standone-os ~]# curl http://192.168.5.3:8080/user/reactive/210
[root@standone-os ~]# curl -H "Content-Type: application/json" \
> -d '{"id":210,"code": "user-001","addressCity":"shanghai","remark":"remark"}' \
> --request POST http://192.168.5.3:8080/user/reactive

[root@standone-os ~]# curl http://192.168.5.3:8080/user/reactive/210
{"id":210,"code":"user-001","addressCity":"shanghai","remark":"remark"}
[root@standone-os ~]# 
[root@standone-os ~]# curl -XDELETE http://192.168.5.3:8080/user/reactive/210
true
[root@standone-os ~]# 
[root@standone-os ~]# curl http://192.168.5.3:8080/user/reactive/210
[root@standone-os ~]# 
```



### 14.8 使用rxjava2-jdbc库将同步持久化库转换为响应式持久化库

David Moten创建的rxjava2-jdbc库，可以非阻塞、响应式的方式封装 JDBC 驱动。 该库基于 RxJava 2 构建，并使用专用线程池和非阻塞连接池，因此，请求不会在等待连接可用时阻 塞线程。

一旦连接可用，查询就开始在连接上执行并阻塞线程.

该库具有流式 DSL，可以发送 SQL 语句并以响应式流的方式接收结果。

SQL

```sql
create table wallet
(
 id int auto_increment primary key,
 owner varchar(255) not null,
 balance int not null,
 deposits int not null,
 withdraws int not null
);

create table book (
 id varchar(64) primary key,
 title varchar(255) not null,
 publishing_year integer not null
);

insert into book values('98cfd43e-1967-47a1-ace7-8399a29866a0','The Martian', 2011);
insert into book values('99cfd43e-1111-3333-ace7-8399a29866a0','Blue Mars', 1996);
insert into book values('11111111-1967-2343-7777-000000000000','The Case for Mars', 1996);
insert into book values('99999999-1967-47a1-aaaa-8399a29866a0','The War of Worlds', 1897);
insert into book values('99cfd43e-1967-3344-e34a-222222233333','Edison''s Conquest of Mars', 1947);

```











## 结束
