# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241125225402362](.\images\image-20241125225402362.png)

**响应延迟**
