# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241126091852663](.\images\image-20241126091852663.png)



**响应延迟**

传统命令式编程的另一个问题是：当一个服务需要做很多操作而不仅仅是IO请求的时候，响应延迟相应的增大。

如服务A需要调用服务B和服务C，比如查询数据库，聚合结果并返回。意味着服务A的响应时间包括：

- 服务B的响应时间（网络延迟时间+处理时间）
- 服务C的响应时间（网络延迟时间+处理时间）
- 数据请求响应时间（网络延迟时间+处理时间）



![image-20241126091817119](.\images\image-20241126091817119.png)

如果服务调用没有前后依赖关系，则可以并行调用服务，如果使用java的CompletableFuture异步调用并注册回调，开发会复杂很多，而且阅读和维护也会复杂很多。



**压垮客户端**

微服务另外一个问题就是：服务A请求服务B的数据，如果数据量非常的时候，超过了服务A能处理的程度，则会导致服务OOM。



**总结**

这些问题都是响应式编程要解决的。

优势：

- 不用Thread per Request模型，使用少量线程即可处理大量的请求。
- 在执行IO操作时不让线程等待。
- 简化并行调用。
- 支持背压，让客户端告诉服务端它能处理多少负载。

### 1.1.1  消息驱动通信

响应式编程的定义

响应式编程使用异步、事件驱动构建非阻塞式应用的。此类应用仅需少量的线程用于横向扩展。

该定义的关键一点是：借助背压技术，防止生产者压垮消费者。

**怎么做？**

答案就是使用异步数据流编程。

如果服务A需要从服务B获取数据。对于响应式编程，服务A向服务B发起请求，并立即返回（非阻塞异步）。

之后请求的数据以数据流的方式返回给服务A，服务B对每个数据项发布onNext事件，当所有的数据都发布了OnNext事件，就发布OnComplete事件结束，如果发生异常，服务B就发布OnError事件，之后不再发布OnNext事件。

![image-20241126093315691](.\images\image-20241126093315691.png)

响应式编程使用函数式编程风格，用于对数据流进行不同的转换。

流可以作为输入，也可以合并，映射和过滤等。

**响应式系统**

响应式系统的设计目标：

- 响应性（以时序的方式响应）
- 健壮（即使发生错误也可以保证响应性）
- 弹性（在不同的工作负载下保持响应性）
- 消息驱动（依赖异步消息传递机制）

响应式编程可以确保单个服务的异步非阻塞，整个系统的响应式需要整体考滤。



### 1.2 响应式应用案例

**响应式编程是使用异步数据流进行编程**

流是一个时序事件序列，可以发送三种不同的事件：（某种类型的）值 、错误或者一个完成信号。

分为值、错误、完成定义事件的函数，异步的处理事件。

监听一个流称为订阅，定义的函数称为观察者，流是被观察者，即观察者模式。

每个流会有多个方法，如map、filter、scan等等。

当调用其中一个方法时，它会基于原来的流返回一个新的流。

它不对原来的点击流做任何的修改，这个特性称为不变性，也可以称为方法链式调用。

```sh
clickStream:  ---c---c--c---c------c-->
              vvvv map(c becomes 1)vvvv
              ---c---c--c---c------c-->
              vvvvvvvvv scan(+) vvvvvvvv
counterstream:---1---2--3---4------5-->
```

map(f) 会根据提供的f函数把原来Stream中的Value分别映射到新的Stream中

scan(g) 会根据你提供的G函数把Stream中的所有Value聚合成一个Value x=g(sccumulated,current)

每click一次，countStream就会把点击的总次数发送给它的观察者。



### 1.3 响应式编程的现状

2011年，微软发布了.NET的响应式扩展，以方便异步、事件驱动的程序。

ReactiveX混合了迭代器和观察者模式，不同之处在于一个是推模式，一个是基于迭代器的拉模式。

除了对变化事件的观察，完成事件和异常事件也会发送给订阅者。

ReactiveX的基本思想是事件是数据，数据是事件。

响应式扩展被移植到了几种语言和平台上，包括 javascript、Python、C++、swift和java、ReactiveX很快成为一种跨语言的标准，将响应式编程引入到行业中。

RxJava，是java的ReactiveX实现。

RxJava是其他reactivex jvm平台技术的主要技术，其他的如RxScala、RxKotlin、RxGroovy。RxJava已经碾为Android开发的核心技术，并且可以开箱即用的使用RxJava。

这表明RxJava不仅仅是一个库，它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。



### 1.4 为什么采用响应式Spring？

响应式系统非常的复杂，在构建这类系统时困难也非常的多。

要轻松构建响应式系统，就必须首先分析能够构建这类系统的框架，然后选择其中之一。

选择框架最常用的方法之一是分析其可用功能，相关性及社区。

在JVM领域，构建响应式系统最知名的框架是Akka和vert.x生态系统。

一方面,Akka是一个受欢迎的框架，具有大量功能和大型社区，然后，Akka最初是作为Scala生态系统的一部分构建的，在很长一段时间内，它仅在基于Scala编写的解决方法中展示它强大的功能，尽管Scala是一种基于JVM的语言，但它与JAVA明显不同，几年前，Akka直接支持java，但是出于某些原因，它在java世界中不像在Scala世界中那么受欢迎。

另一方法，Vert.x框架也是构建高效响应式系统的强大解决方案，Vert.x的设计初衷是作为Node.js在java虚拟机上的替代方法，它支持非阻塞和事件驱动。然后，Vert.x仅在几年前开始具备竞争力，在过去的15年中，Spring框架一直在构建灵活且健状的应用程序框架市场中占有主导地位。

Spring框架使用适合开发人员的编程模型，为构建Web应用程序提供了广泛的可能性，然后长期以来，它在构建健状的响应式系统方法存在一个局限。

Spring框架在一个单独的线程中包装了阻塞式网络调用，同时Spring MVC依赖于Servlet API ，这使得所有的实现必须使用线程的单次请求（thread-per-request)模型。

这种模型非常不理想，效率低下。

为此，响应式规则建议使用非阻塞的操作，但这是Spring生态系统缺少的。此外Spring也没有与Netty等响应式服务器进行良好的集成，而这些响应式服务器解决了上下文切换的问题。

## 2 无处不在的响应性

### 2.1 API不一致的问题

大量的同类弄响应式可供选择（RxJava、CompletableStage、Vert.x、Akka）

另外一方面，丰富的选择很容易使得系统过于复杂。例如，若存在两个依赖于同一个异步非阻塞通信概念但具有不同的API的库，会导致 我们需要提供额外的工具类，以便将一个回调转换为另外一个回调，反之亦然。

Spring4.x框架中的ListenableFuture和CompletionStage之间没有直接集成 。

在许多情况下，为了解决几个问题并使得几个独立的库兼容，必须提供自己的适配并在几个地方重用。

自己写的适配可能bug。需要额外的维护。

Spring5.x框架扩展了ListenableFuture的API并且提供了一个Completable的方法来解决不兼容的问题。

这里的核心 问题在于没有标准。



### 2.2 推拉

在整个响应式环境演变的早期阶段，所有库的设计思想都是把数据从源头推送到订阅者。

因为纯粹的拉模型在某些场景下效率不够高。

拉模型

![image-20241126222758306](.\images\image-20241126222758306.png)

问题：

处理时间方面，仍然存在一些效率低下的情况。

发送一批元素比发送一个元素需要更多的时间。

为了提供最终的优化，只会请求一次数据，当数据变为可用时，该数据源异步推送数据。

![image-20241126223017360](.\images\image-20241126223017360.png)

再次对整体处理时间做了优化。在交互过程中，只有当服务等待每个响应时会有大段空间时间，当第一个元素到达后，数据库会在数据到达时开始发送后续元素。



### 2.3 流量控制问题

在生产者与消费者的处理过程中，会存在两边处理速度不一致的问题。两种场景：

1. 慢生产者和快消费者。
2. 快生产者和慢消费者。

使用队列推送数据的关键要素之一是选择有合适特性的队列 

通常有3种。无界队列、有界丢序队列、有限阻塞队列。

**无界队列**

![image-20241126223504790](.\images\image-20241126223504790.png)

此队列的最大问题在于，一旦到达内存上限，整个系统就很容易崩溃。

**有界丢弃队列**

![image-20241126223629051](.\images\image-20241126223629051.png)

此技术考滤了资源的限制，并且可以根据资源的能力配制队列的容易，当消息的重要性很低时，采用这种队列是一种常见的做法。

**有界阻塞队列**

![image-20241126223917359](.\images\image-20241126223917359.png)

遗憾的是这种技术否定了系统的所有异步的行为。通常一旦生产者到达队列的限制。它就会开始被阻塞并将处理该状态，直接消费者消费了一个元素，从而使队列中出现可用空间为止，由此我们可以得出结论，最慢的消费者的吞吐率限制了系统总吞吐量。继而，除了否定异步行为了该技术还否定了有效的资源利用率，因此想要实现回弹性、弹性和即时响应所有的三方法，那么这些场景会部不可接受。





### 2.4 解决方法

来自 Lightbend、Netflix 和 Pivotal 的一群天才工程师齐聚一堂，共同解决上述问题 并为 JVM 社区提供标准。 

经过长达一年的努力，响应式流规范的初稿公诸于世。

其概念就是响应式编程模式的标准化。



## 3 响应式流规范

### 3.1 响应式流规范基础

响应式流规范网站：

```sh
http://www.reactive-streams.org
```

响应式规则发布了一组接口，用于实现：

maven地址:

```xml
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck-flow</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-examples</artifactId>
  <version>1.0.3</version>
</dependency>
```

响应式流规范文档

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
```

**响应式流规范**

响应式流（Reactive Streams）规范，规定了异步组件之前使用背压进行交互。

响应式流在java 9中使用flow API适配。Flow API是互操作的规范，而不是具体的实现，它的主义跟响应式流规范一致。

响应式流规范包括如下接口

**Publisher**

表示数据流的生产者或者数据源，包含一个方法让订阅者注册 到发布者，Puhblisher代表了发布者和订阅者直接连接的标准化入口点。

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```



**Subscriber**

表示消费者，onSubscriber方法为我们提供了一种标准化的方法来通知Subscriber订阅成功。

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- onSubscribe发布者在开始处理之前调用，并向订阅者传递一个订阅票据对象（Subscription).
- onNext 用于通知订阅者发布者发布了新的数据项。
- onError 用于通知订阅者，发布者遇到了异常，不再发布数据事件。
- onComplete 用于通知订阅者所有的数据事件都已经发布完。

**Subscription**

onSubscribe方法的传入参数引入一名为Subscription(订阅)的订阅票据。

Subscription为控制元素的生产提供了基础。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- request 用于让订阅者通知发布者随后 需要发布的元素数量。
- cancel 用于让订阅者取消发布者随后的事件流。

**Processor**

如果实体需要转换进来的项目，并将转换后的项目传递给另一个订阅者，此时需要Processor接口。该接口既是订阅者，又是发布者。

```xml
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```



### 3.2 响应式流规范实战

地址：

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification
```

添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

异步发布者

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Publisher的实现，用于进行数据的生产操作，可以理解为要加工的数据
 *
 * @author nullnull
 * @since 2023/6/27
 */
public class AsyncIterablePublisher<T> implements Publisher<T> {


    /**
     * 默认的批次大小
     */
    private static final int DEFAULT_BATCH_SIZE = 1024;

    /**
     * 迭代器，用于原始数据的生成操作
     */
    private final Iterable<T> iterable;

    /**
     * 线程池接口，用于生成任务的并行执行
     */
    private final Executor executor;

    /**
     * 用于批次处理任务的大小
     */
    private final int batchSize;


    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor) {
        this(iterable, executor, DEFAULT_BATCH_SIZE);
    }

    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor, int batchSize) {
        //进行参数的检查
        if (null == iterable) {
            throw new NullPointerException("iterable is null");
        }

        if (null == executor) {
            throw new NullPointerException("executor is null");
        }

        if (batchSize < 1) {
            throw new IllegalArgumentException("param batch size is < 1");
        }


        this.iterable = iterable;
        this.executor = executor;
        this.batchSize = batchSize;
    }

    @Override
    public void subscribe(Subscriber<? super T> s) {
        new SubscriberImpl(s).init();
    }


    /**
     * 用于处理订阅的信号
     */
    static interface Signal {
    }

    /**
     * 取消订阅的信号
     */
    enum Cancel implements Signal {
        Instance;
    }

    /**
     * 订阅的信号
     */
    enum Subscribe implements Signal {
        Instance;
    }

    /**
     * 发送的信号
     */
    enum Send implements Signal {
        Instance;
    }

    /**
     * 请求的信号
     */
    static final class Request implements Signal {
        final long n;

        public Request(long n) {
            this.n = n;
        }
    }

    /**
     * 订阅票据，实现了Subscription接口和Runnable接口
     */
    final class SubscriberImpl implements Subscription, Runnable {

        /**
         * Subscriber的引用，用于通信
         */
        private final Subscriber<? super T> subscriber;

        /**
         * 该订阅票据是否失效的标志
         */
        private boolean cancelled = false;

        /**
         * 记录订阅者的数量，这些请求还没有对订阅者回复
         */
        private long demand = 0;

        /**
         * 发送给订阅者的数据流
         */
        private Iterator<T> iterator;

        /**
         * 该队列用于记录发送票据的信号（入栈信号），如"request"，"cancel"等。
         * <p>
         * 通过此队列可以在Publisher端使用多线程异步处理
         */
        private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


        /**
         * 确保票据不会并发的标志，
         * <p>
         * 防止在调用订阅者的onXxx方法的时候并发调用。规范1.3规定的不能并发。
         */
        private final AtomicBoolean on = new AtomicBoolean(false);

        public SubscriberImpl(Subscriber<? super T> subscriber) {
            //根据规范，如果Subscriber为null，需要抛空指针异常，此处抛null。
            if (null == subscriber) {
                throw null;
            }

            this.subscriber = subscriber;
        }


        private void doRequest(int n) {
            // 规范规定，如果请求的元素个数小于1，则抛异常
            // 并在异常信息中指明错误的原因：n必须是正整数。
            if (n < 1) {
                terminateDueTo(new IllegalArgumentException(subscriber
                        + "violated the Reactive Streams rule 3.9 by requesting a non -positive number of elements."));
            }
            // 根据规范 3.17，当请求的元素数大于Long.MAX_VALUE的时候，将请求数  设置为Long.MAX_VALUE即可。
            else if (demand + n < 1) {
                //此认为是无界流
                demand = Long.MAX_VALUE;
                //开始向下游发送元素
                doSend();
            }
            //其他情况，表示当前是设置了正常请求数量
            else {
                //记录下请求个数的元素
                demand += n;
                //开始向下游发送元素
                doSend();
            }
        }


        private void doSend() {
            try {
                long leftBatchSize = batchSize;
                //为充分利用线程池，最多发送BatchSize个元素。然后放弃当前线程，重新调度，通知订阅者onNext信号
                do {
                    T next;
                    boolean hashNext;

                    try {
                        //订阅者在订阅的时候，已经调用了hashNext方法，直接获取
                        // Need to keep track of End-of-Stream
                        next = iterator.next();
                        //检查还有没有数据，如果没有了，表示流结束了
                        hashNext = iterator.hasNext();
                    } catch (final Throwable e) {
                        // If `next` or `hasNext` throws (they can, since  it is user - provided),we need to treat
                        // the stream as errored as per rule1.4

                        //如果next方法或者hashNext方法抛出异常（用户提供），认为流招聘了异常了发送onError信号
                        terminateDueTo(e);

                        return;
                    }

                    //向下流订阅者发送next的信号
                    subscriber.onNext(next);

                    //如果已经到达结束位置，
                    if (!hashNext) {
                        // We need to consider this `Subscription` as cancelled as per rule 1.6
                        // 首先考滤票据取消了订阅
                        doCancel();

                        // Then we signal `onComplete` as per rule 1.2 and    1.5
                        //发送onComplete信号给订阅者
                        subscriber.onComplete();
                    }

                } while (
                    //确保当前没有被取消订阅
                    // This makes  sure that rule 1.8 is upheld,
                    // i.e.we need to stop signalling "eventually"
                        !cancelled
                                //并且还有剩余的元素
                                // 如果还有剩余批次的元素。This   makes sure that we only send
                                // `batchSize`number of elements in one go (so  we can yield to other Runnables)
                                && --leftBatchSize > 0
                                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)
                                && --demand > 0);


                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)

                // If the `Subscription` is still alive and well,
                // and we have demand to satisfy, we signal ourselves to send more data

                // 如果订阅票据没有取消，还有请求，通知自己发送更多的数据
                if (!cancelled && demand > 0)
                    signal(Send.Instance);

            } catch (Throwable t) {

                // We can only get here if `onNext` or `onComplete` threw,
                // and they are not allowed to according to 2.13,
                // so we can only cancel and log here.

                // 如果到这里，只能是onNext或onComplete抛异常，只能取消。

                // Make sure that we are cancelled,
                // since we cannot do   anything else since the `Subscriber`is faulty.

                // 确保已取消，因为是Subscriber的问题
                doCancel();

                // 记录错误信息
                (new IllegalStateException(subscriber
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onNext or "
                        + "onComplete. ", t))
                        .printStackTrace(System.err);
            }
        }


        /**
         * 异常给认
         *
         * @param signal
         */
        private void signal(final Signal signal) {
            //将信号放入入栈队列
            if (inboundSignals.offer(signal)) {
                //信号放入线程成功，则调度线程进行处理
                tryScheduleToExecute();
            }
        }

        /**
         * 该方法确保订阅票据同一个时间在同一个线程运行
         * <p>
         * 规范1.3规定，调用`Subscriber`的`onSubscribe`，`onNext`，`onError`和 `onComplete`方法必须串行，不允许并发。
         */
        private final void tryScheduleToExecute() {

            // 使用原子变量进行CAS操作，成功，是说明当前线程可以处理，失败表示已经在处理了
            if (on.compareAndSet(false, true)) {
                try {
                    //向线程池中提交一个任务
                    executor.execute(this);
                    //如果不能提交线程池运行，则优雅的退出
                } catch (Throwable e) {
                    if (!cancelled) {
                        //错误不可恢复，执行取消订阅
                        doCancel();
                        try {
                            // 停止,发送error信号
                            terminateDueTo(new
                                    IllegalStateException("Publisher terminated due to unavailable Executor.",
                                    e));
                        } finally {
                            // 后续的入站信号不需要处理了，清空信号
                            inboundSignals.clear();
                            // 取消当前订阅票据，但是让该票据处于可调度状态，以防清空入站信号之后又有入站信号加入。  异步订阅者：
                            on.set(false);

                        }

                    }

                }
            }

        }


        /**
         * 规范3.5指明，Subscription.cancel方法必须及时的返回，保持调用者的响应性， 还必须是幂等的，必须是线程安全的。
         * <p>
         * 因此该方法不能执行密集的计算。
         */
        private void doCancel() {
            cancelled = true;
        }


        /**
         * 终止订阅，
         * <p>
         * 规范1.6指出，`Publisher`在通知订阅者`onError`或者`onComplete`信号之
         * 前，
         * <p>
         * **必须**先取消订阅者的订阅票据（`Subscription`）。
         * <p>
         * <p>
         * <p>
         * 当发送onError信号之前先取消订阅
         *
         * @param exception
         */
        private void terminateDueTo(Throwable exception) {
            //发送error前，必须取消订阅
            cancelled = true;

            try {
                //给下游发送onError信号
                subscriber.onError(exception);
            } catch (Throwable e) {
                // 规范1.9指出，onError不能抛异常。
                // 如果onError抛异常，只能记录信息。
                (new IllegalStateException(
                        subscriber +
                                "violated the  Reactive Streams rule 2.13 by throwing an exception from onError.", e))
                        .printStackTrace(System.err);
            }
        }


        @Override
        public void run() {
            // 与上次线程执行建立happens-before关系，防止并发执行
            // 如果on.get()为false，则不执行，线程退出
            // 如果on.get()为false，则表示没有线程在执行，当前线程可以执行
            if (on.get()) {
                //1,从队列中取出一个信号
                Signal poll = inboundSignals.poll();
                // 规范1.8：如果`Subscription`被取消了，则必须最终停止向`Subscriber`发送通知。
                // 规范3.6：如果取消了`Subscription`，则随后调用`Subscription.request( long n)`必须是无效的（NOPs）。
                // 如果订阅票据没有取消
                if (!cancelled) {
                    try {
                        //根据信号进行方法的处理操作
                        // 请求
                        if (poll instanceof Request) {
                            doRequest((int) ((Request) poll).n);
                        }
                        //发送信息
                        if (poll == Send.Instance) {
                            doSend();
                        }
                        //取消信号
                        if (poll == Cancel.Instance) {
                            doCancel();
                        }
                        //订阅信号
                        if (poll == Subscribe.Instance) {
                            doSubscribe();
                        }
                    } finally {
                        // 保证与下一个线程调度的happens-before关系
                        on.set(false);
                        //如果还有信号需要处理
                        if (!inboundSignals.isEmpty()) {
                            // 调度当前线程进行处理
                            tryScheduleToExecute();
                        }
                    }

                }
            }


        }

        /**
         * 不是在`Publisher.subscribe`方法中同步地调用`subscriber.onSubscribe` 方法，而是异步地执行subscriber.onSubscribe方法
         * <p>
         * 这样可以避免在调用线程执行用户的代码。因为在订阅者的onSubscribe方法中要执行 Iterable.iterator方法。
         * <p>
         * 异步处理也无形中遵循了规范的1.9。
         */
        private void doSubscribe() {
            try {
                //获取数据源的迭代器
                iterator = iterable.iterator();

                if (iterator == null) {
                    // 如果iterator是null，就重置为空集合的迭代器。我们假设 iterator永远不是null值。
                    iterator = Collections.<T>emptyList().iterator();
                }
            } catch (Throwable e) {
                // Publisher发生了异常，此时需要通知订阅者onError信号。
                // 但是规范1.9指定了在通知订阅者其他信号之前，必须先通知订阅者  onSubscribe信号。
                // 因此，此处通知订阅者onSubscribe信号，发送空的订阅票据
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {
                        // 空的
                    }

                    @Override
                    public void cancel() {
                        // 空的
                    }
                });
                // 根据规范1.9，通知订阅者onError信号
                terminateDueTo(e);
            }

            if (!cancelled) {
                try {
                    // 为订阅者设置订阅票据。
                    subscriber.onSubscribe(this);
                } catch (Throwable e) {
                    // Publisher方法抛异常，此时需要通知订阅者onError信号。
                    // 但是根据规范2.13，通知订阅者onError信号之前必须先取消该订阅 者的订阅票据。
                    // Publisher记录下异常信息。
                    terminateDueTo(new IllegalStateException(subscriber
                            + "violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe. ",
                            e));
                }

                // 立即处理已经完成的迭代器
                boolean hashNext = false;
                try {
                    // 判断是否还有未发送的数据，如果没有，则向订阅者发送onComplete 信号
                    hashNext = iterator.hasNext();
                } catch (Throwable e) {
                    // 规范的1.4规定
                    // 如果hasNext发生异常，必须向订阅者发送onError信号，发送信号之  前先取消订阅
                    // 规范1.2规定，Publisher通过向订阅者通知onError或 onComplete信号，
                    // 发送少于订阅者请求的onNext信号。
                    terminateDueTo(e);
                }


                // 如果没有数据发送了，表示已经完成，直接发送onComplete信号终止订阅 票据。
                // 规范1.3规定，通知订阅者onXxx信号，必须串行，不能并发。
                if (!hashNext) {
                    try {
                        // 规范1.6指明，在通知订阅者onError或onComplete信号之   前，必须先取消订阅者的订阅票据。
                        // 在发送onComplete信号之前，考虑一下，有可能是  Subscription取消了订阅。
                        doCancel();
                        subscriber.onComplete();
                    } catch (final Throwable t) {
                        // 规范2.13指出，onComplete信号不允许抛异常，因此此处只能 记录下来日志
                        (new IllegalStateException(subscriber
                                + " violatedthe Reactive Streams rule 2.13 by throwing an exception from onComplete.",
                                t)).printStackTrace(System.err);
                    }
                }
            }

        }

        /**
         * 注册订阅者发送过来的信号
         *
         * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
         */
        @Override
        public void request(final long n) {
            signal(new Request(n));
        }


        @Override
        public void cancel() {
            signal(Cancel.Instance);
        }

        /**
         * init方法的设置，用于确保SubscriptionImpl实例在暴露给线程池之前已经构造完成
         * <p>
         * 因此，在构造器一完成，就调用该方法，仅调用一次。
         * <p>
         * 先发个信号试一下
         */
        void init() {
            signal(Subscribe.Instance);
        }
    }
```

异步订阅者

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 自定义订阅者信息
 * <p>
 * 基于Executor的异步运行的订阅者实现，一次请求一个元素，然后对每个元素调用用户定义的方
 * 法进行处理。
 * 注意：该类中使用了很多try-catch用于说明什么时候可以抛异常，什么时候不可以抛异常
 *
 * @author liujun
 * @since 2023/6/30
 */
public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {

    /**
     * Signal表示发布者和订阅者之间的异步协议
     */
    private static interface Signal {
    }

    /**
     * 表示数据流发送完成，完成信号
     */
    private enum OnComplete implements Signal {
        Instance;
    }

    /**
     * 错误信号
     */
    private static class OnError implements Signal {
        public final Throwable error;

        public OnError(Throwable error) {
            this.error = error;
        }
    }

    /**
     * 表示下一个数据项信号
     *
     * @param <T>
     */
    private static class OnNext<T> implements Signal {
        private T next;

        public OnNext(T next) {
            this.next = next;
        }
    }

    /**
     * 表示订阅者的订阅成功信号
     */
    private static class OnSubscribe implements Signal {
        private Subscription subscription;

        public OnSubscribe(Subscription subscription) {
            this.subscription = subscription;
        }
    }


    /**
     * 订阅单据,根据规范3.1，该引用是私有的
     */
    private Subscription subscription;

    /**
     * 用于表示当前的订阅者是否处理完成
     */
    private boolean done;

    /**
     * 根据规范的2.2条款，使用该线程池异步处理各个信号
     */
    private final Executor executor;


    /**
     * 存储信号的队列
     */
    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


    /**
     * 根据规范2.7和2.11，使用原子变量确保不会有多个订阅者线程并发执行。
     */
    private final AtomicBoolean on = new AtomicBoolean(false);


    /**
     * This method is invoked when the OnNext signals arrive
     * Returns whether more elements are desired or not, and if no more elements are   desired,
     * for convenience.
     *
     * @param element
     * @return
     */
    protected abstract boolean whenNext(final T element);

    /**
     * This method is invoked when the OnComplete signal arrives
     * override this method to implement your own custom onComplete logic.
     */
    protected void whenOnComplete() {
    }


    /**
     * This method is invoked if the OnError signal arrives
     * override this method to implement your own custom onError logic.
     */
    protected void whenOnError(Throwable e) {

    }


    /**
     * 仅有这一个构造器，只能被子类调用
     * 传递一个线程池即可
     *
     * @param executor
     */
    public AsyncSubscriber(Executor executor) {
        if (executor == null) {
            throw null;
        }
        this.executor = executor;
    }

    @Override
    public void run() {
        // 跟上次线程执行建立happens-before关系，防止多个线程并发执行
        if (on.get()) {
            try {
                //从队列中取出信号
                Signal poll = inboundSignals.poll();
                // 根据规范条款2.8，如果当前订阅者已完成，就不需要处理了。
                if (!done) {
                    //根据信号类型对应处理
                    if (poll instanceof OnNext) {
                        handleOnNext(((OnNext<T>) poll).next);
                    }
                    //订阅信号
                    else if (poll instanceof OnSubscribe) {
                        handleOnSubscribe(((OnSubscribe) poll).subscription);
                    }
                    //错误信号
                    else if (poll instanceof OnError) {
                        handleOnError(((OnError) poll).error);
                    }
                    //完成信号
                    else if (poll instanceof OnComplete) {
                        handleOnComplete();
                    }
                }
            } finally {
                //设置为false，让下一个线程可以调度。
                on.set(false);
                //队列中还存在数据，继续执行入队列信号
                if (!inboundSignals.isEmpty()) {
                    tryScheduleToExecute();
                }
            }
        }
    }

    /**
     * 调度放入线程池处理操作
     * 确保订阅者一次仅在一个线程执行
     */
    private void tryScheduleToExecute() {
        //原子CAS操作，将false改为true
        if (on.compareAndSet(false, true)) {
            try {
                //将任务提交线程池
                executor.execute(this);
            } catch (Throwable e) {
                // 根据规范条款2.13，如果不能执行线程池的提交方法，需要优雅退出
                if (!done) {
                    try {
                        // 由于错误不可恢复，因此取消订阅票据
                        done();
                    } finally {
                        //首先做队列的清空处理
                        inboundSignals.clear();
                        // 由于订阅票据已经取消，但是此处依然让订阅者处于可调度的状
                        //态，以防在清空入站信号之后又有信号发送过来
                        // 因为信号的发送是异步的
                        on.set(false);
                    }
                }
            }
        }
    }

    /**
     * 幂等地标记当前订阅者已完成处理，不再处理更多的元素。
     * 因此，需要取消订阅票据（Subscription）
     */
    private void done() {
        // 在此处，可以添加done，对订阅者的完成状态进行设置；
        // 虽然规范3.7规定Subscription.cancel()是幂等的，我们不需要这么做。
        // 当whenNext方法抛异常，认为订阅者已经处理完成（不再接收更多元素）
        done = true;
        // If we are bailing out before we got a `Subscription`there 's little need for cancelling it.
        if (subscription != null) {
            try {
                subscription.cancel();
            } catch (Throwable e) {
                // 根据规范条款3.15，此处不能抛异常，因此只是记录下来。
                (new IllegalStateException(subscription
                        + " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        e)).printStackTrace(System.err);
            }
        }
    }

    /**
     * Here it is important that we do not violate 2.2 and 2.3 by calling  methods on  the `Subscription`or `Publisher`
     * <p>
     * 完成信号处理
     */
    private void handleOnComplete() {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onError before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive  Streams rule 1.09 signalling onError prior "
                            + "to onSubscribe. ")).printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;

        //发送完成信号
        whenOnComplete();

    }

    /**
     * 错误信号处理
     *
     * @param error
     */
    private void handleOnError(Throwable error) {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onComplete before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe. "))
                    .printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;
        //发送错误信号
        whenOnError(error);
    }

    /**
     * 订阅信号处理
     *
     * @param subscriptionTmp
     */
    private void handleOnSubscribe(Subscription subscriptionTmp) {
        if (subscriptionTmp == null) {
            // Getting a null `Subscription` here is not valid so lets just  ignore it.
            return;
        }

        //如果上一个订阅还存在，则需进要对当前信号做取消处理
        if (subscription != null) {
            try {
                subscriptionTmp.cancel();
            } catch (final Throwable t) {
                //Subscription.cancel is not allowed to throw an exception, according to rule 3.15
                (new IllegalStateException(subscriptionTmp +
                        " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        t)).printStackTrace(System.err);
            }
            return;
        }


        //其他情况，表示正常，发送首个请求数据的信号
        subscription = subscriptionTmp;

        try {
            // If we want elements, according to rule 2.1 we need to
            //call `request`
            // And, according to rule 3.2 we are allowed to call this
            //synchronously from within the `onSubscribe`method
            subscription.request(1); // Our Subscriber is unbuffered and modest,
            //it requests one element at a time
        } catch (final Throwable t) {
            // Subscription.request is not allowed to throw according
            //to rule 3.16
            (new IllegalStateException(subscription
                    + " violated the Reactive Streams rule 3.16 by throwing an exception from request.",
                    t)).printStackTrace(System.err);
        }
    }

    /**
     * 处理数据
     *
     * @param element
     */
    private void handleOnNext(final T element) {
        // If we aren't already done
        if (done) {
            return;
        }
        // Technically this check is not
        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            //        // Check for spec violation of 2.1 and 1.09
            (new IllegalStateException(
                    "Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before  "
                            + "`Subscription.request`. (no Subscription)")).printStackTrace(System.err);
        }

        try {
            //如果数据还有下一条记录，则再次请求1条记录
            if (whenNext(element)) {
                try {
                    // Our Subscriber is
                    //unbuffered and modest, it requests one element at a time
                    subscription.request(1);
                } catch (Throwable e) {
                    // Subscription.request is not allowed to throw
                    //according to rule 3.16
                    (new IllegalStateException(subscription
                            + "violated the Reactive Streams rule 3.16 by throwing an exception from request."
                            + " ", e)).printStackTrace(System.err);
                }
            }
            //如果没有元素了，标识结束
            else {
                done();
            }
        } catch (Throwable e) {
            //当发生异常，标识当前完成
            done();
            //发送异常信息
            try {
                onError(e);
            } catch (Throwable ex) {
                //Subscriber.onError is not allowed to throw an
                //exception, according to rule 2.13
                (new IllegalStateException(this
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.",
                        ex)).printStackTrace(System.err);
            }

        }


    }

    @Override
    public void onSubscribe(Subscription s) {
        // As per rule 2.13, we need to throw a `java.lang.NullPointerException`if the `Subscription`is `null`
        if (s == null) {
            throw null;
        }
        signal(new OnSubscribe(s));
    }

    private void signal(Signal signal) {
        // 信号入站，线程池调度处理
        // 不需要检查是否为null，因为已经实例化了。
        if (inboundSignals.offer(signal)) {
            //放入执行调度，立即执行
            tryScheduleToExecute();
        }
    }

    @Override
    public void onNext(T t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `element`is `null`
        if (t == null) {
            throw null;
        }

        signal(new OnNext<>(t));
    }

    @Override
    public void onError(Throwable t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `Throwable`is `null`
        if (t == null) {
            throw null;
        }
        signal(new OnError(t));
    }

    @Override
    public void onComplete() {
        signal(OnComplete.Instance);
    }
}
```

单元测试

```java
import org.junit.Test;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class AsyncReactiveTest {

    @Test
    public void dataTest() throws InterruptedException {
        Set<Integer> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(i);
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<Integer> publisher
                = new AsyncIterablePublisher<>(elements, executorService);

        //同步订阅者的测试
        MySubscriber subscriberTmp = new MySubscriber();
        publisher.subscribe(subscriberTmp);


        ////异常订阅者的处理
        //final SelfSubscriber<Integer> subscriber = new SelfSubscriber<>
        //        (Executors.newFixedThreadPool(2)) {
        //    @Override
        //    protected boolean whenNext(Integer element) {
        //        System.out.println("接收到的流元素：" + element);
        //        return true;
        //    }
        //};
        //publisher.subscribe(subscriber);

        Thread.sleep(1000000);

    }


    public class MySubscriber implements Subscriber<Integer> {
        private Subscription sub;

        private int randNum = 5;


        @Override
        public void onSubscribe(Subscription s) {
            System.out.println("调用了订阅方法");
            sub = s;
            sub.request(1);
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("调用了onNext方法" + integer + ",rand:" + randNum);

            if (integer == 0 || (integer + 1) % randNum == 0) {
                System.out.println("再次request:" + randNum);
                sub.request(randNum);
            }
        }

        @Override
        public void onError(Throwable t) {
            System.out.println("错误处理:" + t);
        }

        @Override
        public void onComplete() {
            System.out.println("结束");
        }
    }

}
```

### 3.3 响应式流技术兼容套件

#### 3.3.1 TCK

响应式流看着比较简单，实际包含许多的隐藏陷阱。

除java接口外，该规范还包含许多针对实现的文档化规则。

这些规则严格限制每个接口，同时，保留规范中提到的所有行为至关重要。

开发人员需要一个可以验证所有行为并确保响应库标准化且想到兼容的通用工具。

Konrad Malawski 已经为此实现了一个工具包，其名称为响应式流技术兼容套件（Reactive  Streams Technology Compatibility Kit），简称为 TCK。

TCK是一组TestNG测试用例，需要对其进行扩展，并为相应的Publisher或者Subscriber准备验证。

首先还是引入maven坐标

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>6.9.10</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.16</version>
    </dependency>
</dependencies>
```

**发布者验证**

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.tck.PublisherVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TckTest extends PublisherVerification<String> {


    public TckTest()
    {
        super(new TestEnvironment());
    }

    @Override
    public Publisher<String> createPublisher(long l) {

        Set<String> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(String.valueOf(i));
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<String> publisher
                = new AsyncIterablePublisher<>(elements, executorService);
        return publisher;
    }

    @Override
    public Publisher<String> createFailedPublisher() {

        Set elements = new HashSet<>();
        elements.add(new RuntimeException("手动异常"));

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        return new AsyncIterablePublisher<>(elements,executorService);
    }
}
```

只遵循上述测试用例配制，无法检查该Publisher的准确性，因为许多测试假设流中存在多个元素。

响应式流TCK考滤了这种极端情况，并支持设置一外名为maxElementsFromPublisher方法，该方法返回一个值，用于指定生成元素的最大数量。

```java
    @Override
    public long maxElementsFromPublisher() {
        //return super.maxElementsFromPublisher();
        return 10;
    }
```

一方面重写该方法可以跳过需要多个元素的测试，另一方面，响应式流规则的覆盖范围将减小，可能需要实现自定义测试用例。

**订阅者验证**

订阅者存在两种验证方式。黑盒验证和白盒验证。

首先看黑盒验证

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.tck.SubscriberBlackboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TCKBlackBoxTest extends SubscriberBlackboxVerification<Integer> {


    protected TCKBlackBoxTest() {
        super(new TestEnvironment());
    }

    @Override
    public Subscriber<Integer> createSubscriber() {
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素:" + element);
                //该返回为true，表示继续接收下一个元素，false表示不再请求了
                return true;
            }
        };
        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }

    //@Override
    //public void triggerRequest(Subscriber<? super Integer> subscriber) {
    //    //该方法直接向订阅者发送信号，默认该方法什么都不做
    //    AsyncSubscriber<Integer> subscriber1 = (AsyncSubscriber<Integer>) subscriber;
    //    subscriber1.onNext(100000);
    //}
}
```

该测试用例，可以模拟真实的用户活动。

再看白盒测试

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.reactivestreams.tck.SubscriberWhiteboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class TestWhiteBoxTest extends SubscriberWhiteboxVerification<Integer> {

    protected TestWhiteBoxTest() {
        super(new TestEnvironment());
    }


    @Override
    public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> whiteboxSubscriberProbe) {

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素：" + element);
                //返回true表示请求下一个元素，false表示不再请求
                return true;
            }

            @Override
            public void onSubscribe(Subscription subscription) {
                super.onSubscribe(subscription);
                whiteboxSubscriberProbe.registerOnSubscribe(new SubscriberPuppet() {
                    @Override
                    public void triggerRequest(long elements) {
                        subscription.request(elements);
                    }

                    @Override
                    public void signalCancel() {
                        subscription.cancel();
                    }
                });
            }

            @Override
            public void onNext(Object object) {
                super.onNext(object);
                whiteboxSubscriberProbe.registerOnNext((Integer) object);
            }

            @Override
            public void onError(Throwable t) {
                super.onError(t);
                whiteboxSubscriberProbe.registerOnError(t);
            }

            @Override
            public void onComplete() {
                super.onComplete();
                whiteboxSubscriberProbe.registerOnComplete();
            }
        };


        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }
}
```

createSubscriber方法实现与黑盒验证的工作方式相同，并返回Subscriber实例，但此处还有一个名为whiteboxSubscriberProbe的附加参数。

在这种情况下，whiteboxSubscriberProbe代表了一种机制，该机制实现对需求的嵌入式控制和输入信号的捕获。

与黑盒验证相比，通过正确的注册探测钩子，测试套件不仅能够发送需求，还能验证需求是否被满足以及所有元素是否被接受。同时，需求监控机制比以前更加透明。我们实现了subScriberPupper，它会为直接访问收到的Subscription进行适配。



同时TCK还提供 了processor的测试，此处略过。



## 4. 响应流的异步与并行

一方面，响应流的API中的规则 2.2和3.4规定，对由publisher生成并由Subscriber消费的所有信号的处理过程应该是非阻塞和非干扰的。

因此基于具体的执行环境，可以高效的利用处理器的一个节点和一个内核。

另一方面，所有处理器或者内核的高效利用需要并行化，对响应式流规范中的并行化概念的可以理解为对Subscrber#onNext方法的并行调用。

遗憾的是，规则 中的规则1.3规定，必须以线程安全的方式触发onXXX方法的调用，并且如果由多个线程执行，则使用外部同步，这一假定对所有OnXXX方法的串行化或者简单顺序调用。反过来，这意味着无法创建类型ParallelPublisher的组件并在流中对元素进行并行处理。

如果高效的利用资源，就必须分析常见了流处理管道。



![image-20241127122543496](.\images\image-20241127122543496.png)

一种解决方案是在阶段之间传递异步消息，对于基于内存的流处理而言，这意味着执行过程的一部分被绑定到了一个线程而另一部分被绑定到了另一个线程。

![image-20241127122804397](.\images\image-20241127122804397.png)

通常的做法是：两个独立 的线程之间拆分处理过程，在阶段之前放置异步边界。

又因为两个线程可以彼此独立地工作，所以通过这样做，将元素的整体处理过程并行化。为了实现并行化，必须应用一种数据结构（例如queue)来正确的解耦处理过程。

拆分线程之间的处理过程会导致数据结构中的额外的开销。当然，由于响应式流的规定，这样的数据结构是有界的。数据结构中的数据项数量通常等于Subscriber从其他Publisher请求的批处理的大小，而这取决于系统的一般容量。



![image-20241127123609250](.\images\image-20241127123609250.png)

每个处理阶段都可以绑定一个单犯的线程。



## 5. 响应式环境的转变

JDK9包含了响应式规范这一事实强调了该规范的重要性，并且该规范已经开始改变这个行业。

### 5.1 RxJava的转变

例如：一个应用程序把RxJava1.x和Observalbe作为组件之间的核心通信类型:

```java
interface LogService {
    Observable<String> stream();
}
```

遵循响应式流规范并从以下特定依赖中报出我们的接口

```java
interface LogService {
    Publisher<String> stream();
}
```

将RxJava2类型反向转换为响应式流兼容类型：

```java
Flowable.just(1, 2, 3)
   .map(String::valueOf)
   .toObservable()
   .toFlowable(BackpressureStrategy.ERROR)
   .subscribe();

```



### 5.2 Vert.x 的调整

为了遵循规范，Vert.x  包含一个额外的模块，该模块为响应式流 API 提供支持

```java
// ...
.requestHandler(request -> {
    ReactiveReadStream<Buffer> rrs = ReactiveReadStream.readStream();
    HttpServerResponse response = request.response();
    Flowable<Buffer> logs = 
Flowable.fromPublisher(logsService.stream()).map(Buffer::buffer)
       .doOnTerminate(response::end);
    logs.subscribe(rrs);
    response.setStatusCode(200);
    response.setChunked(true);
    response.putHeader("Content-Type", "text/plain");
    response.putHeader("Connection", "keep-alive");
    Pump.pump(rrs, response).start();
});
// ...
```

### 5.3 Ratpack的改进

```java
RatpackServer.start(server -> server.handlers(chain -> chain.all(ctx -> {
    Publisher<String> logs = logsService.stream();
    ServerSentEvents events = serverSentEvents(
        logs, event -> event.id(Objects::toString).event("log").data(Function.identity());
   );
    ctx.render(events);
})));
```

Patpack还提供了对规范接口的自身实现

```java
Publisher<String> logs = logsService.stream();
TransformablePublisher publisher = Streams.transformable(logs)
   .filter(this::filterUserSensitiveLogs)
   .map(this::escape);
```



## 6. Spring响应式编程

### 6.1 观察者模式

好像观察者模式似乎与响应式编程无关，但经过一些小改动，它定义了响应式编程的基础

![image-20241127125125558](.\images\image-20241127125125558.png)

**Subject接口**

```java

/**
 * Subject接口
 *
 * @author liujun
 * @since 2023/7/13
 */
public interface Subject {

    /**
     *  注册观察者
     */
    void registerObserver(Observer observer);

    /**
     * 解绑观察者
     *
     * @param observer
     */
    void unregisterObserver(Observer observer);

    /**
     * 通知事件变更
     *
     * @param event
     */
    void notifyObservers(String event);

}

```

**Observer接口**

```java

/**
 * Observer接口
 *
 * @author nullnull
 * @since 2023/7/13
 */
public interface Observer {

    void observe(String event);

}
```

**Subject实现类**

```java

import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteSubject implements Subject {

    /**
     * 保证Set是线程安全的
     */
    private Set<Observer> observers = new CopyOnWriteArraySet<>();

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void unregisterObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String event) {
        observers.forEach(observer -> observer.observe(event));
    }
}
```

Observer的实现类

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverA implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}

```

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverB implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}
```

单元测试

```java
import org.junit.Test;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ObserverTest {
    @Test
    public void dataTest() {
        Subject subject = new ConcreteSubject();
        Observer observer1 = new ConcreteObserverA();
        Observer observer2 = new ConcreteObserverB();
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);
        subject.notifyObservers("hello null null");
        System.out.println("==================================");
        subject.unregisterObserver(observer1);
        subject.notifyObservers("great null null");

    }
}

```

输出：

```java
com.nullnull.observer.ConcreteObserverA --- hello null null
com.nullnull.observer.ConcreteObserverB --- hello null null
==================================
com.nullnull.observer.ConcreteObserverB --- great null null
```

可以使用java8的lambda的特性:

```java
 @Test
    public void dataTestLambda() {
        Subject subject = new ConcreteSubject();
        subject.registerObserver(e -> System.out.println("A: " + e));
        subject.registerObserver(e -> System.out.println("B: " + e));
        subject.notifyObservers("This message will receive A & B");

        subject.notifyObservers("hello null null");
        System.out.println("==================================");

    }
```

输出:

```java
A: This message will receive A & B
B: This message will receive A & B
A: hello null null
B: hello null null
```



### 6.2 基于@EventListener注解的发布和订阅模式

实现一个简单的WEB服务，用于显示当前的温度。

![image-20241127222027473](.\images\image-20241127222027473.png)

**maven依赖**

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>


        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

**实体**

```java

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }
}

```

**TemperatureSensor类模拟传感器**

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    private final ApplicationEventPublisher publisher;

    private final Random random = new Random();

    private final ScheduledExecutorService service =
            Executors.newSingleThreadScheduledExecutor();

    public TemperatureSensor(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    @PostConstruct
    public void startProcessing() {
        this.service.schedule(this::probe, 1, TimeUnit.SECONDS);
    }

    private void probe() {
        double temperature = 16 + random.nextGaussian() * 10;
        System.err.println("发送事件。。。");
        // 通过ApplicationEventPublisher发布Temperature事件

        publisher.publishEvent(new Temperature(temperature));
        service.schedule(this::probe, random.nextInt(5000),
                TimeUnit.MILLISECONDS);
    }
}
```

**暴露SSE端点**

```java
import org.json.JSONObject;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@RestController
public class TemperatureController {

    private final Set<SseEmitter> clients = new CopyOnWriteArraySet<>();

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {

        // ResponseBodyEmitter的子类，用于发送SSE（Server-Send Event）：服务器发送 的事件
        //    SseEmitter emitter = new SseEmitter();
        // 设置超时时间
        SseEmitter emitter = new SseEmitter(10000L);
        // 将当前发射器放到集合中
        clients.add(emitter);
        // 给当前发射器设置事件处理函数

        /*
        当异步请求超时的时候调用的代码。
        该方法在异步请求超时的时候由容器线程调用。
         */
        emitter.onTimeout(() -> clients.remove(emitter));
        /*
        当异步请求结束的时候调用的代码。
        当超时或网络错误而终止异步请求处理的时候，在容器线程调用该方法。
        该方法一般用于检车一个ResponseBodyEmitter实例已经无用了。
         */
        emitter.onCompletion(() -> clients.remove(emitter));
        return emitter;
    }

    /**
     * @param temperature
     * @Async // 异步事件处理
     * @EventListener // 事件监听器，该监听器只接收Temperature事件
     */
    @Async // 异步事件处理
    @EventListener // 事件监听器，该监听器只接收Temperature事件
    public void handleMessage(Temperature temperature) {
        System.out.println("监听到web的调度事件了 -- " + temperature);
        List<SseEmitter> deadEmitters = new ArrayList<>();
        // 遍历发射器集合
        clients.forEach(emitter -> {
            try {
                // 发射器发送温度对象，json类型
                final JSONObject jsonObject = new JSONObject(temperature);
                final String s1 = jsonObject.toString();
                emitter.send(s1);
            } catch (Exception ignore) {
                // 如果抛异常，则将该发射器放到deadEmitters集合中
                deadEmitters.add(emitter);
            }
        });
        // 从clients中移除所有失效的发射器。
        clients.removeAll(deadEmitters);
    }
}

```

**配制异步支持**

```java
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@Configuration
@EnableAsync
public class MyAsyncConfig implements AsyncConfigurer {
    // 为异步调用设置Executor
    @Override
    public Executor getAsyncExecutor() {
        // 使用包含两个核心线程的 ThreadPoolTaskExecutor，可以将核心线程增加到一百  个。
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(100);
        // 如果没有正确配置队列容量，线程池就无法增长。
        // 这是因为程序将转而使用 SynchronousQueue，而这限制了并发。
        executor.setQueueCapacity(5);
        executor.initialize();
        return executor;
    }
    // 为异步执行引发的异常配置异常处理程序。
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        // 此处仅记录异常
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

**入口程序配制**

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo10Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo10Application.class, args);
  }
}
```

resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```

启动服务

Demo10Application

访问网页

http://127.0.0.1:8080/

显示：

```tex
Connection opened
Temperature: 23.53 C
Temperature: 8.66 C
Temperature: 19.28 C
Connection closed
Connection opened
```

控制台输出：

```sh
发送事件。。。
2024-11-27 22:30:50.741  INFO 28324 --- [pool-1-thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@499ff586
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@1ad9aed1
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@6eed6b83
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@141e43fa
```



### 6.3 使用RxJava作为响应式框架

官网地址：

```sh
http://reactivex.io/
```

ReactiveX通常被定义为观察者模式、迭代器模式和函数式编程的组合。

Java平台上有一个用于响应式编程的标准库，即RxJava，是Reactive Extensions(响应式扩展，也称为ReactiveX)的Java实现，目前它并不是唯一的响应式库，还是Akka Streams和Project Reactor.

随着2.x版本的发布，RxJava本身发生了很大的变化。

RxJava是迄今为止应用最广泛的响应式库。

这些API从该库的早期版本以来就没有发生改变。



#### 6.3.1 响应式流

使用Rxjava1.x版本实现生产者与消费者

maven坐标

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

代码

```java
    @Test
    public void rxjava1() {

        //创建发布者
        Observable<String> observable = Observable.create(
                new Observable.OnSubscribe<String>() {
                    @Override
                    public void call(Subscriber<? super String> subscriber) {
                        for (int i = 0; i < 10; i++) {
                            subscriber.onNext("hello null null " + i);
                        }
                        subscriber.onCompleted();
                    }
                });

        //创建订阅者
        observable.subscribe(new Subscriber<String>() {
            @Override

            public void onCompleted() {
                System.out.println("on completed");
            }

            @Override

            public void onError(Throwable throwable) {
                System.out.println("on error :" + throwable.getMessage());
            }

            @Override

            public void onNext(String s) {
                System.out.println("on next: " + s);
            }
        });
    }
```

控制台可以输出：

```java
on next: hello null null 0
on next: hello null null 1
on next: hello null null 2
on next: hello null null 3
on next: hello null null 4
on next: hello null null 5
on next: hello null null 6
on next: hello null null 7
on next: hello null null 8
on next: hello null null 9
on completed
```

创建一个Observable并使其带有一个回调，该回调将在订阅者出现时立即被触发。此时Observer将产生一个字符串值，交将流的结束信号发送给订阅者。

可以使用lambda改进下

```java
    @Test
    public void rxjava1Lambda() {
        //创建发布者，使用Lambda表达式
        Observable.create(
                        subscriber -> {
                            for (int i = 0; i < 10; i++) {
                                subscriber.onNext("hello null null " + i);
                            }
                            subscriber.onCompleted();
                        }
                )
                //指定了调用者
                .subscribe(
                        System.out::println,
                        System.err::println,
                        () -> System.out.println("结束")
                );

    }
```

还是同样的输出：

```tex
hello null null 0
hello null null 1
hello null null 2
hello null null 3
hello null null 4
hello null null 5
hello null null 6
hello null null 7
hello null null 8
hello null null 9
结束
```



#### 6.3.2 just方法

just用来引用元素，使用旧式数组、或者使用from，通过iterable集合创建observable实例

```java
    @Test
    public void testJust() {
        Observable<String> just = Observable.just("1", "2", "3", "4", "5");
        just.subscribe(
                item -> System.out.println(item),
                ex -> System.err.println(ex),
                () -> System.out.println("完成")
        );
    }
```

输出:

```tex
1
2
3
4
5
完成
```

使用from

```java
    @Test
    public void testFrom() {
        Observable<Integer> from = Observable.from(new Integer[]{1, 2, 3, 4, 5});
        from.subscribe(
                itm -> System.out.println("下一个元素是:" + itm),
                ex -> System.err.println("异常信息是:" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是:1
下一个元素是:2
下一个元素是:3
下一个元素是:4
下一个元素是:5
结束
```

#### 6.3.3 from方法

from甚至可以接收一个callable对象的返回。

```java
    @Test
    public void testFromCallable() {
        Observable<String> fromCallable = Observable.fromCallable(() -> "hello null null");

        fromCallable.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello null null
结束
```

或者接收一个Future对象

```java
    @Test
    public void testFeature() {
        Future<String> submit = Executors.newCachedThreadPool().submit(() -> "hello word");

        Observable<String> from = Observable.from(submit);

        from.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello word
结束
```



#### 6.3.4 concat方法

每个传入concat操作符会通过将每个数据项重新发送到下游观察者的方式来消费所有数据项。然后，传入流将被处理，直到发生终止操作（OnComplete()，OnError()），并且其处理顺序会与concat()方法中的顺序保持一致。

```java
    @Test
    public void testConcat() {
        Observable.concat(
                Observable.just("hello "),
                Observable.from(new String[]{"null null"}),
                Observable.just("!")
        ).forEach(
                item -> System.out.println("下一个元素：" + item),
                ex -> System.out.println(ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素：hello 
下一个元素：null null
下一个元素：!
结束
```

>注：虽然异常定义处理很方便，但在发生错误的情奖品下，默认的Subscriber实现仍会抛出`rx.exceptions.OnErrorNotImplementedException。`



#### 6.3.5 interval生成异步序列

RxJava不仅可以生成一个未来的事件，还可以基于时间间隔等生成一个异步事件的序列。

```java
    @Test
    public void testInterval() throws InterruptedException {
        Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素：" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成")
                );
        Thread.sleep(5000);
    }

```

输出：

```tex
下一个元素：0
下一个元素：1
下一个元素：2
下一个元素：3
下一个元素：4
```

每秒输出一人上元素。共5秒.

#### 6.3.6 取消订阅

取消订阅的接口:

```java
public interface Subscription {
    // 订阅取消
    void unsubscribe();
    // 检查 Subscriber是否仍在等待事件
    boolean isUnsubscribed();
}
```

为了便于理解这个取消订阅的接口，可以假调情况：订阅者是唯一对事件感兴趣的一方，并且订阅者会消费它，直到CountDownLatch发出一个外部信号。传入流每100毫秒生成一个新事件，而这些事件会产生无限序号，即0,1,2,3....，以下订阅以及取消订阅

```java
    @Test
    public void testUnsubscribe() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Subscription subscribe = Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素:" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成:")
                );

        new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //如果订阅票据还在订阅状态，则取消订阅
            if (!subscribe.isUnsubscribed()) {
                subscribe.unsubscribe();
            }
            latch.countDown();
        }).start();

        System.out.println("主线程完成");
        latch.await();
        System.out.println("等待结束");
    }
```

输出:

```tex
主线程完成
下一个元素:0
下一个元素:1
等待结束
```

#### 6.3.7 map操作符

RxJava中最常用的操作符就是Map

```java
    /**
     * Returns an Observable that applies a specified function to each item emitted by the source Observable and
     * emits the results of these function applications.
     * <dl>
     *  <dt><b>Backpressure:</b></dt>
     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Observable}'s backpressure
     *  behavior.</dd>
     *  <dt><b>Scheduler:</b></dt>
     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.</dd>
     * </dl>
     *
     * @param <R> the output type
     * @param func
     *            a function to apply to each item emitted by the Observable
     * @return an Observable that emits the items from the source Observable, transformed by the specified
     *         function
     * @see <a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>
     */
    public final <R> Observable<R> map(Func1<? super T, ? extends R> func) {
        return unsafeCreate(new OnSubscribeMap<T, R>(this, func));
    }
```

![image-20241128223247756](.\images\image-20241128223247756.png)

通过对每个数据项应用函数转换（Observable）发出的数据，map执行一对一转换。

输出流具有与输入流相同数量的元素。

```java
    /**
     * Map函数用于对象的转换操作
     */
    @Test
    public void map2() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.map(item -> {
            return item * 100;
        }).forEach(item -> System.out.println(item));
    }
```

输出：

```tex
100
200
300
400
500
600
```



#### 6.3.8 filter操作符

与map操作符相比，filter操作符所产生的元素可能少于它所接收的元素。它只发生那些已经成功通过谓词测试的元素：

![image-20241128223728825](.\images\image-20241128223728825.png)

代码

```java
    @Test
    public void filter() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.filter(item -> {
            return item % 2 == 0;
        }).forEach(item -> System.out.println(item));
    }
```

输出:

```tex
2
4
6
```

#### 6.3.9 count操作符

count操作符自描述性很强，它发出的唯一值代表输入的元素数量。但是，count操作符只在原始流结束时发出结果，因此在处理无限流时，count操作符将不会完成或者返回任何内容：

![image-20241128224032199](.\images\image-20241128224032199.png)

样例：

```java
    @Test
    public void count() {
        List<Integer> dataList = new ArrayList<>(1000);

        for (int i = 0; i < 1000; i++) {
            dataList.add(i);
        }

        Observable.from(dataList)
                //过滤出偶数
                .filter(item -> item % 2 == 0)
                //计数
                .count()
                //输出
                .subscribe(
                        item -> System.out.println("结果计数:" + item)
                );
    }
```

```tex
结果计数:500
```

#### 6.3.10 zip操作符

该操作符具体更复杂的行为，因为它会通过应用zip函数来组合来自两个并行流的值。通常用于填充数据。具特别适合用于部分预期结果从不同源获取的情况：

![image-20241128224507365](.\images\image-20241128224507365.png)

样例代码

```java
    @Test
    public void zip() {
        Observable.zip(Observable.just(1, 2, 3, 4),
                        Observable.just("a", "b", "C", "D"),
                        (a, b) -> a + b)
                .forEach(System.out::println);

    }
```

输出：

```tex
1a
2b
3C
4D
```



#### 6.3.11 concatMap操作符

![image-20241129094319937](.\images\image-20241129094319937.png)





#### 更多

更多的响应式流的图片，可以查看：

```javascript
http://rxmarbles.com/
```

操作符的描述：

```javascript
https://reactivex.io/documentation/operators.html
```





### 6.4 Rxjava+SpringBoot

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>


        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

温度类的信息

```java
package com.nullnull.spring4observer2;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }

}

```

业务实现类

```java

import org.springframework.stereotype.Component;
import rx.Observable;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 业务实现类
 *
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    /**
     * 随机数生成对象
     */
    private final Random random = new Random();

    private final Observable<Temperature> dataStream = Observable
            //随机生成0-int最大值的数
            .range(0, Integer.MAX_VALUE)
            //对以接收到的int数据做处理，Observable
            .concatMap(tick -> Observable.just(tick)
                    //随机延迟5秒内
                    .delay(random.nextInt(5000), TimeUnit.MILLISECONDS)
                    //将随机的流返回为Temperature对象
                    .map(tickKey -> this.probe())
                    //生成生产者
                    .publish()
                    // — 让一个可连接的Observable表现得像一个普通的Observable
                    .refCount()
            );

    private Temperature probe() {
        return new Temperature(16 + random.nextGaussian() * 10);
    }

    public Observable<Temperature> temperatureStream() {
        return dataStream;
    }
}
```

TemplateSensor 使用温度值暴露了一个流，通过使用TemperatureSensor, 可以将每个新的SseEmitter订阅到Observable流，并接收到onNext信号发送给SSE客户端

RxSseEmitter

```java
import org.json.JSONObject;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import rx.Subscriber;

import java.io.IOException;

/**
 * RxSseEmitter 负责从Subscriber接收到的数据转换为JSON响应客户端
 * @author nullnull
 * @since 2023/7/15
 */
public class RxSseEmitter extends SseEmitter {
    static final long SSE_SESSION_TIMEOUT = 30 * 60 * 1000L;
    private final Subscriber<Temperature> subscriber;

    public RxSseEmitter() {
        super(SSE_SESSION_TIMEOUT);
        //订阅一个流
        this.subscriber = new Subscriber<Temperature>() {
            @Override
            public void onNext(Temperature temperature) {
                try {
                    //将数据转换为JSON对象
                    final JSONObject jsonObject = new JSONObject(temperature);
                    final String temperatureJson = jsonObject.toString();
                    System.out.println(temperatureJson);
                    //数据输出
                    RxSseEmitter.this.send(temperatureJson);
                } catch (IOException e) {
                    unsubscribe();
                }
            }

            @Override
            public void onError(Throwable e) {
                System.err.println(e);
            }

            @Override
            public void onCompleted() {
                System.out.println("job done");
            }
        };
        onCompletion(subscriber::unsubscribe);
        onTimeout(subscriber::unsubscribe);
    }


    public Subscriber<Temperature> getSubscriber() {
        return subscriber;
    }
}
```

controller:

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;

/**
 * @author nullnull
 * @since 2023/7/15
 */
@RestController
public class TemperatureController {

    private final TemperatureSensor temperatureSensor;

    public TemperatureController(TemperatureSensor temperatureSensor) {
        this.temperatureSensor = temperatureSensor;
    }

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {
        RxSseEmitter emitter = new RxSseEmitter();
        //数据源对象生产数据，交给订阅者SseEmitter
        temperatureSensor.temperatureStream().subscribe(emitter.getSubscriber());
        return emitter;
    }
}

```

启动入口

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo12Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo12Application.class, args);
  }
}

```

src/main/resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```



启动服务

```javascript
http://127.0.0.1:8080/
```

浏览器出现：

```tex
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```



浏览器访问：

```javascript
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```

当没有订阅时，温度传感器不会探测数据，只有订阅后，才有数据返回。



### 6.5 Spring响应式编程

#### 6.5.1 Sping WebFlux

Spring Framework 5添加新模块`srping-web-reactive`,使用响应式非阻塞引擎支持类型Spring MVC的@controller编程模型

![image-20241129231123927](.\images\image-20241129231123927.png)

Spring web Reactive使用Servlet 3.1 非阻塞特性，也可以运行于非Servlet运行时，如Netty和Undertow等.

对每个运行时适配了一组公共的响应式`ServerHttpRequest`和`ServerHttpResponse`抽象，以`Flux<DataBuffer>`的形式暴露请求和响应，读写完全支持背压。

`spring-core`模块提供了`Encoder`和`Decoder`契约，用于对`Flux`的数据进行序列化和反序列化。

`spring-web`模块添加了JSON和XML的实现，用于web应用或其他SSE流和零拷贝文件传输。

`spring-web-reactive`模块包含了Spring Web Reactive框架以支持@controller编程模型。

重新定义了很多Spring MVC的契约，如`HandlerMapping`和`HandlerAdapter`以支持异步和非阻塞，响应式地操作HTTP的请求和响应。

Sping MVC和Sping Web Reactive不共享任何代码，处理逻辑有很多是共通的。

跟Spring MVC的编程模型一样，但是支持响应式的类型并且以响应式的方式执行。

下述类型都可以作为控制方法的@RequestBody参数来使用

- `Account account`-account在调用控制器之前非阻塞地反序列化。

- `Mono<Account> account`-控制使用`Mono`声明执行的逻辑，当account反序列化后执行。

- `Single<Account> account`-跟`Mono`一样，使用RxJava执行引擎。

- `Flux<Account> accounts`- 输入流场景

- `Observable<Account> accounts`-使用RxJava的输入流。

返回值类型

- `Mono<Account>`-当Mono结束，非阻塞地序列化给定的Account对象
- `Single<Account>`-跟Mono的一样，但是使用RxJava执行引擎。
- `Flux<Account>`-流场景，根据请求content type的不同，有可能是SSE
- `Flux<SseEvent>`-SSE流。
- `Observable<SseEvent>`-使用RxJava执行引擎的SSE流。
- `Mono<void>`-当Mono结束，请求处理结束。
- `void`-当方法返回。请求处理结束。表示同步、非阻塞的控制器方法。
- `Account`-非阻塞的序列化给定的Account，表示同步、非阻塞控制器方法。



#### 6.5.2 WebSocket

最知名的全双工客户端-服务器通信双工协议，即WebSocket。

WebSocket协议通信于2013年引入至Spring框架中，旨在进行异步消息发送，但其实际的实现仍然有一些阻塞操作。

例如，将数据写入I/O或者从I/O读取数据仍然是阻塞操作，因此这二者影响应用程序的性能。

WebFlux模块为WebSocket引入了改进版本的基础设施。WebFlux同时提供客户端和服务器基础设施。

**服务端WebSocket API**

WebFlux提供`webSocketHandler`作为处理WebSocket的连接的核心接口。

该接口有一个名为`handle`的方法，它接收`WebSocketSession`。`WebSocketSession`类表示客户端和服务器之间的成功握手，并提供包括有关握手、会话属性和传入数据流的信息和访问。

使用echo消息响应发送者的示例：

```java
class EchoWebSocketHandler implements WebSocketHandler{
    @Override
    public Mono<Void> handle(WebSocketSession session){
        return session.receive()
            .map(WebSocketMessage::getPayloadAsText)
            .map(tm -> "Echo:" + tm)
            .map(session::textMessage)
            .as(session::send);
    }
}
```

 此代码表示接收入站消息，并转换，然后封装为WebSocketMEssage对象，发送出去。其中发送返回Mono<Void>,当写出完成，该Mono完成。

WebSocketMessage是DataBuffer的包装器，它提供了额外功能，例如将以字节为单位的有效负载转换为文本。

一旦提取了传入消息，我们在该文本前加上“Echo.”后缀，将新文本消息包装在WebSocketMessage中，并使用WebSocketSession#Send方法将其发送回客户端。这里Send方法接受Publish<WebSocketMessage>并返回Mono<void>作为结果。

因此通过使用Reactor API中的as操作符，我们可以将Flux视作为Mono<Void>,并使用session::send作为转换函数。

**客户端 WebSocket API**

与WebSocket模块(基于WebMVC)不同，webFlux还为我们提供了客户端的支持。要发送WebSocket连接请坟，可以使用WebSocketClient类。

```java
public interface WebSocketClient {
    Mono<Void> execute(
   URI url,
        WebSocketHandler handler
   );
    Mono<Void> execute(
   URI url,
        HttpHeaders headers,
        WebSocketHandler handler
   );
}
```

**对比WebFlux WebSocket与Spring WebSocket模块**

Spring WebSocket模块的主要缺点是它阻塞了与I/O的交互，而Spring WebFlux提供了完全无阻塞的写入和读取。

WebFlux模块通过使用响应式流规范和Project Reactor提供了更好的流抽象，旧WebSocket模块中的WebSocketHandler接口只允许一次处理一条消息，此外WebSocketSession#SendMessage方法仅允许以同步方式发送消息。

旧Spring WebSocket模块的一个关键特性就是它与Spring Messaging模块的良好集成，而这能用@Message注解秋场景WebSocket端点。

```java
@Controller
public class GreetingController {
    @MessageMapping("/hello")
    @SendTo("/topic/greetings")
    public Greeting greeting(HelloMessage message) {
   return new Greeting("Hello, " + message.getName() + "!");
   }
}
```

上述代码展示了使用SpringMessaging模块声明的WebSocket端点，遗憾的是。WebFlux模块的WebSocket集成缺少此类支持，为了场景复杂的处理程序，必须提供自己的基础设施。

**作为WebSocket轻量级替代品的响应式SSE**

与重量级WebSocket一起，HTML5引入了一种创建静态连接的新方法，其中服务器能够推送事件。该技术解决了与WebSocket类似的问题。

SSE 不支持二进制编码并将事件限制为UTF-8 编码。这意味着WebSocket 可能对较小的消息 有用，并且在客户端和服务器之间传输的流量较少，因此具有较低的延迟。 

总而言之，SSE 通常是WebSocket 的一个很好的替代品。由于SSE 是HTTP 协议的抽象，因此 WebFlux 支持与典型REST 控制器相同的声明性函数式端点配置和消息转换

### 6.6 RSocket

Rsocket是一个应用通信协议，用于多路复用全双工通信中。可以TCP、WebSocket或其他字节流传输中使用，提供了如下交互模型：

- `Request-Response`-发送一个消息，接收一个消息
- `Request-Stream`-发一个消息，接收返回消息。
- `channel`-双向发送消息流。
- `Fire-and-Forget`-发送单向消息。

建立初始连接之后，就没有客户端服务端的概念了，因为双方地位对称，都可以初始化交互。因此Rocket中只有请求者或者响应者。而没有客户端和服务端的概念，交互称为“请求流”或者简单的称为“请求们”。

Rsocket关键特性和优势：

- 跨网络边界的响应式流定义-对于诸如“请求流”或者“通道”之类的流请求，背压信号在请求者和响应者之间传播，从而允许请求者放慢源处的响应者的速度，从而减少了对网络层拥塞控制的依赖以及在网络级别或者任何级别缓冲。
- Request throttling-可以从两端发送‘LEASE’帧，因此命名为'Leasing'，以及限定给时间内另一端允许的请求总数。租约定期更新。
- Session恢复-这是专为断开连接而设计，用于维护会话的状态。状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况停止生产者减少所需的状态量。
- 对于大消息的分隔和再组装。
- KeepAlived（心跳）

**协议**

Rsocket的优点之一是，它在线路上具有定义明确的行为，并且易于阅读的规范以及某些协议扩展。

**建立连接**

最初，客户端通过一些低级流传输(例如TCP或者UDP)连接到服务器，并向服务器发送"SETUP"帧以设置连接参数。

服务器可以拒绝“SETUP”帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非“SETUP”帧指示使用租凭语义来限制数量。在这种情况下，双方都必须等待另一方的“租约”帧以允许发出请求。

**发送请求**

一量建立连接，双方都可以通过帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一发起请求。这些帧中每一个都将一个消息从请求者传送到响应者。

响应者然后可以返回带有响应消息的“PAYLOAD”帧，并且在“REQUEST_CHANNEL”的情况下，请求者还可以发送带有更多请求消息的“PAYLOAD”帧发出信号。

每一端还可以通过“METADATA_PUSH”帧发送元数据通知，该元数据通知与任何单独请求无与，而与整个连接有关。



**消息格式**

Rsocket消息包含数据与元数据。元数据可以发送路由、安全令牌等。数据和元数据的格式可以不同。每个类的mime类型都在“SETUP”框架中声明，并应用于给定连接上的所有请求。

尽管所有消息都可以具有元数据，但通常每个请求都包含诸如路由之类的元数据，因此包含在请求的第一条消息中。即带有帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一。

协议扩展定义了于用应用程序 的通用元数据格式：

- [composite Metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)-多个独立化的元数据条目。
- [Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)-请求的路由。



**java实现**

RSocket的java实现基于Project Reactor构建。TCP和WebScoket的传输建立在Reactor Netty之上。作为响应式库。Reactor简化了实现协议工作。对于应用程度，自然要配合使用带有声明性运算符和透明性背压支持的“Flux”和"Mono"

Spring Support  

 spring-messaging 模块包含如下内容：

 [RSocketRequester](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-requester) —流式API，使用 io.rsocket.RSocket 对数据和元数据编码解码，发起 请求。

 [Annotated Responders](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-annot-responders) —  @MessageMapping 注解的用于处理请求的处理器方法

## Spring WebFlux核心原理

## 7. Project Reactor

### 7.1 Spring WebFlux与Project Reactor

Spring Framework从版本5开始，基于Project Reactor支持响应式编程。

Project Reactor是用于在JVM上构建非阻塞应用程序的Reactive库，基于Reactive Stream规范。

Project Reactor是生态系统中响应式的基础，并且与Spring密切合作进行开发。

Spring WebFlux要求Project Reactor作为核心依赖项。

**模块**

Project Reactor由Reactor文档中列出的一组模块组成。

主要组件是Reactor Core，其中包括响应类型Flux和它们实现了Reactive Stream的Publisher接口以及一组可应用于这些类型的运算符。

其中一些模块是：

`Reactor Test`——提供一些实用程序来测试响应流。

`Reactor Extra`——提供一些额外的Flux运算符。

`Reactor Netty`——无阻塞且支持背压的TCP，HTTP和UDP的客户端和服务器。

`Reactor Adapter`——用于与其他响应式（如Rxjava和Akka Streams）的适配。

`Reactor Kafka`——用于Kafka的响应式API，作为Kafka的消费者。

**并发模型**

有两种在响应式链中切换执行某些方式：`publishOn`和`subscribeOn`.

区别如下：

- publishOn（Scheduler scheduler）——响应所有后续运算符的执行（只要未指定其他任何内容）。
- subscribeOn(Schedule scheduler) ——根据链中最早的subscribeOn调用，更改整个操作符链所订阅的线程。它不影响随后对PublishOn的调用行为。

Schedulers类用于包含提供执行上下文的静态方法。

- `parallel()`——为并行工作而调整的固定线程池，可创建与CPU内核数量一样多的工作线程池。
- `single()`——单个可重用线程。此方法为所有调用方我不用同一线程，直到调度程序被释放为止。如果您希望按响应专用线程，则可以为每个呼叫使用Schedulers.newSingle()。
- `boundedElastic()`——动态创建一定数量的工作者，它限制了它可以支持线程的数量，并且在线程可用时重新调度要安排的任务。这是包装同步阻塞调用的不错选择。
- `immediate()`——立即在执行线程上运行，而不切换执行上下文。
- `fromExecutorService(ExecutorService)`——可用于从任何现有ExecutorService中创建调度程序。

### 7.2 Project Reactor 1.x 版本

通过与Spring框架的完美集成 以及与Netty的组合，非常适合开发具备异步和非阻塞消息处理的高性能系统。

Reactor 1.x的缺点：

1. 该库没有背夺控制。除了阻塞生产线线程或者跳过事件之外，事件驱动的Reacor 1.x并没有控制背压的方法。
2. 错误处理非常复杂。Reactor 1.x提供了几种错误处理和失败的方法。但使用比较复杂。

### 7.3 Project Reactor 2.x 版本

Reactor 2首开响应式流的先河

![image-20241201224830940](.\images\image-20241201224830940.png)

在Reacotr设计中，最重要的变化是将事件总线和流功能提供到单独的模块中。此外，深度的重新设计使新的Reacotr Stream库完全符合响应式流规范。Reactor团队大大改进了Reacotr的API。



### 7.4 Project Reactor 3.x版本

Reactor事件总线在2中得到了改进。首先负责发送消息的Reactor对象被重命名为EventBus，该模块也经过重新设计以支持响应式流规范。

Reactor3 以java8作为基线，同时Reactor 3.x塑造了Spring 5框架的响应式变种。

该库支持所有常见的背压传播模式：

1. 仅推送：当订阅者通过subscription.request(Long.Max_VALUE)请求有效无限数量的元素时。
2. 仅拉取：当订阅者通过subscription.request(1)仅在收到一个元素后请求下一个元素。
3. 推-拉（混合）当订阅者的实时控制需求，且发布者可以适应所提出的数据消费速度时。

为适配不支持推拉式操作的模型的旧API，Reactor提供了许多老式背压机制，包括缓冲、开窗、消息丢弃、启动异常等。

某些情况下，上述策略甚至可以用于实际需求出现之前预取数据，从而提高系统的响应性。

此外，Reactor API还提供了足够的工具用于消除用户活动的尖峰并防止系统过载。

Project Reactor在设计上脂在对并发透时，因此它不会强制执行任何并发模型。同时，它提供了一组有用的调度程序，它们几乎能以任何形式管理执行线程，如果所提出的所有调度程序都不符合要求，开发人员可以基于完全的低阶控制来创建自己的调度程序。

## 8.Project Reactor核心

### 8.1 在项目中添加Reactor

mavn依赖:

```xml
<dependencies>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <version>3.4.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 8.2 响应类型——Flux和Mono

响应流规范只定义了4个接口：

- Publisher<T>
- Subscriber<T>
- Subscription
- Processor<T,R>

Project Reactor提供了Publish<T>接口的实现，即Flux<T>和Mono<T>

**Flux**

Flux定义了一个通用的响应式流，它可以产生零个、一个或者多个元素，乃至无限元素。有公式

```sh
onNext x 0..N [OnError | OnComplete]
```

**Mono**

与Flux相比,Mono类型定义了一个最多可以生成一个元素的流。有公式如下

```sh
onNext x 0..1 [OnError | OnComplete]
```

当应用程序API最多返回一个元素时，可以使用Mono<T>

它可以轻松替换CompletableFuture<T>，并提供相似的语义，只不过completableFuture在没有发出值的情况下无法正常完成。

`CompletableFuture`全立即开始处理，而Mono在订阅者出现之前什么也不做。

Mono类型不仅提供了大量的响应式操作符，还能够整合到更大 的响应式工作流中。

当需要对已完成的操作通知客户端时，也可以使用Mono。此时可以返回`Mono<void>`类型并在处理完成时发出onComplete的信号，或者在发生异常时返回`onError()`,此时我们不返回任何数据，而发出通知信号，而该信号可以用作进一步计算的触发器。

Mono和Flux可以容易地想到转换。

如: `Flux<T>.collectLIst()`返回`Mono<List<T>>`，而`Mono<T>.flux()`返回`Flux<T>`

**RxJava2响应式类型**

即使RxJava2.x库和Project Reactor具有相同的基础，RxJava2还是有一组不同的响应式发布者。

由于这两个库实现了相同的理念，包含响应操作符、线程管理和错误处理，都非常的相似。因此、或者或少熟悉其中一个库意味着同时熟悉了这两个库。

Rxjava1.x中最初只有`Observable`这一个响应式类型，之后又添加了`Single`和`Completable`类型。

在版本2.具体以下响应式类型：

- `Observable`
- `Flowable`
- `Single`
- `Maybe`
- `Completable`

1. **Observable**

   1. 与Rxjava1.x的Observable语义几乎相同，但是不接收`null`值。
   2. `Observable`即不支持背压，也不实现Publisher接口，所以它与响应式流规范不直接兼容。
   3. Observable类型的开销小于Flowable类型。
   4. 它具有toFlowable方法，可以通过用户选择的背压策略将流转换为Flowable。

2. **Flowable**

   1. Flowable类型是Reactor Flux类型的直接对应物。
   2. 实现了响应式流的Publisher，可以应用由Project Reactor实现的响应式工作流中。困为API消费PUblisher类型的参数，而不是针对特定的Flux类型。

3. **Single**

   1. Single类型表示生成仅生成一个元素的流。
   2. 不继承Publisher接口。
   3. 具有toFlowable方法。
   4. 不需要背压策略。
   5. 相较于Reactor中的Mono类型，Single更好地表示了CompletableFuture的主义。但是在订阅发生之前它仍不会开始处理。

4. **Maybe**

   1. 实现了与Reactor中的Mono类型相同的语义，但是不兼容响应式流，因为Maybe不实现Publisher接口。
   2. 具有toFlowable方法，以兼容响应式流规范。

5. **Completable**

   1. 只能触发OnError或者OnComplete信号，但不能产生OnNext信号。
   2. 不实现Publisher接口，但是具有toFlowable方法。
   3. 它对应不能生成OnNext信号的Mono<Void>类型。

   

   总而言之，要与其他兼容响应式流的代码集成，应将RxJava类型转换为Flowable类型。

   

   

   

   ### 8.3 创建Flux和Mono序列

   Flux和Mono提供了许多工厂方法，可以根据已有的数据流创建响应流。
   
   如：可以使用对象引用或集合创建Flux，甚至可以简单地用数字范围来创建。
   
   ```java
     /**
        * 使用元素进行构建
        */
       @Test
       public void just() {
           Flux<String> just = Flux.just("hello", "nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   ```
   
   使用数组构建
   
   ```java
       @Test
       public void fromArray() {
           Flux<String> arrayFlux = Flux.fromArray(new String[]{"hello", "nullnull", "dd"});
           arrayFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   dd
   ```
   
   使用集合构建
   
   ```java
       @Test
       public void fromIterable() {
           Flux<Integer> interFlux = Flux.fromIterable(Arrays.asList(1, 2, 3, 4, 5));
           interFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   1
   2
   3
   4
   5
   ```
   
   使用range生成
   
   ```java
       @Test
       public void range() {
           Flux<Integer> range = Flux.range(100, 5);
           range.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   100
   101
   102
   103
   104
   ```

   

   **创建Mono序列**
   
   Mono提供类似的工厂方法，但订针对单个元素。它经常与nullable类型和Optional类型一起使用。
   
   ```java
       @Test
       public void just()
       {
           Mono<String> just = Mono.just("nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:

   ```tex
   nullnull
   ```
   
   使用`justOrEmpty`
   
   ```java
       @Test
       public void justOrEmpty() {
           Mono<String> objectMono = Mono.justOrEmpty(null);
           objectMono.subscribe(System.out::println);
       }
   ```

   此啥也不会输出
   
   避免空指针，使用Option对象
   
   ```java
       @Test
       public void justOrEmptyOption()
       {
           Mono<String> objectMono = Mono.justOrEmpty(Optional.empty());
           objectMono.subscribe(System.out::println);
       }
   ```

   同样的，这个啥也不会输出.
   
   点击`justOrEmpty`方法的源码发现，以上两种参数调用，都是同一个方法，在内部做了判断。
   
   ```java
   	public static <T> Mono<T> justOrEmpty(@Nullable Optional<? extends T> data) {
   		return data != null && data.isPresent() ? just(data.get()) : empty();
   	}
   ```

   同时Mono对于包装异步操作非常有用。
   
   Mono提供了：
   
   - `fromCallable(Callable)`
   - `fromRunnable(Runnable)`
   - `fromSupplier(Supplier)`
   - `fromFuture(CompletableFuture)`
   - `fromCompletionStage(CompletionStage)`
   
   样例：使用Mono包装Http请求：
   
   ```java
       @Test
       public void monoHttpRequest() throws IOException {
           Mono.fromCallable(() -> httpRequest()).subscribe(System.out::println);
       }
   
       @Test
       public void monoHttpRequestLambda() {
           Mono.fromCallable(this::httpRequest).subscribe(System.out::println);
       }
   
       private String httpRequest() throws IOException {
           URL url = new URL("https://www.baidu.com");
           URLConnection urlConnection = url.openConnection();
           urlConnection.connect();
   
           try (InputStream inputStream = urlConnection.getInputStream();
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);) {
               String tmp = null;
   
               StringBuilder result = new StringBuilder();
   
               while ((tmp = bufferedReader.readLine()) != null) {
                   result.append(tmp).append("\n");
               }
   
               return result.toString();
           } catch (IOException e) {
               throw e;
           }
       }
   ```
   
   输出：
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   ```
   
   带有error以及完成的信号处理
   
   ```java
       /**
        * 异常及完成信号处理
        */
       @Test
       public void monoHttpRequestLambdaFull() {
           Mono.fromCallable(this::httpRequest).subscribe(
                   item -> System.out.println(item),
                   ex -> System.out.println("异常信息:" + ex.toString()),
                   () -> System.out.println("请求完成")
           );
       }
   ```
   
   输出:
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   请求完成
   ```

   Flux和Mono都可以使用`from(Publish<T> p)`工厂方法适配任何其他Publisher实例。
   
   flux使用Publisher
   
   ```java
       @Test
       public void publisher() {
           Flux.from((subscriber) -> {
                       for (int i = 0; i < 10; i++) {
                           subscriber.onNext("hello" + i);
                       }
                       subscriber.onComplete();
                   })
                   .subscribe(
                           System.out::println,
                           System.out::println,
                           () -> System.out.println("处理结果")
                   );
       }
   ```
   
   输出：
   
   ```tex
   hello0
   hello1
   hello2
   hello3
   hello4
   hello5
   hello6
   hello7
   hello8
   hello9
   处理结果
   ```
   
   两种响应式类型都提供了简单的方法来创建常用的空流以及只包含错误的流：
   
   ```java
           //empty工厂方法，它们分别生成Flux或者Mono的空实例。
           Flux<String> empty = Flux.empty();
           //never方法创建一个永远不会发出完成、数据、或者错误等信号的流
           Flux<String> never = Flux.never();
           //error(Throwable)工厂方法创建一个序列，该序列在订阅时始终通过每个订阅者的onError(....)方法传播错误。
           // 由于错误是在Flux或者Mono声明期间被创建，因此每个订阅者都会收到相同的Throwable实例。
           Mono<String> error = Mono.error(new RuntimeException("错误对象"));
   ```
   
   defer工厂方法创建一个序列，并在订阅时决定其行为，可以为不同的订阅者生成 不同的数据：
   
   ```java
      public boolean isValidSeed(String seed) {
           System.out.println("调用了isValidSeed方法");
           return true;
       }
   
       public String getData(String seed) {
           try {
               System.out.println("方法执行：5s");
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           return "echo:" + seed;
       }
   
       public Mono<String> requestData(String seed) {
           if (isValidSeed(seed)) {
               return Mono.fromCallable(() -> getData(seed));
           } else {
               return Mono.error(new RuntimeException("Invalid seed value"));
           }
       }
   
       public Mono<String> requestDeferData(String seed) {
           Mono<String> data;
           if (isValidSeed(seed)) {
               data = Mono.fromCallable(() -> getData(seed));
           } else {
               data = Mono.error(new RuntimeException("Invalid seed value"));
           }
           return Mono.defer(() -> data);
       }
   
       /**
        * 仅调用requestData方法
        */
       @Test
       public void request() {
           requestData("nullnull");
       }
   
       /**
        * 调用requestDeferData方法不订阅
        */
       @Test
       public void requestDeferData() {
           requestDeferData("nullnull");
       }
   
       /**
        * 调用requestDeferData并订阅
        */
       @Test
       public void requestDeferDataSubscribe() {
           requestDeferData("nullnull").subscribe();
       }
   ```

   首先执行`request`
   
   可以看到输出:

   ```java
   调用了isValidSeed方法
   ```

   而`getData`方法并未被触发执行

   
   
   再执行`requestDeferData`方法

   ```java
   调用了isValidSeed方法
   ```

   还是同样的结果，仅仅仅证方法被执行，而`getData`方法并未被触发执行

   
   
   最后执行带有订阅的方法`requestDeferDataSubscribe`
   
   ```tex
   调用了isValidSeed方法
   方法执行：5s
   ```
   
   此时`getData`方法，在被订阅后，被执行。

总结：

1. Project Reactor只需要使用`just`方法枚举元素就可以创建Flux和Mono序列。
2. 可以使用justOrEmpty轻松的将Optional包装到Mono中，或者使用fromSupplier方法将Supplier包装到Mono中。
3. 可以使用fromFuture方法映射Future，或者使用fromRunnable工厂方法映射Runnable.
4. 可以使用fromArray或者fromIterator方法将数组或者Iterator集合转换为Flux流。



### 8.4 订阅响应式流

Flux和Mono提供对subscribe()方法基于lambda的重载，简化了订阅的开发。

subscribe方法的所有重载都返回Disposable接口的实例，可以用于取消基础的订阅过程。

在重载方法1-4中，订阅发出无界数据（Long.MAX_VALUE）的请求。

注意：简单订阅请求无界数据（Long.MAX_VALUE）的选项有时可能迫使生产者完成大量工作以满足需求。因此，如果生产者适合处理有界数据，建议使用订阅对象或者应用请求限制操作符来控制需求。

```java
//重载方法1
//订阅流的最简单的方法，忽略所有信号，通常用于触发具有副作用的流处理。
public final Disposable subscribe();


//重载方法2
//对每个值(onNext信号)调用DataCompsumer，不处理OnError和onComplete信号
public final Disposable subscribe(Consumer<? super T> consumer);

//重载方法3
//与重载方法2相同，处理OnError信号，忽略onComplete信号
public final Disposable subscribe(@Nullable Consumer<? super T> consumer, Consumer<? super Throwable> errorConsumer) 
    
    
//重载方法4
//与方法3相同，处理onComplete信号。
public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer) ;

//重载方法5
//消费响应式流中所有元素，包括错误处理和完成信号，重要的是，这种重载方法能通过请求足够数量的数据来控制订阅，当然请求数量仍然可以是Long.MAX_VALUE.
	public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer,
			@Nullable Consumer<? super Subscription> subscriptionConsumer);

//重载方法6,此方法最通用，但很少被用到
//订阅序列的通用方法，可以为Subscribe的实现提供所需的行为
public final void subscribe(Subscriber<? super T> actual) ;

```

subscribe案例1

```java
    @Test
    public void subscribe() {
        Flux.just("hello", "nullnull", "kk")
                .subscribe(
                        data -> System.out.println("onNext:" + data),
                        ex -> System.out.println("异常信息:" + ex),
                        () -> System.out.println("完成信号")
                );
    }
```

subscribe最基本的用法,输出:

```tex
onNext:hello
onNext:nullnull
onNext:kk
完成信号
```

添副作用

```java
    @Test
    public void subscribeDoOnNext() {
        Flux.range(10, 20)
                //过滤能被5整除的数
                .filter(item -> item % 5 == 0)
                //数据转换，添加前缀v，并转换为字符串
                .map(num -> "v->" + num)
                // 添副作用,用于在发送新的数据项之前执行一些操作，但它不改变数据流本身
                .doOnNext(System.out::println)
                .subscribe();
    }
```

输出:

```tex
v->10
v->15
v->20
v->25
```

**只处理正常情况**

```java
    @Test
    public void subscribeOk() {
        Flux.range(1, 20)
                .filter(item -> item % 4 == 0)
                .subscribe(System.out::println);
    }
```

输出：

```tex
4
8
12
16
20
```

**添加异常处理**

```java
    @Test
    public void subscribeException() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onError(new IllegalArgumentException("添加错误"));
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex)
        );
    }
```

输出:

```tex
tem:0
item:1
item:2
item:3
item:4
异常情况:java.lang.IllegalArgumentException: 添加错误
```

**添加完成事件**

```java
    @Test
    public void subscribeFinish() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onComplete();
            ;
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex),
                () -> System.out.println("处理完成")
        );
    }
```

输出：

```tex
item:0
item:1
item:2
item:3
item:4
处理完成
```

**订阅成功就取消**

```java
    @Test
    public void subscribeCancel() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        //一订阅成功就取消订阅
                        subscription -> subscription.cancel()
                );
    }
```

控制台没有任何的输出

**订阅指定数量**

```java
    @Test
    public void subscribeRequest() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        subscription -> {
                            //订阅响应式流5个元素
                            subscription.request(5);
                            //取消订阅
                            subscription.cancel();
                        }
                );
    }
```

输出：

```tex
onNext:1
onNext:2
onNext:3
onNext:4
onNext:5
```

此处没有收到onComplete信号，因为订阅者在流完成之前取消了订阅。

注意：

1. 响应式流可以由生产者完成（使用onError或者OnComplete信号）
2. 响应流也可以由订阅者完成，通过Subscription实例进行取消。
3. Disposable实例也可用于取消。

**Disposable使用**

通常，Disposable实例不是由订阅者使用，而是由更上一级的抽象的代码使用。

如在主线程通过调用Disposable来取消流处理。

```java
    @Test
    public void disposable() throws InterruptedException {
        Disposable disposable = Flux.interval(Duration.ofMillis(100)).subscribe(data -> System.out.println("onNext:" + data));
        Thread.sleep(2000L);
        //主线程取消订阅
        disposable.dispose();
    }
```

输出:

```tex
onNext:0
onNext:1
onNext:2
onNext:3
onNext:4
onNext:5
onNext:6
onNext:7
onNext:8
onNext:9
onNext:10
onNext:11
onNext:12
onNext:13
onNext:14
onNext:15
onNext:16
onNext:17
onNext:18
onNext:19
```

**自定义订阅者**

如果默认的`subscribe(...)`方法不提供所需的多种功能，则可以实现自己的Subscriber，直接从响应式流规范实现Subscriber接口，并将其订阅到流.

```java
    @Test
    public void selfSubscriber() {
        Subscriber<String> subscriber = new Subscriber<String>() {

            private volatile Subscription subscription;

            @Override
            public void onSubscribe(Subscription s) {
                subscription = s;
                System.out.println("订阅请求1个元素");
                subscription.request(1);
            }

            @Override
            public void onNext(String s) {
                System.out.println("OnNext 接收到1个元素:" + s);
                System.out.println("OnNext 再请求1个元素");
                subscription.request(1);
            }

            @Override
            public void onError(Throwable t) {
                System.out.println("发生错误:" + t);
            }

            @Override
            public void onComplete() {
                System.out.println("成功完成");
            }
        };

        Flux<String> dataTest = Flux.just("hello","nullnull","dd");
        dataTest.subscribe(subscriber);
    }
```

输出：

```tex
订阅请求1个元素
OnNext 接收到1个元素:hello
OnNext 再请求1个元素
OnNext 接收到1个元素:nullnull
OnNext 再请求1个元素
OnNext 接收到1个元素:dd
OnNext 再请求1个元素
成功完成
```

但是，此订阅方法是不对的，它打破了线性代码的封装，也容易出错。

最困难的部分是需要自己管理背压并正确实现订阅者所有的TCK要求。

在前面的示例中，打破了有关订阅验证和取消的这几个TCK。

建议扩展Project Reactor提供的BaseSubscriber类。在这种情况下，订阅者如下所示。

```java
    @Test
    public void recommend() {
        BaseSubscriber<String> baseSubscriber = new BaseSubscriber<String>() {
            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                System.out.println("订阅成功,开始请求第一个元素");
                subscription.request(1);
            }

            @Override
            protected void hookOnNext(String value) {
                System.out.println("hookOnNext-->" + value);
                System.out.println("请求下一个元素");
                request(1);
            }

            @Override
            protected void hookOnComplete() {
                System.out.println("成功完成");
            }

            @Override
            protected void hookOnError(Throwable throwable) {
                System.out.println("发生错误");
            }
        };
        Flux<String> dataTest = Flux.just("hello", "nullnull", "dd");
        dataTest.subscribe(baseSubscriber);
    }
```

输出:

```tex
订阅成功,开始请求第一个元素
hookOnNext-->hello
请求下一个元素
hookOnNext-->nullnull
请求下一个元素
hookOnNext-->dd
请求下一个元素
成功完成
```

使用BaseSubscriber，实现符合TCK的订阅者更为容易。

订阅者在本身拥有生命周期管理的宝贵资源时，会需要这种方法。



### 8.5 用操作符转换响应式流

使用响应式流，除了需要能够创建和使用流，还必须能够完美地转换和操作。

Project Reactor为几乎所胡所需的响应式转换提供了工具，通常可以对库的功能特性做如下分类：

1. 转换现在序列
2. 查看序列的处理方法。
3. 拆分和聚合Flux序列
4. 处理时间。
5. 同步返回数据。

**常规操作符**

1. 映射响应式流元素。

转换序列的最自然方式是将每个元素映射到一个新值。

`Flux`和`Mono`给出了`map`操作符，具有`map(Function<T,R>)`签名的方法可以用于逐个处理元素。

当操作符元素的类型从T转换为R时，整个序列的类型将改变。

![image-20241203230950044](.\images\image-20241203230950044.png)

Mono类的map操作符具有类似的行为。

`cast(Class c)`操作符将流的元素强制转换为目标类。

实现`case(Class c)`操作符的最简单方法是使用`map()`操作符。

Flux类的

```java
	public final <E> Flux<E> cast(Class<E> clazz) {
		Objects.requireNonNull(clazz, "clazz");
		return map(clazz::cast);
	}
```

**index操作符**

index操作符用于枚举序列中的元素。方法签名为:`public final Flux<Tuple2<Long, T>> index()`

```java
    @Test
    public void testIndex() {
        Flux.range(1, 10)
                //数据值转换，添加前缀ds->
                .map(item -> "ds->" + item)
                //给每个值生成一个序列，从0开始
                .index()
                //订阅输出
                .subscribe(System.out::println);
    }
```

输出：

```tex
[0,ds->1]
[1,ds->2]
[2,ds->3]
[3,ds->4]
[4,ds->5]
[5,ds->6]
[6,ds->7]
[7,ds->8]
[8,ds->9]
[9,ds->10]
```

**timestamp操作符**

```java
    @Test
    public void testTimestamp() throws InterruptedException {
        Flux
                //每50毫秒产生一个元素
                .interval(Duration.ofMillis(50))
                //数值转换
                .map(item -> "ds->" + item)
                //生成时间戳
                .timestamp()
                //订阅处理
                .subscribe(item -> System.out.println("OnNext:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("完成信号")
                );

        Thread.sleep(500);
    }
```

输出：

```tex
OnNext:[1733239459690,ds->0]
OnNext:[1733239459737,ds->1]
OnNext:[1733239459784,ds->2]
OnNext:[1733239459831,ds->3]
OnNext:[1733239459878,ds->4]
OnNext:[1733239459942,ds->5]
OnNext:[1733239459990,ds->6]
OnNext:[1733239460038,ds->7]
OnNext:[1733239460084,ds->8]
OnNext:[1733239460131,ds->9]
```



### 8.5.2 过滤响应式流

Project Reactor包含过滤元素的各种操作符。

1. `filter`操作符仅传递满足条件的元素。
2. `ignoreElements`操作符返回`Mono<T>`并过滤所有元素。结果序列仅在原始序列结束后结束。
3. `take(n)`操作符限制所获取的元素，该方法忽略除前n个元素之外的所有元素。
4. `takeLast`仅返回最后一个元素。
5. `takeUntil(Predicate)`传递一个元素直到满足某个条。
6. `elementAt(n)`只可用于获取序列的第n个元素。
7. `single`操作符从数据源发出单个数据项，也为空数据源发出`NoSuchElementException`错误信号,或者为具有多个元素的数据源发出IndexOutOfBoundsExceptionw信号，它不仅可以基于一定数量来获取或跳过元素，还可以通过带有`Duration`的`skip(Duration)`或者`take(Duration)`操作符
8. `TakeUntilOther(Publisher)`或`skipUntilOther(Puhlisher)`操作符，可以或获取一个元素，直到某些消息从另一个流到达。

样例1：

该工作流，首先开始一个流的处理，然后从其他流收到特定事件后，停止该流的处理。

```java

    @Test
    public void testStartStop() throws InterruptedException {
        System.out.println("start");
        //延迟1秒后开始触发
        Mono<String> start = Mono.just("start").delayElement(Duration.ofSeconds(1));
        //在延迟4秒后停止
        Mono<String> stop = Mono.just("stop").delayElement(Duration.ofSeconds(4));
        Flux.interval(Duration.ofMillis(500))
                .map(item -> "fluxElement:" + item)
                .skipUntilOther(start)
                .takeUntilOther(stop)
                .subscribe(System.out::println);
        Thread.sleep(6000);

        System.out.println("finish");
    }
```

输出:

```tex
start
fluxElement:2
fluxElement:3
fluxElement:4
fluxElement:5
fluxElement:6
fluxElement:7
finish
```

查看弹珠图

![image-20241204223422077](.\images\image-20241204223422077.png)



### 8.5.3 收集响应式流

收集列表中的所有元素，并使用`Flux.CollectionList()`和`Flux.CollectSortedList()`将结果集合处理为Mono流是可以的，`Flux.CollectSortedList()`不仅会收集元素，还会对它们进行排序

```java
    @Test
    public void testCollectSortedList() {
        Flux.just(1, 3, 2, 5, 6, 2, 4, 1)
                .collectSortedList(Comparator.reverseOrder())
                .subscribe(System.out::println);
    }
```

输出：

```te
[6, 5, 4, 3, 2, 2, 1, 1]
```

> 注意：收集集合中的序列元素可能非常的耗费资源，当序列具有许多元素时这种现象成为突出。
>
> 此外，尝试在无限流上收集数据可能消耗所有可用的内存。

Project Reactor不仅可以将Flux元素收集到List，还可以收集以下内容：

1. 使用`CollectMap`操作符的映射（`Map<K,T>`）;
2. 使用`CollectMultimap`操作符的多映射（`Map<k,Collection<T>>`）；
3. `Flux.collect(Collector)`操作符收集到任何实现了`java.util.stream.Collector`的数据结构。
4. `Flux`和Mono都有repeat()方法和repeat(times)方法，这两种方法可以针对传入序列进行循环操作。
5. `defaultIfEmpty(T)`是另一个简洁的方法，它能为空Flux或者Mono提供默认值。
6. `Flux.distinct()`仅传递之前未在流中遇到过的元素。但是因为此方法会跟踪所有唯一性的元素，所以(尤其涉及高基数数据时)请谨慎使用，distinct方法具有重载方法，可以为重复跟踪提供自定义算法。因此有时可以手动优化distinct操作符的资源使用。
7. `Flux.distinctUntilChange()`操作符没有此限制，可以用于无限流以删除出现在不间断行中重复项。

>高基数是具有非常罕见元素或唯一性元素的数据，如身份编号和用户名就是典型的高基数数据，而枚举或者来自小弄固定字典的值就不是

**`collectMap`操作符的使用**

```java
    @Test
    public void testCollectMap() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(new Function<Integer, String>() {
                    @Override
                    public String apply(Integer integer) {
                        return "key:" + integer;
                    }
                })
                .subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=2, key:1=1, key:6=6, key:5=5, key:4=4, key:3=3}
```

或者使用lambda表达式

```java
    @Test
    public void testCollectMap1() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item)
                .subscribe(System.out::println);
    }
```

`collectMap`两个参数的使用，也就是分别对Key和分别进行转化操作

```java
    @Test
    public void testCollectMap2() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item, value -> "value:" + value)
                .subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=value:2, key:1=value:1, key:6=value:6, key:5=value:5, key:4=value:4, key:3=value:3}
```

`collectMap`三个参数的使用，也就是分别对Key和分别进行转化操作，可以在集合中，额外的添加元素

```java
    @Test
    public void testCollectMap3() {
        Flux.just(1, 2, 3, 4, 5, 6)
                .collectMap(item -> "key:" + item, value -> "value:" + value, () -> {
                    Map<String, String> result = new HashMap<>();
                    for (int i = 0; i < 3; i++) {
                        result.put("ik-" + i, "iv" + i);
                    }
                    return result;
                })
                .subscribe(System.out::println);
    }
```

输出:

```tex
{ik-0=iv0, key:2=value:2, key:1=value:1, ik-2=iv2, ik-1=iv1, key:6=value:6, key:5=value:5, key:4=value:4, key:3=value:3}
```



**`collectMultiMap`操作符的使用**

```java
    @Test
    public void testCollectMultiMap() {
        Flux.just(1, 2, 3)
                .collectMultimap(key -> "key:" + key, value -> {
                    List<String> valueResult = new ArrayList<>();
                    for (int i = 0; i < value; i++) {
                        valueResult.add("vs:" + i);
                    }
                    return valueResult;
                }).subscribe(System.out::println);
    }
```

输出：

```tex
{key:2=[[vs:0, vs:1]], key:1=[[vs:0]], key:3=[[vs:0, vs:1, vs:2]]}
```

三个参数使用;

```java
    @Test
    public void testCollectMultiMap2() {
        Flux.just(1, 2, 3)
                .collectMultimap(key -> "key:" + key, value -> {
                            List<String> valueResult = new ArrayList<>();
                            for (int i = 0; i < value; i++) {
                                valueResult.add("vs:" + i);
                            }
                            return valueResult;
                        },
                        () -> {
                            Map map = new HashMap<String, List<String>>();
                            for (int i = 0; i < 2; i++) {
                                map.put("add:" + i, Arrays.asList("addv" + i));
                            }
                            return map;
                        }

                ).subscribe(System.out::println);
    }
```

输出:

```tex
{add:0=[addv0], key:2=[[vs:0, vs:1]], key:1=[[vs:0]], key:3=[[vs:0, vs:1, vs:2]], add:1=[addv1]}
```

**repeat操作符的使用**

```java
    @Test
    public void repeat() {
        Flux.just(1, 2, 3)
                //此数据会打印3遍，1次原始数据，2次重复数据
                .repeat(2)
                .subscribe(System.out::println);
    }
```

输出：

```
1
2
3
1
2
3
1
2
3
```

**defaultIfEmpty操作符的使用**

```java
    @Test
    public void defaultIfEmpty() {
        Flux.empty().defaultIfEmpty("nullnull").subscribe(System.out::println);
    }
```

输出：

```tex
nullnull
```

**distinct操作符**

```java
    @Test
    public void distinct() {
        Flux.just(1, 2)
                .repeat(2)
                .distinct()
                .subscribe(System.out::println);
    }
```

经过去重操作后，数据只剩下了两个,此去重是全局去重

输出：

```tex
1
2
```

**distinctUntilChanged操作符的使用**

对于非连续性重复数据是没有效果的

```java
    @Test
    public void distinctUntilChanged()
    {
        Flux.just(1,2)
                .repeat(2)
                .distinctUntilChanged()
                .subscribe(System.out::println);
    }

```

输出：

```tex
1
2
1
2
1
2
```

连续重复测试

```java
    @Test
    public void distinctUntilChanged2()
    {
        Flux.just(1,1,2,2,3,3,1,1)
                .distinctUntilChanged()
                .subscribe(System.out::println);

    }
```

输出:

```tex
1
2
3
1
```

![image-20241204231856554](.\images\image-20241204231856554.png)

### 8.5.4 裁减流中元素

Project Reactor可以：

1. 统计流中元素的数量
2. 检查所有元素是否具有`Flux.all(Predicate)`所需的属性。
3. 使用`Flux.any(Predicate)`操作会检查是否至少有一个元素具有所需属性。
4. 使用`hasElements`操作符检查流中是否包含多个元素；
5. 使用`hasElement`操作符检查流中是否包含某个所需的元素。短路逻辑，在元素与值匹配时立即返回true.
6. `any`操作符不仅可以检查元素的相等性，还可以通过提供自定义predicate实例检查任何其他属性。



**any**

检查序列是是否包含偶数

```java
    @Test
    public void any() {
        Flux.just(1, 2, 3)
                //检查是否包含偶数
                .any(item -> item % 2 == 0)
                .subscribe(System.out::println);
    }
```

输出：

```tex
true
```

**reduce**

Flux类

能使用自定义逻辑来裁剪序列，`reduce`操作符通常需要一个初始值和一个函数，而该函数会将结果与当前步的元素组合在一起

```java
    @Test
    public void reduce() {
        Flux.range(1, 5)
                .reduce(0, (item1, item2) -> item1 + item2)
                .subscribe(System.out::println);
    }
```

输出：

```tex
15
```

reduce操作符只生成最终结果。加点代码，看下中间的过程

```java
    @Test
    public void reduce() {
        Flux.range(1, 5)
                .reduce(0, (item1, item2) ->
                        {
                            System.out.println("item1:" + item1 + ",item2:" + item2);
                            return item1 + item2;
                        }
                )
                .subscribe(System.out::println);
    }
```

输出:

```tex
item1:0,item2:1
item1:1,item2:2
item1:3,item2:3
item1:6,item2:4
item1:10,item2:5
15
```

**scan操作符**

scanr操作符在进行聚合时，可以向下游发送中间结果。

```java
    @Test
    public void scan() {
        Flux.range(1, 5)
                .scan(0, (num1, num2) -> num1 + num2)
                .subscribe(System.out::println);
    }
```

输出：

```tex
0
1
3
6
10
15
```

scan操作符对于许多需要获取处理中事件相关信息的应用程序有用。

可以使用scan计算移动的平均值

```java
    @Test
    public void scanAvg() {
        int arrLength = 3;
        Flux.range(1, 10)
                .index()
                //scan第一个发射的元素是它的初始值
                .scan(new int[arrLength], (arr, entry) -> {
                    arr[(int) (entry.getT1() % arrLength)] = entry.getT2();
                    return arr;
                })
                //当窗口的数据被填满后，才开始计算平均值
                .skip(arrLength)
                .map(array -> Arrays.stream(array).sum() * 1.0 / arrLength)
                .subscribe(System.out::println);
    }
```

输出：

```tex
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
```

**then**

Mono和Flux流有then、thenMany和thenEmpty操作符，它们在上游完成时完成。

上游完成处理后，这些操作符可以用于触发新流，订阅是对于新流的。

```java
    @Test
    public void thenMany() {
        Flux.just(1, 2, 3)
                .doOnNext(item -> System.out.println("输出：" + item))
                .thenMany(Flux.just(4, 5, 6))
                .subscribe(System.out::println);
    }
```

输出：

```tex
输出：1
输出：2
输出：3
4
5
6
```

即使1、2、3是由流生成和处理的，subscribe方法中lambda也只接收4、5、6





### 8.5.5 组合响应式流

Project Reactor可以将许多传入流组成合一个传出流。

指定的操作符虽然有许多重载方法，但都会执行以下转换。

1. `concat`操作符通过向下流转发接收的元素来连接所有数据源，当操作符连接两个流时，它首先消费并重新发送第一个流的元素，然后对第二个执行相同的操作。
2. `merge`操作符将来自上游序列的数据合并到一个下游序列中。与concat操作符不同，上游数据源是立即（同时）被 订阅的。
3. `zip`操作符订阅所有上游，等待所有数据源发出第一个元素，然后将接收到的元素组合到一个输出序列中。
4. `comineLatest`操作符与`zip`操作符的工作方式类似，但是，只要至少一个上游数据源发出一个值，它就会生成新的序列。

**concat操作符**

```java
    @Test
    public void concat() throws InterruptedException {
        Flux.concat(
                        Flux.range(10, 5).delayElements(Duration.ofMillis(100))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅1:")),
                        Flux.range(100, 5).delayElements(Duration.ofMillis(110))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
                )
                .subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出:

```tex
当前被订阅1:
10
11
12
13
14
当前被订阅2
100
101
102
103
104
```

可以发现，此操作符是按顺序一个订阅完成，再订阅第二个。

**merge操作符**

```java
    @Test
    public void merge() throws InterruptedException {
        Flux.merge(
                        Flux.range(10, 5).delayElements(Duration.ofMillis(100))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅1:")),
                        Flux.range(100, 5).delayElements(Duration.ofMillis(110))
                                .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
                )
                .subscribe((t) -> System.out.println("onNext:" + t),
                        e -> System.out.println("exception" + e),
                        () -> System.out.println("finish")
                );
        Thread.sleep(2000);
    }
```

输出:

```tex
当前被订阅1:
当前被订阅2
onNext:10
onNext:100
onNext:11
onNext:101
onNext:12
onNext:102
onNext:13
onNext:103
onNext:14
onNext:104
finish
```

可以发现两个流同步被订阅。并且同时向下游发送了数据。

**zip操作符**

```java
    @Test
    public void zip() throws InterruptedException {
        Flux.zip(
                Flux.range(0, 6)
                        .delayElements(Duration.ofMillis(100))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅1")),
                Flux.range(100, 5)
                        .delayElements(Duration.ofMillis(500))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅2"))
        ).subscribe((t) -> System.out.println("二元组：t1：" + t.getT1() + ",t2:" + t.getT2()),
                e -> System.out.println("error" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
当前被订阅1
当前被订阅2
二元组：t1：0,t2:100
二元组：t1：1,t2:101
二元组：t1：2,t2:102
二元组：t1：3,t2:103
二元组：t1：4,t2:104
finish
```

可以发现个流被同时订阅，并且只有两个流中的数据都到达了，才被送到下游。

![image-20241205093139538](.\images\image-20241205093139538.png)



**combineLatest操作符**

```java
    @Test
    public void combineLatest() throws InterruptedException {
        Flux.combineLatest(
                Flux.range(0, 6)
                        .delayElements(Duration.ofMillis(100))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅1")),
                Flux.range(100, 5)
                        .delayElements(Duration.ofMillis(500))
                        .doOnSubscribe((t) -> System.out.println("当前被订阅2")
                        ),
                (var1, var2) -> "数据1:" + var1 + ",数据2:" + var2
        ).subscribe((t) -> System.out.println("二元组" + t),
                e -> System.out.println("error" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
当前被订阅1
当前被订阅2
二元组数据1:3,数据2:100
二元组数据1:4,数据2:100
二元组数据1:5,数据2:100
二元组数据1:5,数据2:101
二元组数据1:5,数据2:102
二元组数据1:5,数据2:103
二元组数据1:5,数据2:104
finish
```



弹珠图:

![image-20241205094009730](.\images\image-20241205094009730.png)



### 8.5.6 流元素批处理

Project Reactor支持以下几种方式对流元素(Flux<T>)执行批处理

1. 将元素缓冲（buffering）到容器(如list)中，结果流的类型为Flux<List<T>>.
2. 通过开窗（windowing）方式，将元素加入诸如Flux<Flux<T>>等流中，请注意，现在流信息不是值，而是可以处理的子流。
3. 通过某些刍将元素分组（grouping）到具有`Flux<GroupedFlux<K,T>>`类型的流中。每个新键都会触发一个新的GroupFlux实例，并且具有该键的所有元素都将被推送到GroupFlux类的实例中。

可以基于以下场景进行开窗和缓冲操作：

1. 处理元素的数量。比如每10个元素一批处理。
2. 一段时间，比方说每5分钟一次。
3. 基于一些谓语，比方说在每个新的偶数之前切割。
4. 基于来自其他Flux的一个事件，该事件控制着执行过程。

**缓冲**

```java
    @Test
    public void buffer() {
        Flux.range(100, 13)
                .buffer(3).
                subscribe(System.out::println);
    }
```

输出：

```tex
[100, 101, 102]
[103, 104, 105]
[106, 107, 108]
[109, 110, 111]
[112]
```

buffer操作符将许多事件收集到一个事件集合中。该集合本身成为下游操作符的事件。当需要使用元素集合来生成一些请求，而不是使用仅包含一个元素的集合来生成许多小请求时，用缓冲区操作符来实现批处理会比较方便。

如可以将数据项缓冲几秒种然后批量插入，而不是逐个将元素插入数据库。



**windows操作符**

如果需要根据数据序列中的元素是否为素数进行开窗拆分，可以使用window操作符的变体`windowUntil`

```java
  @Test
    public void windowUntil() {
        Flux.range(101, 20)
                .windowUntil(this::isPrime)
                .subscribe(window -> window.collectList()
                        .subscribe(item -> System.out.println("windows:" + item)));
    }

    private boolean isPrime(Integer value) {
        if (value < 2) {
            return false;
        }
        if (value == 2 || value == 3) {
            return true;
        }
        if (value % 2 == 0) {
            return false;
        }

        double sqrt = Math.sqrt(value);
        for (int i = 3; i < sqrt; i++) {
            if (value % i == 0) {
                return false;
            }
        }

        return true;
    }
```

输出：

```tex
windows:[101]
windows:[102, 103]
windows:[104, 105, 106, 107]
windows:[108, 109]
windows:[110, 111, 112, 113]
windows:[114, 115, 116, 117, 118, 119, 120]
```

![image-20241205231445153](.\images\image-20241205231445153.png)

window操作符和buffer操作符类型，buffer操作符仅在缓冲区关闭时才会发出集合，而windows操作符会在事件到达时立即对其进行传播，以更快地做出响应并实现更复杂的工作流程。

**groupBy操作符**

groupBy操作符通过某些条件对响应流中的元素进行分组。通过对每个元素打一个标签（key），按照标签元素进行分组。

如：将整数序列按奇数和偶数进行分组，并仅跟踪每组中的最后两个元素。

```java
    @Test
    public void groupBy() {
        Flux.range(1, 11)
                .groupBy(item -> item % 2 == 0 ? "偶数" : "奇数")
                .subscribe(groupFlux -> {
                    groupFlux.scan(new ArrayList<>(),
                                    (list, element) -> {
                                        list.add(element);
                                        if (list.size() > 3) {
                                            list.remove(0);
                                        }
                                        return list;
                                    })
                            .filter(list -> !list.isEmpty())
                            .subscribe(item -> System.out.println("key:" + groupFlux.key() + "-->" + item));
                });
    }
```

输出：

```tex
key:奇数-->[1]
key:偶数-->[2]
key:奇数-->[1, 3]
key:偶数-->[2, 4]
key:奇数-->[1, 3, 5]
key:偶数-->[2, 4, 6]
key:奇数-->[3, 5, 7]
key:偶数-->[4, 6, 8]
key:奇数-->[5, 7, 9]
key:偶数-->[6, 8, 10]
key:奇数-->[7, 9, 11]
```

![image-20241205232659387](.\images\image-20241205232659387.png)

### 8.5.7 flatMap、concatMap和FlatMapSequential操作符

floatMap操作符在逻辑中由map和flatten这两个操作组成。

flatMap操作符的map部分将传入的每个元素转换为响应式流（`T->Flux<R>`)

flatten部分将所有的生成响应式流合并为一个新的响应式流，通过该流可以传递R类型的元素。

Project Reactor提供了FlatMap操作的一些不同变体，除了重载，该库还提供flatMapSequential操作符和concatMap操作符。

这三个操作符在以下几个方面有所不同：

1. 操作符是否立即订阅其内部流;

flatMap操作符和flatMapSequential操作符会立即订阅，而concatMap操作符则会在生成 下一个子流并订阅它之前等待每个内部完成。

2. 操作符是否保留生成元素的顺序。

concatMap天生保留与源元素相同的顺序，flatMapSequential操作符通过对所接收的元素进行排序来保留顺序，而flatMap操作符不一定保留原始排序。

3. 操作符是否对来自不同子流元素进行交错。

flatMap操作允许交错，而concatMap和flatMapSequential不允许交错。

floatMap案例

```java
    @Test
    public void floatMap() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .doOnNext(System.out::println)
                .flatMap(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("已经订阅"))
                ).subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```te
[1, 2, 3]
已经订阅
[a, b, c]
已经订阅
[7, 8, 9]
已经订阅
7
a
1
8
b
9
2
c
3
```



![image-20241205234250476](.\images\image-20241205234250476.png)

可以发现，三个流是立即被订阅的，不保留生成元素的顺序的。同时不同子流数据也会进行交错。



**concatMap**

```java
    @Test
    public void concatMap() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .doOnNext(System.out::println)
                .concatMap(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("已经订阅"))
                ).subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```tex
[1, 2, 3]
已经订阅
[a, b, c]
[7, 8, 9]
1
2
3
已经订阅
a
b
c
已经订阅
7
8
9
```

![image-20241205234722529](.\images\image-20241205234722529.png)

可以发现，流并不立即被订阅的，而是按顺序一个完成后，再订阅另外一个的，由于按顺序订阅所以数据是保留了原数据顺序，并且不会出现交错执行的情况。

**flatMapSequential操作符**

```java
    @Test
    public void flatMapSequential() throws InterruptedException {
        Random ran = new Random();
        Flux.just(Arrays.asList(1, 2, 3), Arrays.asList("a", "b", "c"),
                        Arrays.asList(7, 8, 9))
                .flatMapSequential(item -> Flux.fromIterable(item)
                        .delayElements(Duration.ofMillis(ran.nextInt(100) + 100))
                        .doOnSubscribe(subscription -> System.out.println("订阅"))
                ).subscribe(System.out::println);
        Thread.sleep(2000);
    }
```

输出：

```tex
订阅
订阅
订阅
1
2
3
a
b
c
7
8
9
```

![image-20241205235252762](.\images\image-20241205235252762.png)



通过观察运行可以发现，三个流都是被立即订阅的，并且不允许出现元素交错的情况。



### 8.5.8 元素采样

对于高吞场景而言，通过应用采样技术处理一小部分是有意义的。

`sample`操作符和`sampleTimeout`操作符可以让流周期性的发出与时间窗口内最后看到的值相对应的数据项。

场景：每100ms就从流中取一个元素。

```java
    @Test
    public void sample() throws InterruptedException {
        Flux.range(1, 50)
                .delayElements(Duration.ofMillis(10))
                .sample(Duration.ofMillis(100))
                .subscribe(System.out::println);
        Thread.sleep(5000L);
    }
```

输出：

```tex
6
11
17
24
31
37
43
49
50
```

假如每10毫秒都顺序生成数据项，订阅者也只会收到所指定的约束条件内的一小部分事件。通过这种方法，我们可以在不需要传入事件就能成功操作的场景下使用被动限速。流控。

**sampleTimeout操作符**

```java
    @Test
    public void sampleTimeout() throws InterruptedException {
        Random rand = new Random();
        Flux.range(1, 20)
                .delayElements(Duration.ofMillis(100))
                //并发计算超时时间，调节速度快慢
                .sampleTimeout(item -> Mono.delay(Duration.ofMillis(rand.nextInt(100) + 50)), 20)
                .subscribe(System.out::println);

        Thread.sleep(2000);
    }
```

输出：

```tex
1
2
3
4
6
7
8
9
10
11
14
15
17
```



![image-20241206122228356](.\images\image-20241206122228356.png)



### 8.5.9 将响应式流转换为阻塞结构

Project Reactor库提供了一个API，用于将响应式流转换为阻塞结构。

以下选项来阻塞流，并同步生成结果：

1. toIterable方法将响应式Flux转换为阻塞Iterable.
2. toStream方法将响应式Flux转换为阻塞Stream API。从Reactor 3.2开始，在底层使用toIterable方法。
3. blockFirst方法阻塞了当前线程，直到上游发出第一个值或完成流为止。
4. blockLast方法阻塞了当前线程，直到上游发出最后一个流或者完成流为止。在OnError的情况下，它会在被阻塞的线程中抛出异常。

**toIterable**

```java
    @Test
    public void testToIterable() {
        Iterable<Integer> iterable = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .toIterable();
        System.out.println("-----------------");
        for (Integer value : iterable) {
            System.out.println("item:" + value);
        }
        System.out.println("finish");
    }
```

输出：

```tex
-----------------
item:1
item:2
item:3
finish
```

![image-20241206123109036](.\images\image-20241206123109036.png)

可以发现数据已经被转换为阻塞式的，按顺序一个一个输出：



**toStream**

```java
    @Test
    public void toStream() {
        Stream<Integer> stream = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .toStream();
        System.out.println("-----------------");
        stream.forEach((item) -> System.out.println("each:" + item));
        System.out.println("finish");
    }
```

输出：

```tex
-----------------
each:1
each:2
each:3
finish
```

效果与toIterable一样，一个一个的输出。

![image-20241206123521376](.\images\image-20241206123521376.png)



**blockFirst**

```java
    @Test
    public void blockFirst() throws InterruptedException {
        Integer blockFirst = Flux.just(1, 2, 3)
                .delayElements(Duration.ofMillis(500))
                .doOnNext(System.out::println)
                //此会阻塞主线程，直到收到第一个元素
                .blockFirst();
        System.out.println("-----------");
        System.out.println("获取值:" + blockFirst);
        Thread.sleep(5000L);
    }
```

输出：

```tex
1
-----------
获取值:1
```



![image-20241206123833937](.\images\image-20241206123833937.png)



**blockLast**

```java
    @Test
    public void blockLast() {
        Integer i = Flux.just(1, 2, 3)
                .delayElements(Duration.ofSeconds(1))
                .doOnEach(System.out::println)
                //该方法会阻塞，直到等到流中的最后一个元素或者完成
                .blockLast();
        System.out.println("----------");
        System.out.println("结果" + i);
        System.out.println("finish");
    }
```

输出:

```tex
doOnEach_onNext(1)
doOnEach_onNext(2)
doOnEach_onNext(3)
onComplete()
----------
结果3
finish
```

![image-20241206124312258](.\images\image-20241206124312258.png)



```java
    @Test
    public void blockLastSub() throws InterruptedException {
        Flux<Integer> integerFlux = Flux.just(1, 2, 3).delayElements(Duration.ofSeconds(1));
        integerFlux.subscribe(integer -> System.out.println("第一个订阅：" + integer));
        integerFlux.subscribe(integer -> System.out.println("第二个订阅：" + integer));
        integerFlux.subscribe(integer -> System.out.println("第三个订阅：" + integer));

        System.out.println("订阅结束...");

        Integer i = integerFlux.blockLast();
        System.out.println("阻塞等待最后一个元素：");
        System.out.println("value:" + i);
        Thread.sleep(5000);
    }
```

输出：

```tex
订阅结束...
第二个订阅：1
第一个订阅：1
第三个订阅：1
第一个订阅：2
第二个订阅：2
第三个订阅：2
第一个订阅：3
第三个订阅：3
第二个订阅：3
阻塞等待最后一个元素：
value:3
```

由此可以看出，此blockLast与subcribe这两个互不影响。独立运行。



### 8.5.10 在序列处理时查看元素

有时，我们需要对处理管道中的每个元素或特定信号执行操作，为满足此类要求，Project Reactor提供了以下方法：

1. `doOnNext(Consumer<T>)`使我们对Flux或者Mono上的每个元素执行一些操作。
2. `doOnComplete`和`doOnError(Throwable)`可以应用在相应的事件上。
3. `doOnSubscribe(Consumer<Subscription>)`、`doOnRequest(LongConsumber)`和`doOnCancel(Runable)`使我们能对订阅生命周期事件做出处理。
4. 无论什么原因导致的流终止，`doOnTerminate(runnable)`都会在流终止时被调用 。
   1. 此外Flux和Mono都提供了`doOnEarch(Consumer<Signal>)`方法，该方法处理表示响应流领域的所有信号。包括`onError`、`onSubscribe`、`onNext`、`OnError`、`OnComplete`

**异常信号打印**

```java
    @Test
    public void doOnEach() {
        Flux.just(1, 2, 3)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .doOnEach(item -> System.out.println("打印：" + item))
                .subscribe();
    }
```

输出:

```tex
打印：doOnEach_onNext(1)
打印：doOnEach_onNext(2)
打印：doOnEach_onNext(3)
打印：onError(java.lang.RuntimeException: 手动异常)
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxPrint.doOnEach(TestFluxPrint.java:17)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

doOnEach的弹珠图

![image-20241206134948889](.\images\image-20241206134948889.png)

其他信号的处理

```java
    @Test
    public void doSign() {
        Flux.just(1, 2, 3)
                .doOnNext(item -> System.out.println("doOnNext打印：" + item))
                .doOnComplete(() -> System.out.println("doOnComplete完成信号打印:"))
                .doOnError(e -> System.out.println("doOnError异常信号打印" + e))
                .doOnSubscribe(item -> System.out.println("订阅时打印:"))
                .doOnRequest((t) -> System.out.println("doOnRequest请求时打印:" + t))
                .doOnTerminate(() -> System.out.println("任何终止信号都会收到："))
                .doOnEach(item -> System.out.println("打印：" + item))
                .subscribe();
    }
```

输出：

```tex
订阅时打印:
doOnRequest请求时打印:9223372036854775807
doOnNext打印：1
打印：doOnEach_onNext(1)
doOnNext打印：2
打印：doOnEach_onNext(2)
doOnNext打印：3
打印：doOnEach_onNext(3)
doOnComplete完成信号打印:
任何终止信号都会收到：
打印：onComplete()
```



### 8.5.11 物化与非物化信号

将流中元素转换为Signal称为物化。将物化过的Signal对象转换为流即为非物化 。

有时采用信号进行流处理比采用数据进行处理更有用，为了将数据流转换为信号流并再次返回，Flox和Mono提供了materialize方法和dematerialize方法

```java
    @Test
    public void materialize() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                //将异常流转换为信号
                .materialize()
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("完成"));

        Thread.sleep(3000);
    }
```

输出：

```tex
item:false
next:onNext(1)
item:false
next:onNext(2)
item:false
next:onNext(3)
item:false
next:onError(java.lang.IllegalArgumentException: 手动异常)
item:true
完成
```

可以看此，此时异常已经被处理成了普通信号进行处理。不是收到了error信号

那如果不使用异常流转换呢？

```java
    @Test
    public void materialize2() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.err.println("error:" + e),
                        () -> System.out.println("完成"));

        Thread.sleep(3000);
    }
```

那此时输出：

```tex
item:false
next:1
item:false
next:2
item:false
next:3
item:false
error:java.lang.IllegalArgumentException: 手动异常
```

此时收到的就是错误信号了,此进如果没有对异常信息处理，那么将会被抛出去

```java
    @Test
    public void materialize2() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item));

        Thread.sleep(3000);
    }
```

输出:

```tex
item:false
next:1
item:false
next:2
item:false
next:3
item:false
[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
Caused by: java.lang.IllegalArgumentException: 手动异常
	at com.nullnull.recator.TestFluxPrint.materialize2(TestFluxPrint.java:57)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

物化后非物化的处理

```java
    @Test
    public void materializeEach() throws InterruptedException {
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(200))
                .publishOn(Schedulers.parallel())
                .concatWith(Flux.error(new IllegalArgumentException("手动异常")))
                .doOnNext(item -> System.out.println("doOnNext信号:" + item))
                .materialize()
                //日志输出
                .log()
                //非物化处理
                .dematerialize()
                .doOnEach(signalSignal -> System.out.println("item:" + signalSignal.isOnComplete()))
                .subscribe(item -> System.out.println("next:" + item));

        Thread.sleep(3000);
    }
```

输出：

```tex
[ INFO] (main) onSubscribe(FluxMaterialize.MaterializeSubscriber)
[ INFO] (main) request(unbounded)
doOnNext信号:1
[ INFO] (parallel-1) onNext(onNext(1))
item:false
next:1
doOnNext信号:2
[ INFO] (parallel-1) onNext(onNext(2))
item:false
next:2
doOnNext信号:3
[ INFO] (parallel-1) onNext(onNext(3))
item:false
next:3
[ INFO] (parallel-1) onNext(onError(java.lang.IllegalArgumentException: 手动异常))
[ INFO] (parallel-1) cancel()
item:false
[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: 手动异常
Caused by: java.lang.IllegalArgumentException: 手动异常
	at com.nullnull.recator.TestFluxPrint.materializeEach(TestFluxPrint.java:69)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

log方法，该方法使用可用的记录器记录所有处理过的信号。

![image-20241207151428057](.\images\image-20241207151428057.png)





### 8.6 以编程方式创建流

有时候，需要一种更复杂的方法来在流中生成信号，或将对象的生命周期绑定到响应式流的生命周期。

### 8.6.1 push和create方法

push工厂方法能够通过适配一个单线程生产者来创建Flux实例。

主要用于衔接外部数据。

此方法对于适配异步、单线程、多值API非常有用，而无须关注背压和取消，push本身包含背压和取消。

```java
    @Test
    public void push() throws InterruptedException {
        //将命令式流转换为响应式流,此处只能是单线程的
        Flux.push(new Consumer<FluxSink<Integer>>() {
                    @Override
                    public void accept(FluxSink<Integer> integerFluxSink) {
                        //通过单线程的方式，调用其他方法，其他方法的返回值，可以通过FluxSink追加到下游的响应式流中
                        IntStream.range(1, 100).forEach((t) -> integerFluxSink.next(t));
                    }
                }).delayElements(Duration.ofMillis(200))
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("e:" + e),
                        () -> System.out.println("finish"));

        Thread.sleep(2000);
    }
```

输出：

```tex
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
```

使用lambda编写:

```java
    @Test
    public void pushLambda() throws InterruptedException {
        Flux.push(fluxSink -> IntStream.range(1, 100).forEach(fluxSink::next))
                //延迟200毫秒
                .delayElements(Duration.ofMillis(200))
                //订阅
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("e:" + e),
                        () -> System.out.println("finish"));

        Thread.sleep(2000);
    }
```

输出：

```tex
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
```

push工厂方法可以很方便地使用默认的背压和取消策略来适配异步的API

![image-20241207162831166](.\images\image-20241207162831166.png)



**create方法**

create与push方法类似，起到桥接的作用。

该方法不能从不同的线程发送事件。

```java
    /**
     * 事件处理器
     */
    static class MyEventProcess {
        private MyEventListener listener;
        private Random rand = new Random();

        /**
         * 注册回调的事件监听器
         *
         * @param listener
         */
        void register(MyEventListener listener) {
            this.listener = listener;
        }

        public void process() {
            //构建数据，向下游发送
            while (rand.nextInt() % 3 != 0) {
                List<String> dataChunk = new ArrayList<>();
                for (int i = 0; i < 10; i++) {
                    dataChunk.add("data-" + i);
                }
                //发送数据
                listener.onDataChunk(dataChunk);
            }
            //完成信号
            listener.processComplete();
        }
    }

    /**
     * 回调接口
     *
     * @param <T>
     */
    interface MyEventListener<T> {
        /**
         * 传递数据的信号
         *
         * @param chunk
         */
        void onDataChunk(List<T> chunk);

        /**
         * 处理数据的信号
         */
        void processComplete();
    }

    @Test
    public void create() throws InterruptedException {
        MyEventProcess process = new MyEventProcess();
        Flux<Object> objectFlux = Flux.create(fluxSink -> {
            //注册监听器
            process.register(new MyEventListener<String>() {
                @Override
                public void onDataChunk(List<String> chunk) {
                    //将数据发送到下游的响应式流中
                    for (String chunkItem : chunk) {
                        fluxSink.next(chunkItem);
                    }
                }

                @Override
                public void processComplete() {
                    //结束流的发送
                    fluxSink.complete();
                }
            });
        });
        objectFlux.subscribe(item -> System.out.println("item:" + item),
                e -> System.out.println("e" + e),
                () -> System.out.println("完成")
        );

        //开始生成数据
        process.process();
        Thread.sleep(5000);
    }
```

输出：

```tex
item:data-0
item:data-1
item:data-2
item:data-3
item:data-4
item:data-5
item:data-6
item:data-7
item:data-8
item:data-9
完成
```



**generate工厂方法**

generate工厂方法指在基于生成器的内部处理状态创建复杂序列。

它需要一个初始值和一个函数，该函数根据前一个状态计算下一个状态，并将onNext信号发送给下游的订阅者。

```java
@Test
    public void generate() throws InterruptedException {
        Flux.generate(
                        //用于构建初始值
                        new Callable<ArrayList<Long>>() {
                            @Override
                            public ArrayList<Long> call() throws Exception {
                                final ArrayList<Long> dataList = new ArrayList<>();
                                dataList.add(0L);
                                dataList.add(1L);

                                return dataList;
                            }
                        },//函数的处理逻辑
                        new BiFunction<ArrayList<Long>, SynchronousSink<Long>, ArrayList<Long>>() {
                            @Override
                            public ArrayList<Long> apply(ArrayList<Long> list, SynchronousSink<Long> sink) {
                                final Long getLong1 = list.get(list.size() - 1);
                                final Long getLong2 = list.get(list.size() - 2);
                                //向下游发送元素
                                sink.next(getLong1);

                                list.add(getLong1 + getLong2);

                                return list;
                            }
                        }

                ).delayElements(Duration.ofMillis(200))
                .take(10)
                .subscribe(
                        item -> System.out.println("next:" + item),
                        ex -> System.out.println("error:" + ex),
                        () -> System.out.println("完成")
                );

        Thread.sleep(3000L);
    }
```

输出:

```tex
next:1
next:1
next:2
next:3
next:5
next:8
next:13
next:21
next:34
next:55
完成
```

使用lambda表达式

```java
    @Test
    public void generateLambda() throws InterruptedException {
        Flux.generate(
                        () -> {
                            final ArrayList<Long> dataList = new ArrayList<>();
                            dataList.add(0L);
                            dataList.add(1L);

                            return dataList;
                        },
                        (list, sink) -> {
                            final Long getLong1 = list.get(list.size() - 1);
                            final Long getLong2 = list.get(list.size() - 2);
                            //向下游发送元素
                            sink.next(getLong1);

                            list.add(getLong1 + getLong2);

                            return list;
                        }

                ).delayElements(Duration.ofMillis(200))
                .take(10)
                .subscribe(
                        item -> System.out.println("next:" + item),
                        ex -> System.out.println("error:" + ex),
                        () -> System.out.println("完成")
                );

        Thread.sleep(3000L);
    }
```

输出:

```tex
next:1
next:1
next:2
next:3
next:5
next:8
next:13
next:21
next:34
next:55
完成
```

使用二元组

```java
    @Test
    public void generateTuples() throws InterruptedException {
        Flux.generate(() -> Tuples.of(0, 1),
                        (tuples, sink) -> {
                            sink.next(tuples.getT2());
                            int sumValue = tuples.getT1() + tuples.getT2();
                            return Tuples.of(tuples.getT2(), sumValue);
                        })
                .delayElements(Duration.ofMillis(300))
                .take(10)
                .subscribe(System.out::println);
        Thread.sleep(5000);
    }
```

输出:

```tex
1
1
2
3
5
8
13
21
34
55
```

在下一个值生成之前，每个新值都被同步传播组了订阅者。

当生成不同的复杂响应流，而该序列需要保持发射之彰的中间状态时，该方法非常有用。



**disposable** 

`using`工厂方法能根据一个`disposable`资源创建流，它在响应式编程中实现了`tr-with-resources`方法

这是一个模拟连接的对象

```java
    static class Connection implements AutoCloseable {
        private final Random rand = new Random();

        static Connection newConnection() {
            System.out.println("创建Connection对象");
            return new Connection();
        }

        public Iterable<String> getData() {
            if (rand.nextInt(10) < 3) {
                throw new RuntimeException("通信异常");
            }
            return Arrays.asList("数据1", "数据2");
        }

        /**
         * 关闭资源的方法，即使发生错误，也得关闭
         *
         * @throws Exception
         */
        @Override
        public void close() {
            System.out.println("关闭Connection连接");
        }
    }

```

传统的使用方法

```java
    @Test
    public void old() {
        try (Connection connection = Connection.newConnection()) {
            connection.getData().forEach(dat -> System.out.println("接收到的数据:" + dat));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```

输出:

```tex
创建Connection对象
接收到的数据:数据1
接收到的数据:数据2
关闭Connection连接
```

或者发生异常:

```tex
创建Connection对象
关闭Connection连接

java.lang.RuntimeException: java.lang.RuntimeException: 通信异常

	at com.nullnull.recator.TestFluxUsing.old(TestFluxUsing.java:47)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
Caused by: java.lang.RuntimeException: 通信异常
	at com.nullnull.recator.TestFluxUsing$Connection.getData(TestFluxUsing.java:26)
	at com.nullnull.recator.TestFluxUsing.old(TestFluxUsing.java:45)
	... 27 more
```

使用响应式流来操作

```java
    @Test
    public void using() {
        Flux.using(
                //获取连接
                Connection::newConnection,
                //正常执行方法
                connection -> Flux.fromIterable(connection.getData()),
                //执行关闭
                Connection::close
        ).subscribe(
                item -> System.out.println("next:" + item),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")

        );
    }
```

输出:

```tex
创建Connection对象
next:数据1
next:数据2
关闭Connection连接
finish
```

或者发生异常：

```tex
创建Connection对象
关闭Connection连接
error:java.lang.RuntimeException: 通信异常
```

即使发生了异常，连接也被关闭了。

连接的生命周期与流的生命周期绑定。

操作符还可以通知订阅者流终止之前或之后是否应该进行清除动作。



**usingWhen包装响应式事务**

与Using操作符类似，usingWhen操作符使我们能以响应式方式管理资源 。但是,using操作符同步获取受托管资源。同时,usingWhen操作符响应式地获取受托管资源（通过订阅Publisher的实例）。此外,usingWhen操作符接受不同的处理程序，以便应对主处理流终止的成功和失败。这些处理程序由发布者实现。

可以仅使用`usingWhen`一个操作符实现完全无阻塞的响应式事务。

```java
    public static class Transaction {
        private static final Random rand = new Random();
        private final int id;

        /**
         * 创建事务
         *
         * @param id
         */
        public Transaction(int id) {
            this.id = id;
        }

        /**
         * 开启响应式事务
         *
         * @return
         */
        public static Mono<Transaction> beginTransaction() {
            System.out.println("开启事务");
            return Mono.defer(() -> Mono.just(new Transaction(rand.nextInt())));
        }

        /**
         * 响应式插入数据
         *
         * @param rows
         * @return
         */
        public Flux<String> insertRow(Publisher<String> rows) {
            return Flux.from(rows)
                    .delayElements(Duration.ofMillis(500))
                    //将数据转换为响应式流
                    .flatMap(row -> {
                        if (rand.nextInt(10) < 3) {
                            return Mono.error(new IllegalArgumentException("出错条目:" + row));
                        } else {
                            return Mono.just(row);
                        }
                    });
        }

        /**
         * 提交事务
         *
         * @return
         */
        public Mono<Void> commit() {
            return Mono.defer(() -> {
                System.out.println("开始提交事务:");
                if (rand.nextBoolean()) {
                    return Mono.empty();
                } else {
                    return Mono.error(new RuntimeException("事务提交异常"));
                }
            });
        }

        /**
         * 响应式事务的回滚
         *
         * @return
         */
        public Mono<Void> rollback() {
            return Mono.defer(() -> {
                System.out.println("开始提交事务");
                if (rand.nextBoolean()) {
                    return Mono.empty();
                } else {
                    return Mono.error(new RuntimeException("回滚异常"));
                }
            });
        }
    }
```

使用`usingWhen`操作

```java
    /**
     * 使用usingWhen实现一个更新的事务
     */
    @Test
    public void usingWhen() throws InterruptedException {
        Flux.usingWhen(
                //提供资源
                Transaction.beginTransaction(),
                //插入数据
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("插入数据");
                        return transaction.insertRow(Flux.just("a", "b", "c"));
                    }
                },
                //正常提交事务
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("提交事务");
                        return transaction.commit();
                    }
                },
                //发生异常时，清理资源
                new BiFunction<Transaction, Throwable, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction, Throwable throwable) {
                        System.out.println("回滚事务");
                        return transaction.rollback();
                    }
                },
                //如果查询取消，清理资源
                new Function<Transaction, Publisher<?>>() {
                    @Override
                    public Publisher<?> apply(Transaction transaction) {
                        System.out.println("取消查询");
                        return null;
                    }
                }
        ).subscribe(event -> System.out.println("onNext:" + event),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出:

```tex
开启事务
插入数据
onNext:a
回滚事务
开始提交事务
error:java.lang.IllegalArgumentException: 出错条目:b
```

或者成功:

```tex
开启事务
插入数据
onNext:a
onNext:b
onNext:c
提交事务
开始提交事务:
finish
```

改成lambda

```java
    @Test
    public void usingWhenLambda() throws InterruptedException {
        Flux.usingWhen(
                //提供资源
                Transaction.beginTransaction(),
                //资源的使用，即插入数据
                transaction -> transaction.insertRow(Flux.just("a", "b", "c")),
                //提交事务
                transaction -> transaction.commit(),
                //发生异常，清理资源
                (transaction, throwable) -> transaction.rollback(),
                transaction -> transaction.rollback()

        ).subscribe(event -> System.out.println("onNext:" + event),
                e -> System.out.println("error:" + e),
                () -> System.out.println("finish")
        );
        Thread.sleep(5000);
    }
```

输出：

```tex
开启事务
onNext:a
onNext:b
onNext:c
开始提交事务:
error:java.lang.RuntimeException: Async resource cleanup failed after onComplete
```

或者：

```tex
开启事务
onNext:a
onNext:b
onNext:c
开始提交事务:
finish
```

使用usingWhen操作符，不仅可以可以更容易的实以完全响应式的方式管理生命周期，还可以轻松实现响应式事务。



### 8.7 错误处理

`onError`信号是响应式流规范的一组成部分，一种将异常传播给可以处理它的用户，但是，如果最终订阅者没有为`onError`信号定义处理程序，那么将抛出`onError`抛异常。

响应式流的语义定义了`OnError`是一个终止操作，该操作之后流会停止执行。

我们可能采取以下策略中的一种做出不同响应：

1. 为`subscribe`操作符中的`OnError`信号定义处理程序。
2. 通过`OnErrorReturn`操作符捕获异常，并用一个默认静态值或一个异常中计算出的值替换它。
3. 通过`OnErrorResume`操作符捕获异常并执行备用工作流。
4. 通过`OnErrorMap`操作符获取并将其转换为另一个异常来更好地表现当前场景。
5. 定义一个在发生错误时重新执行的响应式工作流。如果源响应序列发出错误信号 ，那么`retry`操作符会重新订阅该序列。

**OnError信号**

```java
    /**
     * 仅处理OnNext事件，没有处理OnError，则抛出异常
     */
    @Test
    public void onError() {
        Flux.from(new Publisher<String>() {
            @Override
            public void subscribe(Subscriber<? super String> s) {
                s.onError(new RuntimeException("手动异常"));
            }
        }).subscribe(System.out::println);
    }
```

输出:

```tex
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxOnError$1.subscribe(TestFluxOnError.java:25)
	at reactor.core.publisher.FluxSource.subscribe(FluxSource.java:66)
	at reactor.core.publisher.Flux.subscribe(Flux.java:8095)
	at reactor.core.publisher.Flux.subscribeWith(Flux.java:8268)
	at reactor.core.publisher.Flux.subscribe(Flux.java:8065)
	at reactor.core.publisher.Flux.subscribe(Flux.java:7989)
	at reactor.core.publisher.Flux.subscribe(Flux.java:7932)
	at com.nullnull.recator.TestFluxOnError.onError(TestFluxOnError.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

对Error进行处理

```java
    /**
     * 处理Error信号，则不再抛出
     */
    @Test
    public void onError1() {
        Flux.from(new Publisher<String>() {
            @Override
            public void subscribe(Subscriber<? super String> s) {
                s.onError(new RuntimeException("手动异常"));
            }
        }).subscribe(System.out::println,
                e -> System.out.println("error:" + e),
                () -> System.out.println("完成信号")
        );
    }
```

输出:

```tex
error:java.lang.RuntimeException: 手动异常
```

服务的代码:

```java
    private static Random rand = new Random();

    public static Flux<String> recommendedBooks(String userId) {
        return Flux.defer(() -> {
            if (rand.nextInt(10) < 5) {
                return Flux.<String>error(new RuntimeException("异常信息"))
                        //指定向后推移指定时间，元素发射频率不变
                        .delaySequence(Duration.ofMillis(100));
            } else {
                return Flux.just("JAVA编程思想", "重构")
                        .delayElements(Duration.ofMillis(50));
            }
        }).doOnSubscribe(item -> System.out.println("请求:" + userId));
    }
```

**onErrorReturn**

捕获异常，并用一个默认静态值或一个异常中计算出的值替换它。

```java
@Test
    public void onErrorReturn() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorReturn("代码大全")
                .subscribe(item -> System.out.println("next:" + item),
                        ex ->{
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号");
                            latch.countDown();
                        }
                );

        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

异常时输出：

```tex
请求:user-001
next:代码大全
完成信号
执行等待开始
执行等待结束
```



**onErrorResume**

捕获异常并执行备用工作流。

```java
    @Test
    public void onErrorResume() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);


        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorResume(event -> Flux.just("代码整洁之前"))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号");
                            latch.countDown();
                        }
                );

        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

执行完成：

```tex
请求:user-001
执行等待开始
next:JAVA编程思想
next:重构
完成信号
执行等待结束
```

发生异常时：

```tex
请求:user-001
next:代码整洁之前
完成信号
执行等待开始
执行等待结束
```

**onErrorMap**

获取并将其转换为另一个异常来更好地表现当前场景。

```java
    @Test
    public void OnErrorMap() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user))
                .onErrorMap(throwable -> {
                    if (throwable.getMessage().equals("异常信息")) {
                        return new Exception("转换异常");
                    } else {
                        return new Exception("未知");
                    }
                })
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成信号:");
                            latch.countDown();
                        }
                )
        ;
        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```

输出：

```tex
请求:user-001
error:java.lang.Exception: 转换异常
执行等待开始
执行等待结束
```





**retry**

重新订阅该序列

```java
   @Test
    public void retry() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Flux.just("user-001")
                .flatMap(user -> recommendedBooks(user).retry(3))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("处理完成");
                            latch.countDown();
                        }
                );
        System.out.println("执行等待开始");
        latch.await();
        System.out.println("执行等待结束");
    }
```



输出：

正常结束：

```tex
请求:user-001
请求:user-001
请求:user-001
执行等待开始
next:JAVA编程思想
next:重构
处理完成
执行等待结束
```

可以看出此处正常执行了一次失败了，然后重试了一次成功。

异常结束:

```tex
请求:user-001
请求:user-001
请求:user-001
请求:user-001
error:java.lang.RuntimeException: 异常信息
执行等待开始
执行等待结束
```

Project Reactor提供了丰富的工具集，可以帮助处理异常情况，从而提高应用程序的回弹性。



### 8.8 背压处理

尽管响应式流规范要求将背压构建到生产者和消费者之间的通信中，但这仍然可能使消费者溢出。

一些消费者可能无意识的请求无界队列，然后无法处理生成的负载。

另一些消费者则可能传入消息的速度有严格的限制。比如。数据库客户端每秒不能插入超过1000条记录。在这种情况下，事件批处理技术可能有所帮助。

可以通过以下配制流以处理背压情况：

1. `onBackPressureBuffer`操作符会请求无界需求并将返回的元素推送到下游，如果下游消费者无法跟上，元素将缓存在队列中。
2. `onBackPressureDrop`操作符也请求无界需求（Long.MAV_VALUE）并向下游推送数据，如果下游请求数量不足，那么元素会被丢弃。自定义处理程序可以用来处理已丢弃的元素。
3. `onBackPressureLast`操作符与`onBackPressureDrop`的工作方式类似。只是会记住最近收到的元素，并在需求出现时立即将其推向下游。
4. `onBackPressureError`操作符在尝试向下游推送数据时，请求无界需求。如果下游消费者无法跟上，则操作符会引发错误。
5. 背压管理的另外一种方法是速度限制，`limit(n)`操作符将下游需求拆分为不大于n的较小批次，可以保护脆弱的生产者免受来自下游消费者的不合理数据请求的破坏。`limitRate(n)`操作符会限制来自下游消费者的需求（总请求值）如，limitRequest(100)确保不会向生产者请求超过100个元素，发送100个事件后，操作符成功关闭流。

**onBackpressureBuffer**

会请求无界需求并将返回的元素推送到下游，如果下游消费者无法跟上，元素将缓存在队列中。

```java
    @Test
    public void OnBackpressureBuffer() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 100)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureBuffer(10)
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

如果超出缓存的数量无法处理，则出现异常：

```tex
等待开始
next:1
error:reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)
等待结束

```

修改产生的数量，变以10，让其能够处理：则输出：

```java
//修改：
Flux.range(1, 100)
// 变为    
Flux.range(1, 10)
```



```java
等待开始
next:1
next:2
next:3
next:4
next:5
next:6
next:7
next:8
next:9
next:10
完成：
等待结束
```



**onBackPressureDrop**

下游请求数量不足，那么元素会被丢弃

```java
    @Test
    public void onBackpressureDrop() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 100)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureDrop()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
......
next:30
next:31
next:32
完成：
等待结束
```

可以发现，32以后的元素都被丢弃。

**onBackpressureLast**

`onBackPressureDrop`的工作方式类似。只是会记住最近收到的元素

```java
    @Test
    public void onBackpressureLast() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 500)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureLatest()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
......
next:30
next:31
next:32
next:162
next:163
next:164
......
next:183
next:184
next:185
next:330
next:331
next:332
......
next:350
next:351
next:352
next:353
next:498
next:499
next:500
完成：
等待结束
```

可以发现，最新的无素都被收到，而老的元素，则被丢弃。



**onBackpressureError**

如果下游消费者无法跟上，则操作符会引发错误

```java
    @Test
    public void onBackpressureError() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 500)
                .delayElements(Duration.ofMillis(1))
                .onBackpressureError()
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
next:4
error:reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)
等待结束
```



**limit**

```java
    @Test
    public void limit() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        Flux.range(1, 150)
                .delayElements(Duration.ofMillis(1))
                .limitRate(2)
                .delayElements(Duration.ofMillis(100))
                .subscribe(item -> System.out.println("next:" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("完成：");
                            latch.countDown();
                        }
                );

        System.out.println("等待开始");
        latch.await();
        System.out.println("等待结束");
    }
```

输出：

```tex
等待开始
next:1
next:2
next:3
next:4
next:5
......
next:144
next:145
next:146
next:147
next:148
next:149
next:150
完成：
等待结束
```

弹珠图

![image-20241208141925840](.\images\image-20241208141925840.png)



### 8.9 热数据与冷数据

冷发布者行为方式：无论订阅者何时出现，都为该订阅者生成所有序列数据，没有订阅者就不会生成数据。

**冷发布者**

```java
    @Test
    public void cold() {
        Flux<String> coldPublisher = Flux.defer(() -> {
            System.out.println("生成新的数据");
            return Flux.just(UUID.randomUUID().toString());
        });
        System.out.println("尚未收到新的数据");
        coldPublisher.subscribe(item -> System.out.println("next1:" + item));
        coldPublisher.subscribe(item -> System.out.println("next2:" + item));
        System.out.println("为两个订阅者生成了两次数据");
    }
```

输出：

```tex
尚未收到新的数据
生成新的数据
next1:966d48b6-edf2-4dda-aa7b-0ffe8d427234
生成新的数据
next2:79dac838-3b1b-4ae3-a8ea-8cb330fd703f
为两个订阅者生成了两次数据
```



每当订阅者出现的时候，都会有一个新的序列生成，而这些语义可以代表HTTP请求



**热发布者**

热发布者中的数据生成不依赖于订阅者而存在。因此，热发布者可能在第一个订阅者出现之前开始生成元素。

热发布者代表数据广播场景，如股价一旦发生变化，热发布者就可以向其订阅者广播有关的当前股票的最新的价格。当订阅者到达时，它仅接收未来的价格更新，而不接受先前价格历史。Reactor库中的大多数据热发布者扩展了Processor接口，但是,just工厂方法会生成 一个热发布者，因为它的值只在构建发布者时计算一次，并且订阅者到达时不会重新计算。

可以通过将just包装在defer中来将其转换为冷发布者。这样即使just在初始化时生成 值，这样初始化也只会在新订阅出现时发生。后一种行为由defer工厂方法决定。

**多播流元素**

通过响应式将冷发布者转换为热发布者。

一旦所有订阅者准备好生成 数据，希望在几个订阅者之间共享冷处理的结果，同时，我们又不希望为每个订阅者重新生成数据。Project Reactor为此目的提供了`ConectableFlux`

`ConectableFlux`,不仅可以生成数据以满足最急迫的需求，还会缓存数据，以便所有其他订阅者可以按照自己的速度处理数据。队列和超时的大小可以通过publish方法和replay方法进行配置。

此外,`ConnectableFlux`可以使用`connect`,`autoConnect(n)`,`refCount(n)`和`refCount(int,Duration)`等方法自动跟踪下游订阅者的数据，以便 在达到所需阈值时触发执行操作。

```java
    @Test
    public void ConnectableFlux() {
        Flux<Integer> source = Flux.range(0, 3)
                .doOnSubscribe(s -> System.out.println("对冷发布者的新订阅票据" + s));
        //由冷发布者转变为热发布者
        final ConnectableFlux<Integer> conn = source.publish();
        conn.subscribe(item -> System.out.println("next1:" + item));
        conn.subscribe(item -> System.out.println("next2:" + item));
        System.out.println("所有订阅都都准备好建立连接了");
        //激活为热数据开始执行。
        conn.connect();
    }
```

输出：

```tex
所有订阅都都准备好建立连接了
对冷发布者的新订阅票据reactor.core.publisher.FluxRange$RangeSubscription@675d3402
next1:0
next2:0
next1:1
next2:1
next1:2
next2:2
```



弹珠图

![image-20241208220701716](.\images\image-20241208220701716.png)



**缓存流元素**

使用`ConectableFlux`可以轻松实现不同的数据缓存策略。但是,Reactor已经以`cache`操作符的形式提供了用于事件缓存的API。

`cache`操作符使用`ConnectableFlux`,因为它的主要附加值是它所提供一个流式而直接的API。

可以调整缓存所容纳的数据量以及每个缓存项的到期时间。

```java
    @Test
    public void cache() throws InterruptedException {
        Flux<Integer> source = Flux.range(0,3)
                .doOnSubscribe(s -> System.out.println("冷发布者的新订阅票据"));
        final  Flux<Integer> cacheSource = source.cache(Duration.ofMillis(200));
        cacheSource.subscribe(item -> System.out.println("订阅者1-next:"+item));
        cacheSource.subscribe(item -> System.out.println("订阅者2-next:"+item));
        Thread.sleep(300);
        cacheSource.subscribe(item -> System.out.println("订阅者3-next:"+item));
    }
```

输出：

```tex
冷发布者的新订阅票据
订阅者1-next:0
订阅者1-next:1
订阅者1-next:2
订阅者2-next:0
订阅者2-next:1
订阅者2-next:2
冷发布者的新订阅票据
订阅者3-next:0
订阅者3-next:1
订阅者3-next:2
```

从过程中可以看出，订阅者1和订阅者2，都使用缓存的订阅数据，因为此时还只有一个订阅票据，而当缓存过期后，此时产生了一个新的订阅票据。也就是说缓存失效了，重新生成了订阅票据。重新生成了数据流。

弹珠图：

![image-20241208221619728](.\images\image-20241208221619728.png)



**共享流元素**

我们可以使用`ConnectableFlux`向几个订阅者多播事件。但是需要等待订阅者出现才能开始处理。

`share`操作符可以将冷发布者转换为热发布者。该操作符会为每个新的订阅者传播订阅者尚未错过的事件。

通过此可以做，什么时候订阅，什么时候给数据

```java
    @Test
    public void share() throws InterruptedException {
        Flux<Integer> source = Flux.range(0, 5)
                .delayElements(Duration.ofMillis(100))
                .doOnSubscribe(item -> System.out.println("冷发布者新的订阅票据" + item));
        Flux<Integer> cacheSource = source.share();
        cacheSource.subscribe(item -> System.out.println("订阅者1- next:" + item));
        Thread.sleep(400);
        cacheSource.subscribe(item -> System.out.println("订阅者2- next:" + item));
        Thread.sleep(1000);
    }
```

输出：

```tex
冷发布者新的订阅票据reactor.core.publisher.FluxConcatMap$ConcatMapImmediate@42e26948
订阅者1- next:0
订阅者1- next:1
订阅者1- next:2
订阅者1- next:3
订阅者2- next:3
订阅者1- next:4
订阅者2- next:4
```

通过观察可以发布，订阅者2，相比于订阅者1，晚执行了400毫秒，此时订阅者只收到了数据3和4，少了之前的数据。其于此实现了什么时候订阅，什么时候给最新的数据。

### 8.10 处理时间

响应式编程是异步的，因此它本身假定存在时序。

基于Project Reactor，可以使用`interval`操作符生成基于一定持续时间的事件，使用`delayElements`操作符生成延迟元素，并使用`delaySequence`操作符延迟所有信号。

Reactor的API使用能对一些与时间相关的事件做出响应。

`timestamp`操作符用于输出元素的时间戳。

`timeout`操作符用于指定消息时间间隔的大小。

`elapsed`操作符测量与上一个事件的时间间隔。

**interval操作符**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period )
```

指定元素之间的间隔。

```java
    @Test
    public void interval() throws InterruptedException {
        //指定每个元素之间的时间间隔
        Flux.interval(Duration.ofMillis(200))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        System.out.println("当前的线程名称:"+Thread.currentThread().getName());
        Thread.sleep(2000);

    }
```

输出：

```tex
当前的线程名称:main
parallel-1---->0
parallel-1---->1
parallel-1---->2
parallel-1---->3
parallel-1---->4
parallel-1---->5
parallel-1---->6
parallel-1---->7
parallel-1---->8
结束
parallel-1---->9
```

可发现订阅者是在另外的线程中运行。而非当前线程。

查看弹珠图：

![image-20241208224040167](.\images\image-20241208224040167.png)

**interval-2**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration delay,
    @NotNull  java.time.Duration period )
```

指定延迟时间及时间间隔



```java
    @Test
    public void interval2() throws InterruptedException {
        //参数1：指定第一个元素发送的时间与订阅时间的时间差。
        //参数2： 指定生成的序列元素之间的时间间隔。
        Flux.interval(Duration.ofSeconds(2), Duration.ofMillis(200))
                .subscribe(item -> System.out.println("onext:" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
onext:0
onext:1
onext:2
onext:3
onext:4
结束
onext:5
```

弹珠图:

![image-20241208224541205](.\images\image-20241208224541205.png)

**interval-3**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period,
    @NotNull  reactor.core.scheduler.Scheduler timer )
```

指定生成的序列以什么样的方式来运行。

```java
    @Test
    public void interval3() throws InterruptedException {
        Flux.interval(Duration.ofMillis(200), Schedulers.parallel())
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
parallel-1---->0
parallel-1---->1
parallel-1---->2
parallel-1---->3
parallel-1---->4
parallel-1---->5
parallel-1---->6
parallel-1---->7
parallel-1---->8
parallel-1---->9
parallel-1---->10
parallel-1---->11
parallel-1---->12
parallel-1---->13
结束
parallel-1---->14
```

**interval-4**

```java
public static Flux<Long> interval(     @NotNull  java.time.Duration period,
    @NotNull  reactor.core.scheduler.Scheduler timer )
```

指定生成的序列在指定的线程中运行。

```java
    @Test
    public void interval4() throws InterruptedException {
        Flux.interval(Duration.ofMillis(200), Schedulers.newSingle("sch-"))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
sch--1---->0
sch--1---->1
sch--1---->2
sch--1---->3
sch--1---->4
sch--1---->5
sch--1---->6
sch--1---->7
sch--1---->8
sch--1---->9
sch--1---->10
sch--1---->11
sch--1---->12
sch--1---->13
结束
sch--1---->14
```



**delayElements**

```java
    @Test
    public void delayElements() throws InterruptedException {
        Flux.range(1, 10)
                //对每个元素之间的时间间隔进行指定时间
                .delayElements(Duration.ofSeconds(1))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item));
        Thread.sleep(5000);
        System.out.println("结束");
    }
```

输出：

```tex
parallel-1---->1
parallel-2---->2
parallel-3---->3
parallel-4---->4
结束
```



![image-20241208230459540](.\images\image-20241208230459540.png)



**delaySequence操作符**

```java
    @Test
    public void delaySequence() throws InterruptedException {
        Flux.range(1, 10)
                //指定数据延迟发布的时间与第一个元素的时间间隔，即数据整体延迟3秒后全部发出
                .delaySequence(Duration.ofSeconds(3))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "---->" + item + "<>" + LocalDateTime.now()));
        System.out.println("开始:" + LocalDateTime.now());
        Thread.sleep(5000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:2024-12-08T23:09:18.771
parallel-1---->1<>2024-12-08T23:09:21.770
parallel-1---->2<>2024-12-08T23:09:21.771
parallel-1---->3<>2024-12-08T23:09:21.771
parallel-1---->4<>2024-12-08T23:09:21.771
parallel-1---->5<>2024-12-08T23:09:21.771
parallel-1---->6<>2024-12-08T23:09:21.771
parallel-1---->7<>2024-12-08T23:09:21.771
parallel-1---->8<>2024-12-08T23:09:21.771
parallel-1---->9<>2024-12-08T23:09:21.772
parallel-1---->10<>2024-12-08T23:09:21.772
结束
```



**timeOut**

对响应流进行约束，响应流中的等待时间不能超过指定的时间

```java
    @Test
    public void timeOut() throws InterruptedException {
        Random rand = new Random();
        CountDownLatch latch = new CountDownLatch(1);
        Flux.interval(Duration.ofMillis(300))
                //时间超过指定毫秒后直接报异常
                .timeout(Duration.ofMillis(rand.nextInt(20) + 290))
                .subscribe(item -> System.out.println(item),
                        ex ->
                        {
                            System.out.println("ex:" + ex);
                            latch.countDown();
                        },
                        () -> {
                            System.out.println("finish");
                            latch.countDown();
                        }
                );
        System.out.println("开始:");
        latch.await(3, TimeUnit.SECONDS);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
0
1
ex:java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 299ms in 'source(FluxInterval)' (and no fallback has been configured)
结束
```

弹珠图：

![image-20241208231808564](.\images\image-20241208231808564.png)



**timestamp操作符**

为响应式流的每个元素都生成一个时间戳

```java
    @Test
    public void timestamp() throws InterruptedException {

        Flux.interval(Duration.ofMillis(300))
                .timestamp()
                .subscribe(item -> {
                            Long timestamp = item.getT1();
                            long element = item.getT2();
                            System.out.println("元素：" + element + "的时间戳:" + timestamp);
                        }
                );
        System.out.println("开始:");
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
元素：0的时间戳:1733671378335
元素：1的时间戳:1733671378640
元素：2的时间戳:1733671378932
元素：3的时间戳:1733671379239
元素：4的时间戳:1733671379527
元素：5的时间戳:1733671379831
元素：6的时间戳:1733671380137
元素：7的时间戳:1733671380430
元素：8的时间戳:1733671380735
结束
元素：9的时间戳:1733671381038
```

弹珠图：

![image-20241208232658572](.\images\image-20241208232658572.png)

**elapsed操作符**

为响应式流中的每个元素与上一个元素的时间间隔

```java

    @Test
    public void elapsed() throws InterruptedException {
        Flux.interval(Duration.ofMillis(300))
                .elapsed()
                .subscribe(item -> {
                            Long interval = item.getT1();
                            long element = item.getT2();
                            System.out.println("元素：" + element + "与上一个元素的时间间隔:" + interval + "ms");
                        }
                );
        System.out.println("开始:");
        Thread.sleep(3000);
        System.out.println("结束");
    }
```

输出：

```tex
开始:
元素：0与上一个元素的时间间隔:318ms
元素：1与上一个元素的时间间隔:295ms
元素：2与上一个元素的时间间隔:304ms
元素：3与上一个元素的时间间隔:288ms
元素：4与上一个元素的时间间隔:312ms
元素：5与上一个元素的时间间隔:287ms
元素：6与上一个元素的时间间隔:306ms
元素：7与上一个元素的时间间隔:309ms
元素：8与上一个元素的时间间隔:289ms
结束
元素：9与上一个元素的时间间隔:309ms
```

弹珠图：

![image-20241208232755236](.\images\image-20241208232755236.png)



### 8.11 组合和转换响应式流

当我们构建复杂的响应流工作流时，通常需要在几个不同的地方用相同的操作符序列。

`transform`操作符，可以将这些常见的部分提取到单独的对象中，并在需要时重用它们。

`transform`操作符，可以增强流结构本身。

```java
    @Test
    public void transform() {
        Function<Flux<String>, Flux<String>> logUserInfo = stream ->
                stream.index().doOnNext(
                        item -> System.out.println("时间戳:" + item.getT1() + ",元素：" + item.getT2())
                ).map(Tuple2::getT2);

        Flux.range(100, 3)
                .map(i -> "转换-" + i)
                .transform(logUserInfo)
                .subscribe(item -> System.out.println("next:" + item),
                        e -> System.out.println("error:" + e),
                        () -> System.out.println("finish")
                );
    }
```

输出：

```tex
时间戳:0,元素：转换-100
next:转换-100
时间戳:1,元素：转换-101
next:转换-101
时间戳:2,元素：转换-102
next:转换-102
finish
```

弹珠图:

![image-20241209121242109](D:\work\nullnull\learn\learn-md\webflex\images\image-20241209121242109.png)

`transform`操作符仅在流生命周期的组装阶段更新一次流行为，可以在响应式的应用程序中实现代码重用。



### 8.12 处理器

响应式流规范定了Processor接口，Processor既是Publisher也是Subscriber。

因此，即可以订阅Processor实例，也可以手动向它发送信号（onNext、onErro和OnComplete)。

Reactor的作者建议忽略处理器，因为他们很难用并且容易出错。

在大多数情况下，处理器可以被操作符的组合所取代。另外生成器工厂方法（push、create和generate）可能更适合适配外部API。

Reactor提出以下几种处理器：

- `Direct`处理器只能通过操作处理器的接收器来推送用户手动操作而产生的数据。
  - `DirectProcessor`和`UnicaseProcessor`是这组处理器的代表。
  - `DirectProcessor`不处理背压，可用于向多个订阅者发布事件。
  - `UnicastProcessor`使用内部队列处理背压，最多只能为一个`Subscriber`服务。
- `Synchronous`处理器
  - `EmitterProcessor`和 `replayProcessor`可以同时通过手动方式和订阅上游Publisher的方式来推送数据。
  - `EmitterProcessor`可以为多个订阅者提供服务并满足它们的需求，但仅能以同步方式消费单一Publisher产生的数据。
  - `ReplayProcessor`的行为类似于`EmitterProcessor`,但是它能使用几种策略来缓存传入的数据。
- Asynchronous处理器
  - `workQueueProcessor`和`TopicProcessor`可以推送从多个上游发布者处获得的下游数据。
  - 为了处理多个上游发布者，这些处理器使用RingBuffer的数据结构。这些处理器具有专用的构建器API，因为配置选项的数软件管家使它们很难初始化。
  - `WorkQueueProcessor`具有与`TopicProcessor`类似的特性，但是，它放宽了一个响应式流要求，这便它在运行时所使用的资源更少。



### 8.13 测试与调度Project Reactor

Reactor库附带了一个通用的测试框架。`io.projectreactor:reactor-test`库提供了测试Project Reactor所实现的响应式工作流所需的所有必要工具。

虽然响应式代码不那么容易调度，从早到晚 Project Reactor提供了能在需要时简化调试过程的技术。与任何基于回调的框架一样。Project Reactor中的栈跟踪信息量不大。它们没有在代码中给出发生异常情况的准确位置。Reactor库库具有面向调试的组装时检测功能。可使用：

```java
Hooks.onOperatorDebug();
```

示例程序

```java
    @Test
    public void onDebug()
    {
        Hooks.onOperatorDebug();

        Flux.range(1,10)
                .map(item -> "map-"+item)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .subscribe(System.out::println);
    }
```

输出：

```tex
map-1
map-2
map-3
map-4
map-5
map-6
map-7
map-8
map-9
map-10
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:19)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Assembly trace from producer [reactor.core.publisher.FluxError] :
	reactor.core.publisher.Flux.error(Flux.java:871)
	com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
Error has been observed at the following site(s):
	|_      Flux.error ⇢ at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
	|_ Flux.concatWith ⇢ at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:20)
Stack trace:
		at com.nullnull.recator.TestFluxDebug.onDebug(TestFluxDebug.java:19)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:568)
		at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
		at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
		at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
		at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
		at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
		at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
		at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
		at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
		at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
		at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
		at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
		at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
		at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
```

启用后，此功能开始收集将要组装的所有流的栈跟踪，稍后此信息可以基于组装信息扩展栈跟踪信息，从而帮助我们更快地现问题，但是创建栈跟踪的过程成本很高，因此作为最后的技术手段，它就只以受控的方法进行激活。



此外Project Reactor的Flux和Mono类型提供了一个被称为log的便捷方法。它能记录使用操作符的所有信号，即便在调试情况下，许多方法自定义实现也可以提供足够的自由度来跟踪所需的数据。

```java
    @Test
    public void onLog() {
        Flux.range(1,5)
                .map(item -> "map-"+item)
                .concatWith(Flux.error(new RuntimeException("手动异常")))
                .log()
                .subscribe(System.out::println);
    }
```

输出：

```tex
[ INFO] (main) onSubscribe(FluxConcatArray.ConcatArraySubscriber)
[ INFO] (main) request(unbounded)
[ INFO] (main) onNext(map-1)
map-1
[ INFO] (main) onNext(map-2)
map-2
[ INFO] (main) onNext(map-3)
map-3
[ INFO] (main) onNext(map-4)
map-4
[ INFO] (main) onNext(map-5)
map-5
[ERROR] (main) onError(java.lang.RuntimeException: 手动异常)
[ERROR] (main)  - java.lang.RuntimeException: 手动异常
java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onLog(TestFluxDebug.java:28)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 手动异常
Caused by: java.lang.RuntimeException: 手动异常
	at com.nullnull.recator.TestFluxDebug.onLog(TestFluxDebug.java:28)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

```

### 8.14 Reactor插件

Project Reactor是一个通用且功能丰富的库，但是，它无法容纳所所有用的响应式工具，因此有一些项目在一个领域扩展了Reactor的功能，官方的Reactor插件为Reactor项目提供了几个模块。

`reactor-adapter`模块为Rxjava2响应式类型和调度程序提供桥接，此外，该模块还能与Akka进行集成。

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-adapter</artifactId>
    <version>3.4.0</version>
</dependency>
```

`reactor-logback`模块提供高速异步日志记录功能。它以logBack的AsyncAppender和LMAX Disruptor的RingBuffer为基础，其中后者通过Reactor的Processor实现

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-logback</artifactId>
    <version>3.2.6.RELEASE</version>
</dependency>
```

reactor-extra 模块包含用于高级需求的其他实用程序。例如，该模块包含 TupleUtils类，该类简 化了编写 Tuple 类的代码。此外，该模块具有 MathFlux类，可以从数字源中计算最小值和最大值，并 对它们求和或取平均。 ForkJoinPoolScheduler 类使 Java 的 ForkJoinPool 适配 Reactor 的  Scheduler。

```xml
<dependency>
    <groupId>io.projectreactor.addons</groupId>
    <artifactId>reactor-extra</artifactId>
    <version>3.4.0</version>
</dependency>
```

此外，Project Reactor 生态系统还为流行的异步框架和消息代理服务器提供了响应式驱动程序。 Reactor RabbitMQ 模块使用熟悉的 Reactor API 为 RabbitMQ 提供了一个响应式 Java 客户端。 该模块不仅提供具有背压支持的异步非阻塞消息传递，还使应用程序能够通过使用 Flux和 Mono 类 型将 RabbitMQ 用作消息总线。

```xml
<dependency>
    <groupId>io.projectreactor.rabbitmq</groupId>
    <artifactId>reactor-rabbitmq</artifactId>
    <version>1.5.0</version>
</dependency>
```

Reactor Kafka 模块为 Kafka 消息代理服务器提供了类似的功能。

```xml
<dependency>
    <groupId>io.projectreactor.kafka</groupId>
    <artifactId>reactor-kafka</artifactId>
    <version>1.3.1</version>
</dependency>
```

另一个广受欢迎的 Reactor 扩展被称为 Reactor Netty。它使用 Reactor 的响应式类型来适配Netty  的 TCP/HTTP/UDP 客户端和服务器。Spring WebFlux 模块在内部使用 Reactor Netty 来构建非阻塞式  Web 应用程序。

```xml
<dependency>
    <groupId>io.projectreactor.netty</groupId>
    <artifactId>reactor-netty</artifactId>
    <version>1.0.2</version>
</dependency>
```





## 9 Project Reactor 高级

### 9.1 响应式流的生命周期

要理解多线程的工作原理以及Reactor中实现的各种内部优化，首先必须了解Reactor中响应式类型的生命周期。

**组装时**

流生命周期的第一部分是组装时（assembly-time）

Reactor提供了一个流式API，用于构建复杂的元素处理流程。

Reactor的API看起来像是一个组合流程中所选择操作符的构建器。

构建器不仅是可变的，还假设像build这样的终端操作会执行另一个对象的构建。

在响应式库中，构建执行流程的过程称为组装（assembing）。

如果从头开发，不考滤Reactor API,流组装的可能表现形式:

```java
Flux<Integer> sourceFlux = new FluxArray(1,20,300,4000);
Flux<String> mapFlux = new MapFlux(sourceFlux,String::valueOf);
Flux<String> filterFlux = new Flux(mapFlux,s -> s.length() > 1);
//...
```

在底层Flux对象是相互组合的。在组装过程中，就获得了一个Publishers链，每个新的Publisher包装前一个。

伪代码：

```java
FluxFilter(
	FluxMap(
    	FiluaArray(1,20,300,4000);
    )
)
```

在流生命周期中，该阶段着重要的作用，因为在流组装期间，可以通过检测流的类型来一个接一个地替换操作符。

```java
	public final Flux<T> concatWith(Publisher<? extends T> other) {
		if (this instanceof FluxConcatArray) {
			@SuppressWarnings({ "unchecked" })
			FluxConcatArray<T> fluxConcatArray = (FluxConcatArray<T>) this;

			return fluxConcatArray.concatAdditionalSourceLast(other);
		}
		return concat(this, other);
	}
```

如果是FluxConcatArray，则不创建新的流，直接加入到链中，以这种方式可以改善整体流性能。

此外在组装时，可以在组装过程中为流提供一些hooks，并启用一些额外的日志记录、跟踪、度量收集，以及其他在调试或者流监控期间可以有用的重要补充。

在该阶段，可以操作流的构建过程并应用不同的技术来优化、监控或者更好的进行流调试，这是构建响应流必不可少的部分。



**订阅时**

流执行生命周期的第二个重要阶段是订阅（subscription-time）

当调用指定的Publisher的subscribe方法时，就会发生订阅。

为了构建执行流程，对Publisher进行相互传递，因而产生了Publisher链。一旦调用 了顶层包装器subscribe方法，就开始了该链的订阅过程。

最终将得到一个订阅的相互包装链

```java
filterFlux.subscribe(Subscriber) {
    mapFlux.subscribe(new FilterSubscriber(Subscriber)) {
        arrayFlux.subscribe(new MapSubscriber(FilterSubscriber(Subscriber))) 
{
            // 在这里开始推送真正的元素
       }
   }
}
```



```java
ArraySubscriber(
 MapSubscriber(
   FilterSubscriber(
       Subscriber
       )
   )
)
```



订阅时的重要性在于：

1. 在该阶段中，可以执行与组装阶段相同的优化。
2. 其次在Reactor中启用多线程的一些操作符能更改订阅所发生的工作单元。



**运行时**

流执行的最后一步是运行是（runtime）阶段

在该阶段（Publisher）和（Subscriber）之前进行实际信号交换。

响应式流规范规定，Publisher和Subscriber交换的前两个信号是onSubscribe信号和request信号。



![image-20241209225123264](.\images\image-20241209225123264.png)



### 9.2 Reactor中线程调度模型

publisherOn操作符能将部分运行时操作的执行移动到指定的工作单元。

为了指定应该在运行时处理元素的工作单元，Reactor为此引入了一个特定的抽象，叫作Scheduler。Scheduler是一个接口，代表Project Reactor中的一个工作单元或工作单元池。

```java
Scheduler schedule = ...;
Flux.rang(1,100)
    .map(String::valueof)
    .filter(s -> s.length() > 1)
    .publishOn(scheduler)
    .map(this::calculateHash)
    .map(this::doBusinessLogic)
    .subscriber();
```

publishOn操作符之后的执行位于不同的Scheduler工作单元上。

执行模型：

![image-20241209225747171](.\images\image-20241209225747171.png)

publishOn操作符的重点是运行时执行，在底层，publishOn操作符会保留一个队列，并为该队列提供新元素，以便专用工作单元消费消息并逐个处理它们。

注意：响应式流中的甩胡元素都是逐个处理的（而不是同时处理的）因此可能始终为所有事件定义严格的顺序，此属性也被称为串行化。

**使用PublishOn操作符实现并行化**

![image-20241209230104341](.\images\image-20241209230104341.png)

如果在流程中放置一个PublishOn就可能加快处理速度：

![image-20241209230210024](.\images\image-20241209230210024.png)

**subscribeOn操作符**

Reactor中的多线程另一个要点是名为subscribeOn的操作符，与publishOn相比，subscribeOn使你能更改正在运行的订阅链的工作单元。

当从函数的执行过程中创建流的数据源时，此操作符很有用。

通常此类执行在订阅时进行，它会调用一个函数，该函数会提供执行.subscrbe方法的数据源。

左侧是订阅，右侧是消费

![image-20241209230547393](.\images\image-20241209230547393.png)

**并行操作符**

除了一些重要操作符（用于管理想要处理的执行流某些部分的线程），Reactor还提供了一种熟悉的并行技术。为此，Reactor有一个名为`parallel`的操作符，它能将流分割为并行子流并均衡它们之间的元素。

```java
    @Test
    public void parallel() throws InterruptedException {
        Random rand = new Random();
        CountDownLatch downLatch = new CountDownLatch(1);
        Flux.range(1, 32)
                .doOnNext((item) ->
                        System.out.println("parallel:" + Thread.currentThread().getName() + ",item --> " + item)
                )
                //轮询方式将元素交给保修处理器核心来处理，这里只是准备阶段，需要调度runOn真正调度执行。
                .parallel()
                //每个处理器一个执行单元，12c16t，线程名称：runOn:parallel-{1-16}
                .runOn(Schedulers.parallel())
                //执行转换操作
                .map(num -> num + rand.nextInt(10000))
                .doOnNext(item -> System.out.println("map:" + Thread.currentThread().getName()))
                //仅过滤也偶数信息
                .filter(num -> num % 2 == 0)
                .doOnNext((item) -> System.out.println("filter:" + Thread.currentThread().getName()))
                .subscribe(item -> System.out.println(Thread.currentThread().getName() + "-" + item),
                        ex -> {
                            System.out.println("error:" + ex);
                            downLatch.countDown();
                        },
                        () -> {
                            System.out.println("finish线程:" + Thread.currentThread().getName());
                            downLatch.countDown();
                        }
                )
        ;


        System.out.println("等待开始:" + LocalDateTime.now());
        downLatch.await(5, TimeUnit.SECONDS);
        System.out.println("等待结束:" + LocalDateTime.now());
    }
```

输出：

```tex
parallel:main,item --> 1
parallel:main,item --> 2
parallel:main,item --> 3
parallel:main,item --> 4
parallel:main,item --> 5
parallel:main,item --> 6
parallel:main,item --> 7
parallel:main,item --> 8
parallel:main,item --> 9
parallel:main,item --> 10
parallel:main,item --> 11
parallel:main,item --> 12
parallel:main,item --> 13
parallel:main,item --> 14
parallel:main,item --> 15
parallel:main,item --> 16
parallel:main,item --> 17
parallel:main,item --> 18
parallel:main,item --> 19
parallel:main,item --> 20
parallel:main,item --> 21
parallel:main,item --> 22
parallel:main,item --> 23
map:parallel-16
map:parallel-14
map:parallel-6
map:parallel-3
filter:parallel-3
map:parallel-2
filter:parallel-2
map:parallel-10
map:parallel-7
parallel:main,item --> 24
map:parallel-9
parallel:main,item --> 25
filter:parallel-9
parallel-9-1328
map:parallel-9
filter:parallel-9
parallel-9-7224
map:parallel-11
map:parallel-13
map:parallel-15
filter:parallel-15
map:parallel-1
filter:parallel-1
parallel-15-1894
parallel:main,item --> 26
map:parallel-7
filter:parallel-7
parallel-2-2314
parallel-3-4848
map:parallel-2
map:parallel-12
filter:parallel-12
map:parallel-8
map:parallel-5
filter:parallel-6
map:parallel-4
parallel-6-6202
map:parallel-5
parallel:main,item --> 27
map:parallel-8
filter:parallel-8
parallel-12-3694
map:parallel-3
filter:parallel-3
parallel-3-1134
parallel-7-4446
parallel-1-1820
map:parallel-1
parallel:main,item --> 28
parallel-8-5714
map:parallel-6
map:parallel-4
parallel:main,item --> 29
parallel:main,item --> 30
parallel:main,item --> 31
parallel:main,item --> 32
map:parallel-12
map:parallel-15
map:parallel-16
map:parallel-13
map:parallel-11
finish线程:parallel-2
finish线程:parallel-3
finish线程:parallel-5
finish线程:parallel-9
finish线程:parallel-6
map:parallel-14
filter:parallel-14
finish线程:parallel-13
finish线程:parallel-7
finish线程:parallel-16
filter:parallel-15
filter:parallel-12
map:parallel-10
parallel-12-2016
parallel-15-6388
parallel-14-806
finish线程:parallel-8
finish线程:parallel-4
finish线程:parallel-11
finish线程:parallel-1
finish线程:parallel-14
finish线程:parallel-15
finish线程:parallel-10
finish线程:parallel-12
等待开始:2024-12-10T09:25:34.147238
等待结束:2024-12-10T09:25:34.148237400

```

`parallel`是FluxAPI的一部分，通过应用`parallel`操作符，开始在不同类型的Flux上执行操作，该Flux称为`ParallelFlux`。

`ParallelFlux`是一组Flux的抽象，其中源Flux中的元素是<font color="red">均衡</font>的，然后应用runOn操作符，可以将publishOn应用于内部Flux，并分配与元素（正在不同工作单元之彰进行处理）相关的工作。

**调度器**

调度器是一个接口，具有两个核心方法，即`Scheduler.schedlue`和`Scheduler.createWorker`.

`Scheduler.schedlue`可以调度Runable任务，

`Scheduler.createWorker`不仅为我们提供了Worker专用的实例，还可以以相同方式调度Runable任务。Scheduler接口和Worker接口之间的核心区别在于Scheduler接口表示工作单元池，而Worker是Thread或资源的专用抽象。

默认情况下，Reactor提供了3个核心调度程序接口实现：

1. `SingleSchedule`能为一个专用工作单元安排所有可能的任务。它具有时间性，因此可以延迟安排定期事件。此调度程序可以使用`Schedule.single()`调用进行引用。
2. `ParallelScheduler`适用于固定大小的工作单元池（默认情况下，其大小受CPU内核数限制），适合于CPU密集形任务。此外默认情况下，它也可以处理与时间相关的调度事件。此调度程序可以使用`Scheduler.parallel`调用进行引用。
3. `ElasticScheduler`可以动态创建工作单元并缓存线程池，由于其所创建的线程池没有最大数量限制，因此调度程序非常适用于I/O密集形调度，此调度程序可以使用`Schedule.elastic()`调用进行引用。

此外还可以实现具有所期望的特性的Scheduler。

**响应式上下文**

Reactor附带的另一个关键功能是Context。Context是沿数据流传递接口。

Context接口的核心思想是提供某些上下文信息的访问，因为这些信息可能在稍后运行阶段有用。

ThreadLocal在多线程环境中的问题

```java
    @Test
    public void threadLocal() throws InterruptedException {
        Random random = new Random();

        ThreadLocal<Map<Object, Object>> threadLocal = new ThreadLocal<>();
        threadLocal.set(new HashMap<>());
        Flux.range(0, 10)
                .doOnNext(item -> threadLocal.get().put(item, random.nextGaussian()))
                //多线程调度执行
                .publishOn(Schedulers.parallel())
                .map(key -> threadLocal.get().get(key))
                .blockLast();

        Thread.sleep(1000);
    }
```

输出：

```tex
java.lang.NullPointerException: Cannot invoke "java.util.Map.get(Object)" because the return value of "java.lang.ThreadLocal.get()" is null

	at com.nullnull.recator.TestFluxContext.lambda$threadLocal$1(TestFluxContext.java:27)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:113)
	at reactor.core.publisher.FluxPublishOn$PublishOnSubscriber.runAsync(FluxPublishOn.java:440)
	at reactor.core.publisher.FluxPublishOn$PublishOnSubscriber.run(FluxPublishOn.java:527)
	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)
	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99)
		at reactor.core.publisher.Flux.blockLast(Flux.java:2494)
		at com.nullnull.recator.TestFluxContext.threadLocal(TestFluxContext.java:28)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:568)
		at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
		at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
		at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
		at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
		at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
		at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
		at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
		at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
		at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
		at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
		at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
		at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
		at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
		at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
		at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
```

在多线程环境中使用ThreadLocal是非常危险的，并可能导致意外发生，尽管JavaAPI能将ThreadLocal从数据从一个线程传输到另外一个线程。但它并不保证传输的完全一致性。

Reactor的Context，解决了这个问题。

```java
    @Test
    public void context() {
        Random random = new Random();

        String key = "keys";

        Object lastValue = Flux.range(0, 10)
                .flatMap(k ->
                        Mono.subscriberContext()
                                .doOnNext(context -> {
                                    Map<Object, Object> map = context.get(key);

                                    map.put(k, random.nextGaussian());
                                }).thenReturn(k)
                )
                //并行化执行
                .publishOn(Schedulers.parallel())
                .flatMap(k ->
                        Mono.subscriberContext()
                                .map(context -> {
                                    Map<Object, Object> map = context.get(key);
                                    return map.get(k);
                                })
                )
                .subscriberContext(context -> context.put(key, new HashMap<>()))
                .blockLast();

        System.out.println("结果：" + lastValue);
    }
```

输出：

```tex
结果：-0.4618533277499057
```

翻看源码：

```java
	@Deprecated
	public static Mono<Context> subscriberContext() {
		return onAssembly(MonoCurrentContext.INSTANCE);
	}
```

查看MonoCurrentContext类

```java
final class MonoCurrentContext extends Mono<Context>
		implements Fuseable, Scannable {

	static final MonoCurrentContext INSTANCE = new MonoCurrentContext();

	@SuppressWarnings("unchecked")
	public void subscribe(CoreSubscriber<? super Context> actual) {
		Context ctx = actual.currentContext();
		actual.onSubscribe(Operators.scalarSubscription(actual, ctx));
	}

	@Override
	public Object scanUnsafe(Attr key) {
		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
		return null;
	}
}
```



既然Context接口具有与Map接口类型的方法，那为什么 需要使用Map来传输数据？

答案是：Context是不可变对象，一旦向它添加元素，它就实现了Context的新实例，这样的设计有利于多线程访问模型。

这意味着，这是向流中提供Context并动态提供某些数据的唯一方法。这些数据在组装或者订阅时的整个运行期间可用。如果在组装时提供了Context，那么所有订阅者将共享相同的静态上下文，但这在每个Subscriber具有其自身的Context的情况下可能没有用。因此可以向每个Subscriber提供其自身上下文的唯一生命周期时段的订阅时阶段。

```java
    @Test
    public void contextRun() {
        printCurrentContext("top")
                .subscriberContext(Context.of("top", "Context"))
                .flatMap(data -> printCurrentContext("middle"))
                .subscriberContext(Context.of("middle", "context"))
                .flatMap(data -> printCurrentContext("bottom"))
                .subscriberContext(Context.of("bottom", "context"))
                .flatMap(data -> printCurrentContext("initial"))
                .block();
    }

    private void print(String id, Context context) {
        System.out.println(id + "{");
        System.out.println(context);
        System.out.println("}");
    }


    Mono<Context> printCurrentContext(String id) {
        return Mono.subscriberContext()
                .doOnNext(context -> print(id, context));
    }
```

输出：

```tex
top{
Context3{bottom=context, middle=context, top=Context}
}
middle{
Context2{bottom=context, middle=context}
}
bottom{
Context1{bottom=context}
}
initial{
Context0{}
}
```



### 9.3 Project Reactor内幕

Project Reactor3最显著的改进就是：

响应流生命周期(Reactive Stream life-cycle)和操作符融合(operator fusion)。

**宏融合**

宏融合主要发生在组装时，其目的用一个操作符替换掉另一个操作符。



**微融合**

微融合(micro-fusion)是一种更复杂的优化，与运行时优化以及我不用共享资源有关，微融合的一个很好的例子是条件操作符：

![image-20241210123458991](.\images\image-20241210123458991.png)

商店订购了 n 件商品。过了一段时间，工厂用卡车将物品送到商店。 但是，为了最终到达商店，卡车必须通过检验部门，以确保所有商品质量合格。由于有些物品没有 仔细包装，因而只有部分订单到达了商店。在那之后，工厂准备了另一辆卡车，再次往商店送货。这种 情况反复发生，直到所有订购的商品到达商店。幸好，工厂意识到他们在使商品通过单独的检验部门上 花了太多的时间和金钱，并决定从检验部门雇用检验员到本地。

![image-20241210123539425](.\images\image-20241210123539425.png)

所有物品现在都可以在工厂进行检验后送到商店，而无须前往检验部门。

根据当前响应式库（例如RxJava 或 Reactor 3）的设计，request 操作有自己的额外 CPU 开销。  

根据 David Karnok 的研究，每个“对 request()的调用通常最终都在一个原子 CAS 循环中，而 每 21~45 个循环会掉落一个元素”。 

 这意味着条件操作符（如 filter 操作符）可能对整体性能产生重大影响！出于这个原因，出现了一 种被称为 ConditionalSubscriber 的微融合类型。 这种类型的优化使我们能在数据源端验证条件，并发送所需数量的元素而无须额外的 request 调 用。 



为了避免内存开销和性能开销，应该遵循响应式流规范的建议，切换通信协议。 

假设一个或多个边界内的元素链具有共享队列，那么可以切换整个操作符链以使用上游操作符作为 无须额外 request 调用的队列，这样可以显著提高整体性能。 

因此，下游可以从上游排出值，如果该值不可用于指示流的结束，则返回 null。



以下示例代码：

```java
Flux.just(1, 2, 3)
   .publishOn(Schedulers.parallel())
   .concatMap(i -> Flux.range(0, i).publishOn(Schedulers.parallel()))
   .subscribe();
```

![image-20241210123809645](.\images\image-20241210123809645.png)

优化后：

![image-20241210123907150](.\images\image-20241210123907150.png)

publishOn 和 concatMap 操作符可以被显著优化。在第一种情况下，因为没有必须 在主线程中执行的中间操作符，所以我们可以直接使用 just 操作符作为队列，并在单独的线程上从该队 列中执行 pull 操作。在 concatMap 的情况下，所有内部流也可以被视为队列，以在没有附加任何  request 调用的情况下排出每个流。 

 总之，Reactor 库的内部结构比看起来更复杂。通过强大的优化，Reactor 远远领先于 RxJava 1.x， 从而提供了更好的性能。





第三部分 Spring WebFlux高级实战

## 10 WebFlux作为响应式服务器基础

Spring 框架的整个基础设施都是围绕Servlet API 构建的，它们之间紧密耦合。

Spring框架所做的事情

![image-20241210124119353](.\images\image-20241210124119353.png)

Spring MVC的缺点： 

1. 不允许在整个请求声明周期中出现非阻塞操作。没有开箱即用的非阻塞HTTP客户端。 
2. WebMVC 抽象不能支持非阻塞 Servlet 3.1 的所有功能。 
3. 对于非 Servlet 服务器，重用 Spring Web 功能或变成模块不灵活。



### 10.1 响应式Web内核

响应式Web内核首先需要使用模拟接口和对请求进行处理的方法替换 javax.servlet.Servlet.service 方法。 

更改相关的类和接口 

增强和定制 Servlet API 对客户端请求和服务器响应的交互方式。

```java
/** 
  * 请求的封装。
  * 获取请求报文体的类型是Flux，表示具备响应式能力。
  * DataBuffer是针对字节缓冲区的抽象，便于对特定服务器实现数据交换。
  * 除了请求报文体，还有消息头、请求路径、cookie、查询参数等信息，可以在该接口或子接口中提
供。
  */
interface ServerHttpRequest {
    // ...
    Flux<DataBuffer> getBody();
    // ...
}
/**
   * 响应的封装。
   * writeWith方法接收的参数是Publisher，提供了响应式，并与特定响应式库解耦。
   * 返回值是Mono<Void>，表示向网络发送数据是一个异步的过程。
   * 即，只有当订阅Mono时才会执行发送数据的过程。
   * 接收服务器可以根据传输协议的流控支持背压。
   */
interface ServerHttpResponse {
    // ...
    Mono<Void> writeWith(Publisher<? extends DataBuffer> body);
    // ...
}
/**
  * HTTP请求-响应的容器。
  * 这是高层接口，除了HTTP交互，还可以保存框架相关信息。
  * 如请求的已恢复的WebSession信息等。
  *
  *
  */
interface ServerWebExchange {
    // ...
    ServerHttpRequest getRequest();
    ServerHttpResponse getResponse();
     // ...
    Mono<WebSession> getSession();
    // ...
}
```

上述三个接口类似于Servlet API 中的接口。 响应式接口旨在从交互模型的角度提供几乎相同的方法，同时提供开箱即用的响应式。

请求的处理程序和过滤器 API：

```java
/**
  * 对应于WebMVC中的DispatcherServlet
  *   查找请求的处理程序，使用视图解析器渲染视图，因此handle方法不需要返回任何结果。
  * 
  * 返回值Mono<Void>提供了异步处理。
  * 如果在指定的时间内没有信号出现，可以取消执行。
  */
interface WebHandler {
    Mono<Void> handle(ServerWebExchange exchange);
}
/**
  * 过滤器链
  */
interface WebFilterChain {
    Mono<Void> filter(ServerWebExchange exchange);
}
/**
  * 过滤器
  */
interface WebFilter {
    Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain);
}


/**
 * 需要为这些接口适配不同的服务器。
 * 即与ServerHttpRequest和ServerHttpResponse进行直接交互的组件。
 * 同时负责ServerWebExchange的构建，特定的会话存储、本地化解析器等信息的保存。
 *
 */
public interface HttpHandler {
    Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse 
response);
}
```

通过该适当的抽象，隐藏了服务器引擎的细节，具体服务器的工作方式对 Spring WebFlux 用户不 重要。



### 10.2 响应式WEB和MVC框架

Spring Web MVC 模块的关键特性 基于注解。因此，需要为响应式Web 栈提供相同的概念。

重用 WebMVC 的基础设施，用 Flux 、 Mono 和 Publisher 等响应式类型替换同步通信。  

保留与 Spring Web MVC 相同的 HandlerMapping 和 HandlerAdapter 链，使用基于 Reactor 的 响应式交互替换实时命令：

```java
interface HandlerMapping {
    /*
    HandlerExecutionChain getHandler(HttpServletRequest request)
    */
    Mono<Object> getHandler(ServerWebExchange exchange);
}
interface HandlerAdapter {
    
    boolean supports(Object handler);
    /*
    ModelAndView handle(HttpServletRequest request, HttpServletResponse 
response, Object handler);
    */
    Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);
}
```

响应式 HandlerMapping 中，两个方法整体上类似， 不同之处在于响应式返回Mono 类型支持响应式。 

 响应式HandlerAdapter 接口中，由于 ServerWebExchange 类同时组合了请求和响应，因此  handle 方法的响应式版本更简洁。 

该方法返回 HandlerResult 的 Mono 而不是 ModelAndView 。

得到最终的结构：

![image-20241210124709705](.\images\image-20241210124709705.png)



1. 传入请求，由底层服务器引擎处理。服务器引擎列表不限于基于ServletAPI 的服务器。每个服 务器引擎都有自己的响应式适配器，将 HTTP 请求和 HTTP 响应的内部表示映射到  ServerHttpRequest 和 ServerHttpResponse 。
2. HttpHandler 阶段，该阶段将给定的 ServerHttpRequest 、 ServerHttpResponse 、用户  Session 和相关信息组合到 ServerWebExchage 实例中。
3. WebFilterChain 阶段，它将定义的 WebFilter 组合到链中。然后， WebFilterChain 会 负责执行此链中每个 WebFilter 实例的 WebFilter#filter 方法，以过滤传入的 ServerWebExchange 。
4. 如果满足所有过滤条件， WebFilterChain 将调用 WebHandler 实例。 
5. 查找 HandlerMapping 实例并调用第一个合适的实例。可以是RouterFunctionMapping、也 可以是RequestMappingHandlerMapping 和HandlerMapping 资源。 RouterFunctionMapping，引入到WebFlux 之中，超越了纯粹的功能请求处理。
6. RequestMappingHandlerAdapter 阶段，与以前功能相同，使用响应式流来构建响应式流。

在WebFlux 模块中，默认服务器引擎是Netty。

Netty 服务器很适合作为默认服务器，因为它广泛用于响应式领域。

该服务器引擎还同时提供客户端和服务器异步非阻塞交互。 同时，可以灵活地选择服务器引擎。





## 结束
