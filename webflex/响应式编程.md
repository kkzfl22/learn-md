# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241126091852663](.\images\image-20241126091852663.png)



**响应延迟**

传统命令式编程的另一个问题是：当一个服务需要做很多操作而不仅仅是IO请求的时候，响应延迟相应的增大。

如服务A需要调用服务B和服务C，比如查询数据库，聚合结果并返回。意味着服务A的响应时间包括：

- 服务B的响应时间（网络延迟时间+处理时间）
- 服务C的响应时间（网络延迟时间+处理时间）
- 数据请求响应时间（网络延迟时间+处理时间）



![image-20241126091817119](D:\work\nullnull\learn\learn-md\webflex\images\image-20241126091817119.png)

如果服务调用没有前后依赖关系，则可以并行调用服务，如果使用java的CompletableFuture异步调用并注册回调，开发会复杂很多，而且阅读和维护也会复杂很多。



**压垮客户端**

微服务另外一个问题就是：服务A请求服务B的数据，如果数据量非常的时候，超过了服务A能处理的程度，则会导致服务OOM。



**总结**

这些问题都是响应式编程要解决的。

优势：

- 不用Thread per Request模型，使用少量线程即可处理大量的请求。
- 在执行IO操作时不让线程等待。
- 简化并行调用。
- 支持背压，让客户端告诉服务端它能处理多少负载。

### 1.1.1  消息驱动通信

响应式编程的定义

响应式编程使用异步、事件驱动构建非阻塞式应用的。此类应用仅需少量的线程用于横向扩展。

该定义的关键一点是：借助背压技术，防止生产者压垮消费者。

**怎么做？**

答案就是使用异步数据流编程。

如果服务A需要从服务B获取数据。对于响应式编程，服务A向服务B发起请求，并立即返回（非阻塞异步）。

之后请求的数据以数据流的方式返回给服务A，服务B对每个数据项发布onNext事件，当所有的数据都发布了OnNext事件，就发布OnComplete事件结束，如果发生异常，服务B就发布OnError事件，之后不再发布OnNext事件。

![image-20241126093315691](.\images\image-20241126093315691.png)

响应式编程使用函数式编程风格，用于对数据流进行不同的转换。

流可以作为输入，也可以合并，映射和过滤等。

**响应式系统**

响应式系统的设计目标：

- 响应性（以时序的方式响应）
- 健壮（即使发生错误也可以保证响应性）
- 弹性（在不同的工作负载下保持响应性）
- 消息驱动（依赖异步消息传递机制）

响应式编程可以确保单个服务的异步非阻塞，整个系统的响应式需要整体考滤。



### 1.2 响应式应用案例

**响应式编程是使用异步数据流进行编程**

流是一个时序事件序列，可以发送三种不同的事件：（某种类型的）值 、错误或者一个完成信号。

分为值、错误、完成定义事件的函数，异步的处理事件。

监听一个流称为订阅，定义的函数称为观察者，流是被观察者，即观察者模式。

每个流会有多个方法，如map、filter、scan等等。

当调用其中一个方法时，它会基于原来的流返回一个新的流。

它不对原来的点击流做任何的修改，这个特性称为不变性，也可以称为方法链式调用。

```sh
clickStream:  ---c---c--c---c------c-->
              vvvv map(c becomes 1)vvvv
              ---c---c--c---c------c-->
              vvvvvvvvv scan(+) vvvvvvvv
counterstream:---1---2--3---4------5-->
```

map(f) 会根据提供的f函数把原来Stream中的Value分别映射到新的Stream中

scan(g) 会根据你提供的G函数把Stream中的所有Value聚合成一个Value x=g(sccumulated,current)

每click一次，countStream就会把点击的总次数发送给它的观察者。



### 1.3 响应式编程的现状

2011年，微软发布了.NET的响应式扩展，以方便异步、事件驱动的程序。

ReactiveX混合了迭代器和观察者模式，不同之处在于一个是推模式，一个是基于迭代器的拉模式。

除了对变化事件的观察，完成事件和异常事件也会发送给订阅者。

ReactiveX的基本思想是事件是数据，数据是事件。

响应式扩展被移植到了几种语言和平台上，包括 javascript、Python、C++、swift和java、ReactiveX很快成为一种跨语言的标准，将响应式编程引入到行业中。

RxJava，是java的ReactiveX实现。

RxJava是其他reactivex jvm平台技术的主要技术，其他的如RxScala、RxKotlin、RxGroovy。RxJava已经碾为Android开发的核心技术，并且可以开箱即用的使用RxJava。

这表明RxJava不仅仅是一个库，它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。



### 1.4 为什么采用响应式Spring？

响应式系统非常的复杂，在构建这类系统时困难也非常的多。

要轻松构建响应式系统，就必须首先分析能够构建这类系统的框架，然后选择其中之一。

选择框架最常用的方法之一是分析其可用功能，相关性及社区。

在JVM领域，构建响应式系统最知名的框架是Akka和vert.x生态系统。

一方面,Akka是一个受欢迎的框架，具有大量功能和大型社区，然后，Akka最初是作为Scala生态系统的一部分构建的，在很长一段时间内，它仅在基于Scala编写的解决方法中展示它强大的功能，尽管Scala是一种基于JVM的语言，但它与JAVA明显不同，几年前，Akka直接支持java，但是出于某些原因，它在java世界中不像在Scala世界中那么受欢迎。

另一方法，Vert.x框架也是构建高效响应式系统的强大解决方案，Vert.x的设计初衷是作为Node.js在java虚拟机上的替代方法，它支持非阻塞和事件驱动。然后，Vert.x仅在几年前开始具备竞争力，在过去的15年中，Spring框架一直在构建灵活且健状的应用程序框架市场中占有主导地位。

Spring框架使用适合开发人员的编程模型，为构建Web应用程序提供了广泛的可能性，然后长期以来，它在构建健状的响应式系统方法存在一个局限。

Spring框架在一个单独的线程中包装了阻塞式网络调用，同时Spring MVC依赖于Servlet API ，这使得所有的实现必须使用线程的单次请求（thread-per-request)模型。

这种模型非常不理想，效率低下。

为此，响应式规则建议使用非阻塞的操作，但这是Spring生态系统缺少的。此外Spring也没有与Netty等响应式服务器进行良好的集成，而这些响应式服务器解决了上下文切换的问题。

## 2 无处不在的响应性

### 2.1 API不一致的问题

大量的同类弄响应式可供选择（RxJava、CompletableStage、Vert.x、Akka）

另外一方面，丰富的选择很容易使得系统过于复杂。例如，若存在两个依赖于同一个异步非阻塞通信概念但具有不同的API的库，会导致 我们需要提供额外的工具类，以便将一个回调转换为另外一个回调，反之亦然。

Spring4.x框架中的ListenableFuture和CompletionStage之间没有直接集成 。

在许多情况下，为了解决几个问题并使得几个独立的库兼容，必须提供自己的适配并在几个地方重用。

自己写的适配可能bug。需要额外的维护。

Spring5.x框架扩展了ListenableFuture的API并且提供了一个Completable的方法来解决不兼容的问题。

这里的核心 问题在于没有标准。



### 2.2 推拉

在整个响应式环境演变的早期阶段，所有库的设计思想都是把数据从源头推送到订阅者。

因为纯粹的拉模型在某些场景下效率不够高。

拉模型

![image-20241126222758306](.\images\image-20241126222758306.png)

问题：

处理时间方面，仍然存在一些效率低下的情况。

发送一批元素比发送一个元素需要更多的时间。

为了提供最终的优化，只会请求一次数据，当数据变为可用时，该数据源异步推送数据。

![image-20241126223017360](.\images\image-20241126223017360.png)

再次对整体处理时间做了优化。在交互过程中，只有当服务等待每个响应时会有大段空间时间，当第一个元素到达后，数据库会在数据到达时开始发送后续元素。



### 2.3 流量控制问题

在生产者与消费者的处理过程中，会存在两边处理速度不一致的问题。两种场景：

1. 慢生产者和快消费者。
2. 快生产者和慢消费者。

使用队列推送数据的关键要素之一是选择有合适特性的队列 

通常有3种。无界队列、有界丢序队列、有限阻塞队列。

**无界队列**

![image-20241126223504790](.\images\image-20241126223504790.png)

此队列的最大问题在于，一旦到达内存上限，整个系统就很容易崩溃。

**有界丢弃队列**

![image-20241126223629051](.\images\image-20241126223629051.png)

此技术考滤了资源的限制，并且可以根据资源的能力配制队列的容易，当消息的重要性很低时，采用这种队列是一种常见的做法。

**有界阻塞队列**

![image-20241126223917359](.\images\image-20241126223917359.png)

遗憾的是这种技术否定了系统的所有异步的行为。通常一旦生产者到达队列的限制。它就会开始被阻塞并将处理该状态，直接消费者消费了一个元素，从而使队列中出现可用空间为止，由此我们可以得出结论，最慢的消费者的吞吐率限制了系统总吞吐量。继而，除了否定异步行为了该技术还否定了有效的资源利用率，因此想要实现回弹性、弹性和即时响应所有的三方法，那么这些场景会部不可接受。





### 2.4 解决方法

来自 Lightbend、Netflix 和 Pivotal 的一群天才工程师齐聚一堂，共同解决上述问题 并为 JVM 社区提供标准。 

经过长达一年的努力，响应式流规范的初稿公诸于世。

其概念就是响应式编程模式的标准化。



## 3 响应式流规范

### 3.1 响应式流规范基础

响应式流规范网站：

```sh
http://www.reactive-streams.org
```

响应式规则发布了一组接口，用于实现：

maven地址:

```xml
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck-flow</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-examples</artifactId>
  <version>1.0.3</version>
</dependency>
```

响应式流规范文档

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
```

**响应式流规范**

响应式流（Reactive Streams）规范，规定了异步组件之前使用背压进行交互。

响应式流在java 9中使用flow API适配。Flow API是互操作的规范，而不是具体的实现，它的主义跟响应式流规范一致。

响应式流规范包括如下接口

**Publisher**

表示数据流的生产者或者数据源，包含一个方法让订阅者注册 到发布者，Puhblisher代表了发布者和订阅者直接连接的标准化入口点。

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```



**Subscriber**

表示消费者，onSubscriber方法为我们提供了一种标准化的方法来通知Subscriber订阅成功。

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- onSubscribe发布者在开始处理之前调用，并向订阅者传递一个订阅票据对象（Subscription).
- onNext 用于通知订阅者发布者发布了新的数据项。
- onError 用于通知订阅者，发布者遇到了异常，不再发布数据事件。
- onComplete 用于通知订阅者所有的数据事件都已经发布完。

**Subscription**

onSubscribe方法的传入参数引入一名为Subscription(订阅)的订阅票据。

Subscription为控制元素的生产提供了基础。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- request 用于让订阅者通知发布者随后 需要发布的元素数量。
- cancel 用于让订阅者取消发布者随后的事件流。

**Processor**

如果实体需要转换进来的项目，并将转换后的项目传递给另一个订阅者，此时需要Processor接口。该接口既是订阅者，又是发布者。

```xml
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```



### 3.2 响应式流规范实战

地址：

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification
```

添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

异步发布者

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Publisher的实现，用于进行数据的生产操作，可以理解为要加工的数据
 *
 * @author nullnull
 * @since 2023/6/27
 */
public class AsyncIterablePublisher<T> implements Publisher<T> {


    /**
     * 默认的批次大小
     */
    private static final int DEFAULT_BATCH_SIZE = 1024;

    /**
     * 迭代器，用于原始数据的生成操作
     */
    private final Iterable<T> iterable;

    /**
     * 线程池接口，用于生成任务的并行执行
     */
    private final Executor executor;

    /**
     * 用于批次处理任务的大小
     */
    private final int batchSize;


    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor) {
        this(iterable, executor, DEFAULT_BATCH_SIZE);
    }

    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor, int batchSize) {
        //进行参数的检查
        if (null == iterable) {
            throw new NullPointerException("iterable is null");
        }

        if (null == executor) {
            throw new NullPointerException("executor is null");
        }

        if (batchSize < 1) {
            throw new IllegalArgumentException("param batch size is < 1");
        }


        this.iterable = iterable;
        this.executor = executor;
        this.batchSize = batchSize;
    }

    @Override
    public void subscribe(Subscriber<? super T> s) {
        new SubscriberImpl(s).init();
    }


    /**
     * 用于处理订阅的信号
     */
    static interface Signal {
    }

    /**
     * 取消订阅的信号
     */
    enum Cancel implements Signal {
        Instance;
    }

    /**
     * 订阅的信号
     */
    enum Subscribe implements Signal {
        Instance;
    }

    /**
     * 发送的信号
     */
    enum Send implements Signal {
        Instance;
    }

    /**
     * 请求的信号
     */
    static final class Request implements Signal {
        final long n;

        public Request(long n) {
            this.n = n;
        }
    }

    /**
     * 订阅票据，实现了Subscription接口和Runnable接口
     */
    final class SubscriberImpl implements Subscription, Runnable {

        /**
         * Subscriber的引用，用于通信
         */
        private final Subscriber<? super T> subscriber;

        /**
         * 该订阅票据是否失效的标志
         */
        private boolean cancelled = false;

        /**
         * 记录订阅者的数量，这些请求还没有对订阅者回复
         */
        private long demand = 0;

        /**
         * 发送给订阅者的数据流
         */
        private Iterator<T> iterator;

        /**
         * 该队列用于记录发送票据的信号（入栈信号），如"request"，"cancel"等。
         * <p>
         * 通过此队列可以在Publisher端使用多线程异步处理
         */
        private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


        /**
         * 确保票据不会并发的标志，
         * <p>
         * 防止在调用订阅者的onXxx方法的时候并发调用。规范1.3规定的不能并发。
         */
        private final AtomicBoolean on = new AtomicBoolean(false);

        public SubscriberImpl(Subscriber<? super T> subscriber) {
            //根据规范，如果Subscriber为null，需要抛空指针异常，此处抛null。
            if (null == subscriber) {
                throw null;
            }

            this.subscriber = subscriber;
        }


        private void doRequest(int n) {
            // 规范规定，如果请求的元素个数小于1，则抛异常
            // 并在异常信息中指明错误的原因：n必须是正整数。
            if (n < 1) {
                terminateDueTo(new IllegalArgumentException(subscriber
                        + "violated the Reactive Streams rule 3.9 by requesting a non -positive number of elements."));
            }
            // 根据规范 3.17，当请求的元素数大于Long.MAX_VALUE的时候，将请求数  设置为Long.MAX_VALUE即可。
            else if (demand + n < 1) {
                //此认为是无界流
                demand = Long.MAX_VALUE;
                //开始向下游发送元素
                doSend();
            }
            //其他情况，表示当前是设置了正常请求数量
            else {
                //记录下请求个数的元素
                demand += n;
                //开始向下游发送元素
                doSend();
            }
        }


        private void doSend() {
            try {
                long leftBatchSize = batchSize;
                //为充分利用线程池，最多发送BatchSize个元素。然后放弃当前线程，重新调度，通知订阅者onNext信号
                do {
                    T next;
                    boolean hashNext;

                    try {
                        //订阅者在订阅的时候，已经调用了hashNext方法，直接获取
                        // Need to keep track of End-of-Stream
                        next = iterator.next();
                        //检查还有没有数据，如果没有了，表示流结束了
                        hashNext = iterator.hasNext();
                    } catch (final Throwable e) {
                        // If `next` or `hasNext` throws (they can, since  it is user - provided),we need to treat
                        // the stream as errored as per rule1.4

                        //如果next方法或者hashNext方法抛出异常（用户提供），认为流招聘了异常了发送onError信号
                        terminateDueTo(e);

                        return;
                    }

                    //向下流订阅者发送next的信号
                    subscriber.onNext(next);

                    //如果已经到达结束位置，
                    if (!hashNext) {
                        // We need to consider this `Subscription` as cancelled as per rule 1.6
                        // 首先考滤票据取消了订阅
                        doCancel();

                        // Then we signal `onComplete` as per rule 1.2 and    1.5
                        //发送onComplete信号给订阅者
                        subscriber.onComplete();
                    }

                } while (
                    //确保当前没有被取消订阅
                    // This makes  sure that rule 1.8 is upheld,
                    // i.e.we need to stop signalling "eventually"
                        !cancelled
                                //并且还有剩余的元素
                                // 如果还有剩余批次的元素。This   makes sure that we only send
                                // `batchSize`number of elements in one go (so  we can yield to other Runnables)
                                && --leftBatchSize > 0
                                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)
                                && --demand > 0);


                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)

                // If the `Subscription` is still alive and well,
                // and we have demand to satisfy, we signal ourselves to send more data

                // 如果订阅票据没有取消，还有请求，通知自己发送更多的数据
                if (!cancelled && demand > 0)
                    signal(Send.Instance);

            } catch (Throwable t) {

                // We can only get here if `onNext` or `onComplete` threw,
                // and they are not allowed to according to 2.13,
                // so we can only cancel and log here.

                // 如果到这里，只能是onNext或onComplete抛异常，只能取消。

                // Make sure that we are cancelled,
                // since we cannot do   anything else since the `Subscriber`is faulty.

                // 确保已取消，因为是Subscriber的问题
                doCancel();

                // 记录错误信息
                (new IllegalStateException(subscriber
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onNext or "
                        + "onComplete. ", t))
                        .printStackTrace(System.err);
            }
        }


        /**
         * 异常给认
         *
         * @param signal
         */
        private void signal(final Signal signal) {
            //将信号放入入栈队列
            if (inboundSignals.offer(signal)) {
                //信号放入线程成功，则调度线程进行处理
                tryScheduleToExecute();
            }
        }

        /**
         * 该方法确保订阅票据同一个时间在同一个线程运行
         * <p>
         * 规范1.3规定，调用`Subscriber`的`onSubscribe`，`onNext`，`onError`和 `onComplete`方法必须串行，不允许并发。
         */
        private final void tryScheduleToExecute() {

            // 使用原子变量进行CAS操作，成功，是说明当前线程可以处理，失败表示已经在处理了
            if (on.compareAndSet(false, true)) {
                try {
                    //向线程池中提交一个任务
                    executor.execute(this);
                    //如果不能提交线程池运行，则优雅的退出
                } catch (Throwable e) {
                    if (!cancelled) {
                        //错误不可恢复，执行取消订阅
                        doCancel();
                        try {
                            // 停止,发送error信号
                            terminateDueTo(new
                                    IllegalStateException("Publisher terminated due to unavailable Executor.",
                                    e));
                        } finally {
                            // 后续的入站信号不需要处理了，清空信号
                            inboundSignals.clear();
                            // 取消当前订阅票据，但是让该票据处于可调度状态，以防清空入站信号之后又有入站信号加入。  异步订阅者：
                            on.set(false);

                        }

                    }

                }
            }

        }


        /**
         * 规范3.5指明，Subscription.cancel方法必须及时的返回，保持调用者的响应性， 还必须是幂等的，必须是线程安全的。
         * <p>
         * 因此该方法不能执行密集的计算。
         */
        private void doCancel() {
            cancelled = true;
        }


        /**
         * 终止订阅，
         * <p>
         * 规范1.6指出，`Publisher`在通知订阅者`onError`或者`onComplete`信号之
         * 前，
         * <p>
         * **必须**先取消订阅者的订阅票据（`Subscription`）。
         * <p>
         * <p>
         * <p>
         * 当发送onError信号之前先取消订阅
         *
         * @param exception
         */
        private void terminateDueTo(Throwable exception) {
            //发送error前，必须取消订阅
            cancelled = true;

            try {
                //给下游发送onError信号
                subscriber.onError(exception);
            } catch (Throwable e) {
                // 规范1.9指出，onError不能抛异常。
                // 如果onError抛异常，只能记录信息。
                (new IllegalStateException(
                        subscriber +
                                "violated the  Reactive Streams rule 2.13 by throwing an exception from onError.", e))
                        .printStackTrace(System.err);
            }
        }


        @Override
        public void run() {
            // 与上次线程执行建立happens-before关系，防止并发执行
            // 如果on.get()为false，则不执行，线程退出
            // 如果on.get()为false，则表示没有线程在执行，当前线程可以执行
            if (on.get()) {
                //1,从队列中取出一个信号
                Signal poll = inboundSignals.poll();
                // 规范1.8：如果`Subscription`被取消了，则必须最终停止向`Subscriber`发送通知。
                // 规范3.6：如果取消了`Subscription`，则随后调用`Subscription.request( long n)`必须是无效的（NOPs）。
                // 如果订阅票据没有取消
                if (!cancelled) {
                    try {
                        //根据信号进行方法的处理操作
                        // 请求
                        if (poll instanceof Request) {
                            doRequest((int) ((Request) poll).n);
                        }
                        //发送信息
                        if (poll == Send.Instance) {
                            doSend();
                        }
                        //取消信号
                        if (poll == Cancel.Instance) {
                            doCancel();
                        }
                        //订阅信号
                        if (poll == Subscribe.Instance) {
                            doSubscribe();
                        }
                    } finally {
                        // 保证与下一个线程调度的happens-before关系
                        on.set(false);
                        //如果还有信号需要处理
                        if (!inboundSignals.isEmpty()) {
                            // 调度当前线程进行处理
                            tryScheduleToExecute();
                        }
                    }

                }
            }


        }

        /**
         * 不是在`Publisher.subscribe`方法中同步地调用`subscriber.onSubscribe` 方法，而是异步地执行subscriber.onSubscribe方法
         * <p>
         * 这样可以避免在调用线程执行用户的代码。因为在订阅者的onSubscribe方法中要执行 Iterable.iterator方法。
         * <p>
         * 异步处理也无形中遵循了规范的1.9。
         */
        private void doSubscribe() {
            try {
                //获取数据源的迭代器
                iterator = iterable.iterator();

                if (iterator == null) {
                    // 如果iterator是null，就重置为空集合的迭代器。我们假设 iterator永远不是null值。
                    iterator = Collections.<T>emptyList().iterator();
                }
            } catch (Throwable e) {
                // Publisher发生了异常，此时需要通知订阅者onError信号。
                // 但是规范1.9指定了在通知订阅者其他信号之前，必须先通知订阅者  onSubscribe信号。
                // 因此，此处通知订阅者onSubscribe信号，发送空的订阅票据
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {
                        // 空的
                    }

                    @Override
                    public void cancel() {
                        // 空的
                    }
                });
                // 根据规范1.9，通知订阅者onError信号
                terminateDueTo(e);
            }

            if (!cancelled) {
                try {
                    // 为订阅者设置订阅票据。
                    subscriber.onSubscribe(this);
                } catch (Throwable e) {
                    // Publisher方法抛异常，此时需要通知订阅者onError信号。
                    // 但是根据规范2.13，通知订阅者onError信号之前必须先取消该订阅 者的订阅票据。
                    // Publisher记录下异常信息。
                    terminateDueTo(new IllegalStateException(subscriber
                            + "violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe. ",
                            e));
                }

                // 立即处理已经完成的迭代器
                boolean hashNext = false;
                try {
                    // 判断是否还有未发送的数据，如果没有，则向订阅者发送onComplete 信号
                    hashNext = iterator.hasNext();
                } catch (Throwable e) {
                    // 规范的1.4规定
                    // 如果hasNext发生异常，必须向订阅者发送onError信号，发送信号之  前先取消订阅
                    // 规范1.2规定，Publisher通过向订阅者通知onError或 onComplete信号，
                    // 发送少于订阅者请求的onNext信号。
                    terminateDueTo(e);
                }


                // 如果没有数据发送了，表示已经完成，直接发送onComplete信号终止订阅 票据。
                // 规范1.3规定，通知订阅者onXxx信号，必须串行，不能并发。
                if (!hashNext) {
                    try {
                        // 规范1.6指明，在通知订阅者onError或onComplete信号之   前，必须先取消订阅者的订阅票据。
                        // 在发送onComplete信号之前，考虑一下，有可能是  Subscription取消了订阅。
                        doCancel();
                        subscriber.onComplete();
                    } catch (final Throwable t) {
                        // 规范2.13指出，onComplete信号不允许抛异常，因此此处只能 记录下来日志
                        (new IllegalStateException(subscriber
                                + " violatedthe Reactive Streams rule 2.13 by throwing an exception from onComplete.",
                                t)).printStackTrace(System.err);
                    }
                }
            }

        }

        /**
         * 注册订阅者发送过来的信号
         *
         * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
         */
        @Override
        public void request(final long n) {
            signal(new Request(n));
        }


        @Override
        public void cancel() {
            signal(Cancel.Instance);
        }

        /**
         * init方法的设置，用于确保SubscriptionImpl实例在暴露给线程池之前已经构造完成
         * <p>
         * 因此，在构造器一完成，就调用该方法，仅调用一次。
         * <p>
         * 先发个信号试一下
         */
        void init() {
            signal(Subscribe.Instance);
        }
    }
```

异步订阅者

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 自定义订阅者信息
 * <p>
 * 基于Executor的异步运行的订阅者实现，一次请求一个元素，然后对每个元素调用用户定义的方
 * 法进行处理。
 * 注意：该类中使用了很多try-catch用于说明什么时候可以抛异常，什么时候不可以抛异常
 *
 * @author liujun
 * @since 2023/6/30
 */
public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {

    /**
     * Signal表示发布者和订阅者之间的异步协议
     */
    private static interface Signal {
    }

    /**
     * 表示数据流发送完成，完成信号
     */
    private enum OnComplete implements Signal {
        Instance;
    }

    /**
     * 错误信号
     */
    private static class OnError implements Signal {
        public final Throwable error;

        public OnError(Throwable error) {
            this.error = error;
        }
    }

    /**
     * 表示下一个数据项信号
     *
     * @param <T>
     */
    private static class OnNext<T> implements Signal {
        private T next;

        public OnNext(T next) {
            this.next = next;
        }
    }

    /**
     * 表示订阅者的订阅成功信号
     */
    private static class OnSubscribe implements Signal {
        private Subscription subscription;

        public OnSubscribe(Subscription subscription) {
            this.subscription = subscription;
        }
    }


    /**
     * 订阅单据,根据规范3.1，该引用是私有的
     */
    private Subscription subscription;

    /**
     * 用于表示当前的订阅者是否处理完成
     */
    private boolean done;

    /**
     * 根据规范的2.2条款，使用该线程池异步处理各个信号
     */
    private final Executor executor;


    /**
     * 存储信号的队列
     */
    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


    /**
     * 根据规范2.7和2.11，使用原子变量确保不会有多个订阅者线程并发执行。
     */
    private final AtomicBoolean on = new AtomicBoolean(false);


    /**
     * This method is invoked when the OnNext signals arrive
     * Returns whether more elements are desired or not, and if no more elements are   desired,
     * for convenience.
     *
     * @param element
     * @return
     */
    protected abstract boolean whenNext(final T element);

    /**
     * This method is invoked when the OnComplete signal arrives
     * override this method to implement your own custom onComplete logic.
     */
    protected void whenOnComplete() {
    }


    /**
     * This method is invoked if the OnError signal arrives
     * override this method to implement your own custom onError logic.
     */
    protected void whenOnError(Throwable e) {

    }


    /**
     * 仅有这一个构造器，只能被子类调用
     * 传递一个线程池即可
     *
     * @param executor
     */
    public AsyncSubscriber(Executor executor) {
        if (executor == null) {
            throw null;
        }
        this.executor = executor;
    }

    @Override
    public void run() {
        // 跟上次线程执行建立happens-before关系，防止多个线程并发执行
        if (on.get()) {
            try {
                //从队列中取出信号
                Signal poll = inboundSignals.poll();
                // 根据规范条款2.8，如果当前订阅者已完成，就不需要处理了。
                if (!done) {
                    //根据信号类型对应处理
                    if (poll instanceof OnNext) {
                        handleOnNext(((OnNext<T>) poll).next);
                    }
                    //订阅信号
                    else if (poll instanceof OnSubscribe) {
                        handleOnSubscribe(((OnSubscribe) poll).subscription);
                    }
                    //错误信号
                    else if (poll instanceof OnError) {
                        handleOnError(((OnError) poll).error);
                    }
                    //完成信号
                    else if (poll instanceof OnComplete) {
                        handleOnComplete();
                    }
                }
            } finally {
                //设置为false，让下一个线程可以调度。
                on.set(false);
                //队列中还存在数据，继续执行入队列信号
                if (!inboundSignals.isEmpty()) {
                    tryScheduleToExecute();
                }
            }
        }
    }

    /**
     * 调度放入线程池处理操作
     * 确保订阅者一次仅在一个线程执行
     */
    private void tryScheduleToExecute() {
        //原子CAS操作，将false改为true
        if (on.compareAndSet(false, true)) {
            try {
                //将任务提交线程池
                executor.execute(this);
            } catch (Throwable e) {
                // 根据规范条款2.13，如果不能执行线程池的提交方法，需要优雅退出
                if (!done) {
                    try {
                        // 由于错误不可恢复，因此取消订阅票据
                        done();
                    } finally {
                        //首先做队列的清空处理
                        inboundSignals.clear();
                        // 由于订阅票据已经取消，但是此处依然让订阅者处于可调度的状
                        //态，以防在清空入站信号之后又有信号发送过来
                        // 因为信号的发送是异步的
                        on.set(false);
                    }
                }
            }
        }
    }

    /**
     * 幂等地标记当前订阅者已完成处理，不再处理更多的元素。
     * 因此，需要取消订阅票据（Subscription）
     */
    private void done() {
        // 在此处，可以添加done，对订阅者的完成状态进行设置；
        // 虽然规范3.7规定Subscription.cancel()是幂等的，我们不需要这么做。
        // 当whenNext方法抛异常，认为订阅者已经处理完成（不再接收更多元素）
        done = true;
        // If we are bailing out before we got a `Subscription`there 's little need for cancelling it.
        if (subscription != null) {
            try {
                subscription.cancel();
            } catch (Throwable e) {
                // 根据规范条款3.15，此处不能抛异常，因此只是记录下来。
                (new IllegalStateException(subscription
                        + " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        e)).printStackTrace(System.err);
            }
        }
    }

    /**
     * Here it is important that we do not violate 2.2 and 2.3 by calling  methods on  the `Subscription`or `Publisher`
     * <p>
     * 完成信号处理
     */
    private void handleOnComplete() {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onError before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive  Streams rule 1.09 signalling onError prior "
                            + "to onSubscribe. ")).printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;

        //发送完成信号
        whenOnComplete();

    }

    /**
     * 错误信号处理
     *
     * @param error
     */
    private void handleOnError(Throwable error) {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onComplete before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe. "))
                    .printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;
        //发送错误信号
        whenOnError(error);
    }

    /**
     * 订阅信号处理
     *
     * @param subscriptionTmp
     */
    private void handleOnSubscribe(Subscription subscriptionTmp) {
        if (subscriptionTmp == null) {
            // Getting a null `Subscription` here is not valid so lets just  ignore it.
            return;
        }

        //如果上一个订阅还存在，则需进要对当前信号做取消处理
        if (subscription != null) {
            try {
                subscriptionTmp.cancel();
            } catch (final Throwable t) {
                //Subscription.cancel is not allowed to throw an exception, according to rule 3.15
                (new IllegalStateException(subscriptionTmp +
                        " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        t)).printStackTrace(System.err);
            }
            return;
        }


        //其他情况，表示正常，发送首个请求数据的信号
        subscription = subscriptionTmp;

        try {
            // If we want elements, according to rule 2.1 we need to
            //call `request`
            // And, according to rule 3.2 we are allowed to call this
            //synchronously from within the `onSubscribe`method
            subscription.request(1); // Our Subscriber is unbuffered and modest,
            //it requests one element at a time
        } catch (final Throwable t) {
            // Subscription.request is not allowed to throw according
            //to rule 3.16
            (new IllegalStateException(subscription
                    + " violated the Reactive Streams rule 3.16 by throwing an exception from request.",
                    t)).printStackTrace(System.err);
        }
    }

    /**
     * 处理数据
     *
     * @param element
     */
    private void handleOnNext(final T element) {
        // If we aren't already done
        if (done) {
            return;
        }
        // Technically this check is not
        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            //        // Check for spec violation of 2.1 and 1.09
            (new IllegalStateException(
                    "Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before  "
                            + "`Subscription.request`. (no Subscription)")).printStackTrace(System.err);
        }

        try {
            //如果数据还有下一条记录，则再次请求1条记录
            if (whenNext(element)) {
                try {
                    // Our Subscriber is
                    //unbuffered and modest, it requests one element at a time
                    subscription.request(1);
                } catch (Throwable e) {
                    // Subscription.request is not allowed to throw
                    //according to rule 3.16
                    (new IllegalStateException(subscription
                            + "violated the Reactive Streams rule 3.16 by throwing an exception from request."
                            + " ", e)).printStackTrace(System.err);
                }
            }
            //如果没有元素了，标识结束
            else {
                done();
            }
        } catch (Throwable e) {
            //当发生异常，标识当前完成
            done();
            //发送异常信息
            try {
                onError(e);
            } catch (Throwable ex) {
                //Subscriber.onError is not allowed to throw an
                //exception, according to rule 2.13
                (new IllegalStateException(this
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.",
                        ex)).printStackTrace(System.err);
            }

        }


    }

    @Override
    public void onSubscribe(Subscription s) {
        // As per rule 2.13, we need to throw a `java.lang.NullPointerException`if the `Subscription`is `null`
        if (s == null) {
            throw null;
        }
        signal(new OnSubscribe(s));
    }

    private void signal(Signal signal) {
        // 信号入站，线程池调度处理
        // 不需要检查是否为null，因为已经实例化了。
        if (inboundSignals.offer(signal)) {
            //放入执行调度，立即执行
            tryScheduleToExecute();
        }
    }

    @Override
    public void onNext(T t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `element`is `null`
        if (t == null) {
            throw null;
        }

        signal(new OnNext<>(t));
    }

    @Override
    public void onError(Throwable t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `Throwable`is `null`
        if (t == null) {
            throw null;
        }
        signal(new OnError(t));
    }

    @Override
    public void onComplete() {
        signal(OnComplete.Instance);
    }
}
```

单元测试

```java
import org.junit.Test;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class AsyncReactiveTest {

    @Test
    public void dataTest() throws InterruptedException {
        Set<Integer> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(i);
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<Integer> publisher
                = new AsyncIterablePublisher<>(elements, executorService);

        //同步订阅者的测试
        MySubscriber subscriberTmp = new MySubscriber();
        publisher.subscribe(subscriberTmp);


        ////异常订阅者的处理
        //final SelfSubscriber<Integer> subscriber = new SelfSubscriber<>
        //        (Executors.newFixedThreadPool(2)) {
        //    @Override
        //    protected boolean whenNext(Integer element) {
        //        System.out.println("接收到的流元素：" + element);
        //        return true;
        //    }
        //};
        //publisher.subscribe(subscriber);

        Thread.sleep(1000000);

    }


    public class MySubscriber implements Subscriber<Integer> {
        private Subscription sub;

        private int randNum = 5;


        @Override
        public void onSubscribe(Subscription s) {
            System.out.println("调用了订阅方法");
            sub = s;
            sub.request(1);
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("调用了onNext方法" + integer + ",rand:" + randNum);

            if (integer == 0 || (integer + 1) % randNum == 0) {
                System.out.println("再次request:" + randNum);
                sub.request(randNum);
            }
        }

        @Override
        public void onError(Throwable t) {
            System.out.println("错误处理:" + t);
        }

        @Override
        public void onComplete() {
            System.out.println("结束");
        }
    }

}
```

### 3.3 响应式流技术兼容套件

#### 3.3.1 TCK

响应式流看着比较简单，实际包含许多的隐藏陷阱。

除java接口外，该规范还包含许多针对实现的文档化规则。

这些规则严格限制每个接口，同时，保留规范中提到的所有行为至关重要。

开发人员需要一个可以验证所有行为并确保响应库标准化且想到兼容的通用工具。

Konrad Malawski 已经为此实现了一个工具包，其名称为响应式流技术兼容套件（Reactive  Streams Technology Compatibility Kit），简称为 TCK。

TCK是一组TestNG测试用例，需要对其进行扩展，并为相应的Publisher或者Subscriber准备验证。

首先还是引入maven坐标

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>6.9.10</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.16</version>
    </dependency>
</dependencies>
```

**发布者验证**

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.tck.PublisherVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TckTest extends PublisherVerification<String> {


    public TckTest()
    {
        super(new TestEnvironment());
    }

    @Override
    public Publisher<String> createPublisher(long l) {

        Set<String> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(String.valueOf(i));
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<String> publisher
                = new AsyncIterablePublisher<>(elements, executorService);
        return publisher;
    }

    @Override
    public Publisher<String> createFailedPublisher() {

        Set elements = new HashSet<>();
        elements.add(new RuntimeException("手动异常"));

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        return new AsyncIterablePublisher<>(elements,executorService);
    }
}
```

只遵循上述测试用例配制，无法检查该Publisher的准确性，因为许多测试假设流中存在多个元素。

响应式流TCK考滤了这种极端情况，并支持设置一外名为maxElementsFromPublisher方法，该方法返回一个值，用于指定生成元素的最大数量。

```java
    @Override
    public long maxElementsFromPublisher() {
        //return super.maxElementsFromPublisher();
        return 10;
    }
```

一方面重写该方法可以跳过需要多个元素的测试，另一方面，响应式流规则的覆盖范围将减小，可能需要实现自定义测试用例。

**订阅者验证**

订阅者存在两种验证方式。黑盒验证和白盒验证。

首先看黑盒验证

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.tck.SubscriberBlackboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TCKBlackBoxTest extends SubscriberBlackboxVerification<Integer> {


    protected TCKBlackBoxTest() {
        super(new TestEnvironment());
    }

    @Override
    public Subscriber<Integer> createSubscriber() {
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素:" + element);
                //该返回为true，表示继续接收下一个元素，false表示不再请求了
                return true;
            }
        };
        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }

    //@Override
    //public void triggerRequest(Subscriber<? super Integer> subscriber) {
    //    //该方法直接向订阅者发送信号，默认该方法什么都不做
    //    AsyncSubscriber<Integer> subscriber1 = (AsyncSubscriber<Integer>) subscriber;
    //    subscriber1.onNext(100000);
    //}
}
```

该测试用例，可以模拟真实的用户活动。

再看白盒测试

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.reactivestreams.tck.SubscriberWhiteboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class TestWhiteBoxTest extends SubscriberWhiteboxVerification<Integer> {

    protected TestWhiteBoxTest() {
        super(new TestEnvironment());
    }


    @Override
    public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> whiteboxSubscriberProbe) {

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素：" + element);
                //返回true表示请求下一个元素，false表示不再请求
                return true;
            }

            @Override
            public void onSubscribe(Subscription subscription) {
                super.onSubscribe(subscription);
                whiteboxSubscriberProbe.registerOnSubscribe(new SubscriberPuppet() {
                    @Override
                    public void triggerRequest(long elements) {
                        subscription.request(elements);
                    }

                    @Override
                    public void signalCancel() {
                        subscription.cancel();
                    }
                });
            }

            @Override
            public void onNext(Object object) {
                super.onNext(object);
                whiteboxSubscriberProbe.registerOnNext((Integer) object);
            }

            @Override
            public void onError(Throwable t) {
                super.onError(t);
                whiteboxSubscriberProbe.registerOnError(t);
            }

            @Override
            public void onComplete() {
                super.onComplete();
                whiteboxSubscriberProbe.registerOnComplete();
            }
        };


        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }
}
```

createSubscriber方法实现与黑盒验证的工作方式相同，并返回Subscriber实例，但此处还有一个名为whiteboxSubscriberProbe的附加参数。

在这种情况下，whiteboxSubscriberProbe代表了一种机制，该机制实现对需求的嵌入式控制和输入信号的捕获。

与黑盒验证相比，通过正确的注册探测钩子，测试套件不仅能够发送需求，还能验证需求是否被满足以及所有元素是否被接受。同时，需求监控机制比以前更加透明。我们实现了subScriberPupper，它会为直接访问收到的Subscription进行适配。



同时TCK还提供 了processor的测试，此处略过。



## 4. 响应流的异步与并行

一方面，响应流的API中的规则 2.2和3.4规定，对由publisher生成并由Subscriber消费的所有信号的处理过程应该是非阻塞和非干扰的。

因此基于具体的执行环境，可以高效的利用处理器的一个节点和一个内核。

另一方面，所有处理器或者内核的高效利用需要并行化，对响应式流规范中的并行化概念的可以理解为对Subscrber#onNext方法的并行调用。

遗憾的是，规则 中的规则1.3规定，必须以线程安全的方式触发onXXX方法的调用，并且如果由多个线程执行，则使用外部同步，这一假定对所有OnXXX方法的串行化或者简单顺序调用。反过来，这意味着无法创建类型ParallelPublisher的组件并在流中对元素进行并行处理。

如果高效的利用资源，就必须分析常见了流处理管道。



![image-20241127122543496](.\images\image-20241127122543496.png)

一种解决方案是在阶段之间传递异步消息，对于基于内存的流处理而言，这意味着执行过程的一部分被绑定到了一个线程而另一部分被绑定到了另一个线程。

![image-20241127122804397](.\images\image-20241127122804397.png)

通常的做法是：两个独立 的线程之间拆分处理过程，在阶段之前放置异步边界。

又因为两个线程可以彼此独立地工作，所以通过这样做，将元素的整体处理过程并行化。为了实现并行化，必须应用一种数据结构（例如queue)来正确的解耦处理过程。

拆分线程之间的处理过程会导致数据结构中的额外的开销。当然，由于响应式流的规定，这样的数据结构是有界的。数据结构中的数据项数量通常等于Subscriber从其他Publisher请求的批处理的大小，而这取决于系统的一般容量。



![image-20241127123609250](.\images\image-20241127123609250.png)

每个处理阶段都可以绑定一个单犯的线程。



## 5. 响应式环境的转变

JDK9包含了响应式规范这一事实强调了该规范的重要性，并且该规范已经开始改变这个行业。

### 5.1 RxJava的转变

例如：一个应用程序把RxJava1.x和Observalbe作为组件之间的核心通信类型:

```java
interface LogService {
    Observable<String> stream();
}
```

遵循响应式流规范并从以下特定依赖中报出我们的接口

```java
interface LogService {
    Publisher<String> stream();
}
```

将RxJava2类型反向转换为响应式流兼容类型：

```java
Flowable.just(1, 2, 3)
   .map(String::valueOf)
   .toObservable()
   .toFlowable(BackpressureStrategy.ERROR)
   .subscribe();

```



### 5.2 Vert.x 的调整

为了遵循规范，Vert.x  包含一个额外的模块，该模块为响应式流 API 提供支持

```java
// ...
.requestHandler(request -> {
    ReactiveReadStream<Buffer> rrs = ReactiveReadStream.readStream();
    HttpServerResponse response = request.response();
    Flowable<Buffer> logs = 
Flowable.fromPublisher(logsService.stream()).map(Buffer::buffer)
       .doOnTerminate(response::end);
    logs.subscribe(rrs);
    response.setStatusCode(200);
    response.setChunked(true);
    response.putHeader("Content-Type", "text/plain");
    response.putHeader("Connection", "keep-alive");
    Pump.pump(rrs, response).start();
});
// ...
```

### 5.3 Ratpack的改进

```java
RatpackServer.start(server -> server.handlers(chain -> chain.all(ctx -> {
    Publisher<String> logs = logsService.stream();
    ServerSentEvents events = serverSentEvents(
        logs, event -> event.id(Objects::toString).event("log").data(Function.identity());
   );
    ctx.render(events);
})));
```

Patpack还提供了对规范接口的自身实现

```java
Publisher<String> logs = logsService.stream();
TransformablePublisher publisher = Streams.transformable(logs)
   .filter(this::filterUserSensitiveLogs)
   .map(this::escape);
```



## 6. Spring响应式编程

### 6.1 观察者模式

好像观察者模式似乎与响应式编程无关，但经过一些小改动，它定义了响应式编程的基础

![image-20241127125125558](.\images\image-20241127125125558.png)

**Subject接口**

```java

/**
 * Subject接口
 *
 * @author liujun
 * @since 2023/7/13
 */
public interface Subject {

    /**
     *  注册观察者
     */
    void registerObserver(Observer observer);

    /**
     * 解绑观察者
     *
     * @param observer
     */
    void unregisterObserver(Observer observer);

    /**
     * 通知事件变更
     *
     * @param event
     */
    void notifyObservers(String event);

}

```

**Observer接口**

```java

/**
 * Observer接口
 *
 * @author nullnull
 * @since 2023/7/13
 */
public interface Observer {

    void observe(String event);

}
```

**Subject实现类**

```java

import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteSubject implements Subject {

    /**
     * 保证Set是线程安全的
     */
    private Set<Observer> observers = new CopyOnWriteArraySet<>();

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void unregisterObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String event) {
        observers.forEach(observer -> observer.observe(event));
    }
}
```

Observer的实现类

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverA implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}

```

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverB implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}
```

单元测试

```java
import org.junit.Test;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ObserverTest {
    @Test
    public void dataTest() {
        Subject subject = new ConcreteSubject();
        Observer observer1 = new ConcreteObserverA();
        Observer observer2 = new ConcreteObserverB();
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);
        subject.notifyObservers("hello null null");
        System.out.println("==================================");
        subject.unregisterObserver(observer1);
        subject.notifyObservers("great null null");

    }
}

```

输出：

```java
com.nullnull.observer.ConcreteObserverA --- hello null null
com.nullnull.observer.ConcreteObserverB --- hello null null
==================================
com.nullnull.observer.ConcreteObserverB --- great null null
```

可以使用java8的lambda的特性:

```java
 @Test
    public void dataTestLambda() {
        Subject subject = new ConcreteSubject();
        subject.registerObserver(e -> System.out.println("A: " + e));
        subject.registerObserver(e -> System.out.println("B: " + e));
        subject.notifyObservers("This message will receive A & B");

        subject.notifyObservers("hello null null");
        System.out.println("==================================");

    }
```

输出:

```java
A: This message will receive A & B
B: This message will receive A & B
A: hello null null
B: hello null null
```



### 6.2 基于@EventListener注解的发布和订阅模式

实现一个简单的WEB服务，用于显示当前的温度。

![image-20241127222027473](.\images\image-20241127222027473.png)

**maven依赖**

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>


        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

**实体**

```java

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }
}

```

**TemperatureSensor类模拟传感器**

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    private final ApplicationEventPublisher publisher;

    private final Random random = new Random();

    private final ScheduledExecutorService service =
            Executors.newSingleThreadScheduledExecutor();

    public TemperatureSensor(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    @PostConstruct
    public void startProcessing() {
        this.service.schedule(this::probe, 1, TimeUnit.SECONDS);
    }

    private void probe() {
        double temperature = 16 + random.nextGaussian() * 10;
        System.err.println("发送事件。。。");
        // 通过ApplicationEventPublisher发布Temperature事件

        publisher.publishEvent(new Temperature(temperature));
        service.schedule(this::probe, random.nextInt(5000),
                TimeUnit.MILLISECONDS);
    }
}
```

**暴露SSE端点**

```java
import org.json.JSONObject;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@RestController
public class TemperatureController {

    private final Set<SseEmitter> clients = new CopyOnWriteArraySet<>();

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {

        // ResponseBodyEmitter的子类，用于发送SSE（Server-Send Event）：服务器发送 的事件
        //    SseEmitter emitter = new SseEmitter();
        // 设置超时时间
        SseEmitter emitter = new SseEmitter(10000L);
        // 将当前发射器放到集合中
        clients.add(emitter);
        // 给当前发射器设置事件处理函数

        /*
        当异步请求超时的时候调用的代码。
        该方法在异步请求超时的时候由容器线程调用。
         */
        emitter.onTimeout(() -> clients.remove(emitter));
        /*
        当异步请求结束的时候调用的代码。
        当超时或网络错误而终止异步请求处理的时候，在容器线程调用该方法。
        该方法一般用于检车一个ResponseBodyEmitter实例已经无用了。
         */
        emitter.onCompletion(() -> clients.remove(emitter));
        return emitter;
    }

    /**
     * @param temperature
     * @Async // 异步事件处理
     * @EventListener // 事件监听器，该监听器只接收Temperature事件
     */
    @Async // 异步事件处理
    @EventListener // 事件监听器，该监听器只接收Temperature事件
    public void handleMessage(Temperature temperature) {
        System.out.println("监听到web的调度事件了 -- " + temperature);
        List<SseEmitter> deadEmitters = new ArrayList<>();
        // 遍历发射器集合
        clients.forEach(emitter -> {
            try {
                // 发射器发送温度对象，json类型
                final JSONObject jsonObject = new JSONObject(temperature);
                final String s1 = jsonObject.toString();
                emitter.send(s1);
            } catch (Exception ignore) {
                // 如果抛异常，则将该发射器放到deadEmitters集合中
                deadEmitters.add(emitter);
            }
        });
        // 从clients中移除所有失效的发射器。
        clients.removeAll(deadEmitters);
    }
}

```

**配制异步支持**

```java
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@Configuration
@EnableAsync
public class MyAsyncConfig implements AsyncConfigurer {
    // 为异步调用设置Executor
    @Override
    public Executor getAsyncExecutor() {
        // 使用包含两个核心线程的 ThreadPoolTaskExecutor，可以将核心线程增加到一百  个。
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(100);
        // 如果没有正确配置队列容量，线程池就无法增长。
        // 这是因为程序将转而使用 SynchronousQueue，而这限制了并发。
        executor.setQueueCapacity(5);
        executor.initialize();
        return executor;
    }
    // 为异步执行引发的异常配置异常处理程序。
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        // 此处仅记录异常
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

**入口程序配制**

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo10Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo10Application.class, args);
  }
}
```

resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```

启动服务

Demo10Application

访问网页

http://127.0.0.1:8080/

显示：

```tex
Connection opened
Temperature: 23.53 C
Temperature: 8.66 C
Temperature: 19.28 C
Connection closed
Connection opened
```

控制台输出：

```sh
发送事件。。。
2024-11-27 22:30:50.741  INFO 28324 --- [pool-1-thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@499ff586
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@1ad9aed1
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@6eed6b83
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@141e43fa
```



### 6.3 使用RxJava作为响应式框架

官网地址：

```sh
http://reactivex.io/
```

ReactiveX通常被定义为观察者模式、迭代器模式和函数式编程的组合。

Java平台上有一个用于响应式编程的标准库，即RxJava，是Reactive Extensions(响应式扩展，也称为ReactiveX)的Java实现，目前它并不是唯一的响应式库，还是Akka Streams和Project Reactor.

## 结束
