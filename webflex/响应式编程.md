# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241126091852663](.\images\image-20241126091852663.png)



**响应延迟**

传统命令式编程的另一个问题是：当一个服务需要做很多操作而不仅仅是IO请求的时候，响应延迟相应的增大。

如服务A需要调用服务B和服务C，比如查询数据库，聚合结果并返回。意味着服务A的响应时间包括：

- 服务B的响应时间（网络延迟时间+处理时间）
- 服务C的响应时间（网络延迟时间+处理时间）
- 数据请求响应时间（网络延迟时间+处理时间）



![image-20241126091817119](D:\work\nullnull\learn\learn-md\webflex\images\image-20241126091817119.png)

如果服务调用没有前后依赖关系，则可以并行调用服务，如果使用java的CompletableFuture异步调用并注册回调，开发会复杂很多，而且阅读和维护也会复杂很多。



**压垮客户端**

微服务另外一个问题就是：服务A请求服务B的数据，如果数据量非常的时候，超过了服务A能处理的程度，则会导致服务OOM。



**总结**

这些问题都是响应式编程要解决的。

优势：

- 不用Thread per Request模型，使用少量线程即可处理大量的请求。
- 在执行IO操作时不让线程等待。
- 简化并行调用。
- 支持背压，让客户端告诉服务端它能处理多少负载。

### 1.1.1  消息驱动通信

响应式编程的定义

响应式编程使用异步、事件驱动构建非阻塞式应用的。此类应用仅需少量的线程用于横向扩展。

该定义的关键一点是：借助背压技术，防止生产者压垮消费者。

**怎么做？**

答案就是使用异步数据流编程。

如果服务A需要从服务B获取数据。对于响应式编程，服务A向服务B发起请求，并立即返回（非阻塞异步）。

之后请求的数据以数据流的方式返回给服务A，服务B对每个数据项发布onNext事件，当所有的数据都发布了OnNext事件，就发布OnComplete事件结束，如果发生异常，服务B就发布OnError事件，之后不再发布OnNext事件。

![image-20241126093315691](.\images\image-20241126093315691.png)

响应式编程使用函数式编程风格，用于对数据流进行不同的转换。

流可以作为输入，也可以合并，映射和过滤等。

**响应式系统**

响应式系统的设计目标：

- 响应性（以时序的方式响应）
- 健壮（即使发生错误也可以保证响应性）
- 弹性（在不同的工作负载下保持响应性）
- 消息驱动（依赖异步消息传递机制）

响应式编程可以确保单个服务的异步非阻塞，整个系统的响应式需要整体考滤。



### 1.2 响应式应用案例

**响应式编程是使用异步数据流进行编程**

流是一个时序事件序列，可以发送三种不同的事件：（某种类型的）值 、错误或者一个完成信号。

分为值、错误、完成定义事件的函数，异步的处理事件。

监听一个流称为订阅，定义的函数称为观察者，流是被观察者，即观察者模式。

每个流会有多个方法，如map、filter、scan等等。

当调用其中一个方法时，它会基于原来的流返回一个新的流。

它不对原来的点击流做任何的修改，这个特性称为不变性，也可以称为方法链式调用。

```sh
clickStream:  ---c---c--c---c------c-->
              vvvv map(c becomes 1)vvvv
              ---c---c--c---c------c-->
              vvvvvvvvv scan(+) vvvvvvvv
counterstream:---1---2--3---4------5-->
```

map(f) 会根据提供的f函数把原来Stream中的Value分别映射到新的Stream中

scan(g) 会根据你提供的G函数把Stream中的所有Value聚合成一个Value x=g(sccumulated,current)

每click一次，countStream就会把点击的总次数发送给它的观察者。



### 1.3 响应式编程的现状

2011年，微软发布了.NET的响应式扩展，以方便异步、事件驱动的程序。

ReactiveX混合了迭代器和观察者模式，不同之处在于一个是推模式，一个是基于迭代器的拉模式。

除了对变化事件的观察，完成事件和异常事件也会发送给订阅者。

ReactiveX的基本思想是事件是数据，数据是事件。

响应式扩展被移植到了几种语言和平台上，包括 javascript、Python、C++、swift和java、ReactiveX很快成为一种跨语言的标准，将响应式编程引入到行业中。

RxJava，是java的ReactiveX实现。

RxJava是其他reactivex jvm平台技术的主要技术，其他的如RxScala、RxKotlin、RxGroovy。RxJava已经碾为Android开发的核心技术，并且可以开箱即用的使用RxJava。

这表明RxJava不仅仅是一个库，它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。



### 1.4 为什么采用响应式Spring？

响应式系统非常的复杂，在构建这类系统时困难也非常的多。

要轻松构建响应式系统，就必须首先分析能够构建这类系统的框架，然后选择其中之一。

选择框架最常用的方法之一是分析其可用功能，相关性及社区。

在JVM领域，构建响应式系统最知名的框架是Akka和vert.x生态系统。

一方面,Akka是一个受欢迎的框架，具有大量功能和大型社区，然后，Akka最初是作为Scala生态系统的一部分构建的，在很长一段时间内，它仅在基于Scala编写的解决方法中展示它强大的功能，尽管Scala是一种基于JVM的语言，但它与JAVA明显不同，几年前，Akka直接支持java，但是出于某些原因，它在java世界中不像在Scala世界中那么受欢迎。

另一方法，Vert.x框架也是构建高效响应式系统的强大解决方案，Vert.x的设计初衷是作为Node.js在java虚拟机上的替代方法，它支持非阻塞和事件驱动。然后，Vert.x仅在几年前开始具备竞争力，在过去的15年中，Spring框架一直在构建灵活且健状的应用程序框架市场中占有主导地位。

Spring框架使用适合开发人员的编程模型，为构建Web应用程序提供了广泛的可能性，然后长期以来，它在构建健状的响应式系统方法存在一个局限。

Spring框架在一个单独的线程中包装了阻塞式网络调用，同时Spring MVC依赖于Servlet API ，这使得所有的实现必须使用线程的单次请求（thread-per-request)模型。

这种模型非常不理想，效率低下。

为此，响应式规则建议使用非阻塞的操作，但这是Spring生态系统缺少的。此外Spring也没有与Netty等响应式服务器进行良好的集成，而这些响应式服务器解决了上下文切换的问题。

## 2 无处不在的响应性

### 2.1 API不一致的问题

大量的同类弄响应式可供选择（RxJava、CompletableStage、Vert.x、Akka）

另外一方面，丰富的选择很容易使得系统过于复杂。例如，若存在两个依赖于同一个异步非阻塞通信概念但具有不同的API的库，会导致 我们需要提供额外的工具类，以便将一个回调转换为另外一个回调，反之亦然。

Spring4.x框架中的ListenableFuture和CompletionStage之间没有直接集成 。

在许多情况下，为了解决几个问题并使得几个独立的库兼容，必须提供自己的适配并在几个地方重用。

自己写的适配可能bug。需要额外的维护。

Spring5.x框架扩展了ListenableFuture的API并且提供了一个Completable的方法来解决不兼容的问题。

这里的核心 问题在于没有标准。



### 2.2 推拉

在整个响应式环境演变的早期阶段，所有库的设计思想都是把数据从源头推送到订阅者。

因为纯粹的拉模型在某些场景下效率不够高。

拉模型

![image-20241126222758306](.\images\image-20241126222758306.png)

问题：

处理时间方面，仍然存在一些效率低下的情况。

发送一批元素比发送一个元素需要更多的时间。

为了提供最终的优化，只会请求一次数据，当数据变为可用时，该数据源异步推送数据。

![image-20241126223017360](.\images\image-20241126223017360.png)

再次对整体处理时间做了优化。在交互过程中，只有当服务等待每个响应时会有大段空间时间，当第一个元素到达后，数据库会在数据到达时开始发送后续元素。



### 2.3 流量控制问题

在生产者与消费者的处理过程中，会存在两边处理速度不一致的问题。两种场景：

1. 慢生产者和快消费者。
2. 快生产者和慢消费者。

使用队列推送数据的关键要素之一是选择有合适特性的队列 

通常有3种。无界队列、有界丢序队列、有限阻塞队列。

**无界队列**

![image-20241126223504790](.\images\image-20241126223504790.png)

此队列的最大问题在于，一旦到达内存上限，整个系统就很容易崩溃。

**有界丢弃队列**

![image-20241126223629051](.\images\image-20241126223629051.png)

此技术考滤了资源的限制，并且可以根据资源的能力配制队列的容易，当消息的重要性很低时，采用这种队列是一种常见的做法。

**有界阻塞队列**

![image-20241126223917359](.\images\image-20241126223917359.png)

遗憾的是这种技术否定了系统的所有异步的行为。通常一旦生产者到达队列的限制。它就会开始被阻塞并将处理该状态，直接消费者消费了一个元素，从而使队列中出现可用空间为止，由此我们可以得出结论，最慢的消费者的吞吐率限制了系统总吞吐量。继而，除了否定异步行为了该技术还否定了有效的资源利用率，因此想要实现回弹性、弹性和即时响应所有的三方法，那么这些场景会部不可接受。





### 2.4 解决方法

来自 Lightbend、Netflix 和 Pivotal 的一群天才工程师齐聚一堂，共同解决上述问题 并为 JVM 社区提供标准。 

经过长达一年的努力，响应式流规范的初稿公诸于世。

其概念就是响应式编程模式的标准化。



## 3 响应式流规范

### 3.1 响应式流规范基础

响应式流规范网站：

```sh
http://www.reactive-streams.org
```

响应式规则发布了一组接口，用于实现：

maven地址:

```xml
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck-flow</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-examples</artifactId>
  <version>1.0.3</version>
</dependency>
```

响应式流规范文档

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
```

**响应式流规范**

响应式流（Reactive Streams）规范，规定了异步组件之前使用背压进行交互。

响应式流在java 9中使用flow API适配。Flow API是互操作的规范，而不是具体的实现，它的主义跟响应式流规范一致。

响应式流规范包括如下接口

**Publisher**

表示数据流的生产者或者数据源，包含一个方法让订阅者注册 到发布者，Puhblisher代表了发布者和订阅者直接连接的标准化入口点。

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```



**Subscriber**

表示消费者，onSubscriber方法为我们提供了一种标准化的方法来通知Subscriber订阅成功。

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- onSubscribe发布者在开始处理之前调用，并向订阅者传递一个订阅票据对象（Subscription).
- onNext 用于通知订阅者发布者发布了新的数据项。
- onError 用于通知订阅者，发布者遇到了异常，不再发布数据事件。
- onComplete 用于通知订阅者所有的数据事件都已经发布完。

**Subscription**

onSubscribe方法的传入参数引入一名为Subscription(订阅)的订阅票据。

Subscription为控制元素的生产提供了基础。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- request 用于让订阅者通知发布者随后 需要发布的元素数量。
- cancel 用于让订阅者取消发布者随后的事件流。

**Processor**

如果实体需要转换进来的项目，并将转换后的项目传递给另一个订阅者，此时需要Processor接口。该接口既是订阅者，又是发布者。

```xml
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

