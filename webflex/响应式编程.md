# 响应式编程

## 1.  响应式编程简介

### 1.1 为什么需要响应式？

传统的命令式编程在面对当前的一些需求时的一些限制：

需求：`即使在应用负载较高时，应用需要更高的可用性，并提供低的延迟时间`

**Thread Per Request模型**

比如使用Servlet开发的单体应用时，部署Tomcat。

tomcat 有线程池，每个请求交给线程池中的一个线程来执行，如果执行过程中包括访问数据库，或者包括读取文件，则在调用数据库时或读取文件时，请求线程是阻塞的，即使是阻塞的线程也是占用资源的，典型的每个线程要使用1MB内存。

如果有并发请求，则会有多个线程处于阻塞状态，每个线程占据一份资源。

同时，Tomcat的线程池大小决定了可以同时处理多个少请求。

与传统的Spring开发的WEB作一个对比，就能知道响应式编程是什么，以及它能提供什么？

传统方式：使用Spring MVC开发WEB应用并部署到Servlet容器，如tomcat，Servlet容器有专门的线程池用于管理HTTP请求，每个请求对应一个线程，该线程负责该请求的整个生命周期（Thread per Request模型）。意味着应用仅能处理并发数为线程池大小的请求，可以配制更大的线程池，但是线程占用内存（一般一个线程1MB的样子），线程越多，占用内存也越大。

如果应用基于微服务架构，我们可以横向扩展，但是也有内存占用高的问题，因此，当并发数很大的时候，Thread per Request模型很消耗资源。

微服务架构一个特性是分布式，运行分多个独立的进程，或者部署在不同的服务器上。传统的命令式编程使用同步请求/响应模式在服务之前通信，线程需要频繁在服务调用的时候阻塞。浪费了资源。

**等待IO操作**

在IO操作中也存大大量的资源浪费；如调用数据库。读取文件等。

此时发出IO请求线程会阻塞等待IO操作的完成。即使阻塞式IO，这些线程的阻塞仅驻是为了等待一个响应，浪费了线程，浪费了内存。



![image-20241126091852663](.\images\image-20241126091852663.png)



**响应延迟**

传统命令式编程的另一个问题是：当一个服务需要做很多操作而不仅仅是IO请求的时候，响应延迟相应的增大。

如服务A需要调用服务B和服务C，比如查询数据库，聚合结果并返回。意味着服务A的响应时间包括：

- 服务B的响应时间（网络延迟时间+处理时间）
- 服务C的响应时间（网络延迟时间+处理时间）
- 数据请求响应时间（网络延迟时间+处理时间）



![image-20241126091817119](D:\work\nullnull\learn\learn-md\webflex\images\image-20241126091817119.png)

如果服务调用没有前后依赖关系，则可以并行调用服务，如果使用java的CompletableFuture异步调用并注册回调，开发会复杂很多，而且阅读和维护也会复杂很多。



**压垮客户端**

微服务另外一个问题就是：服务A请求服务B的数据，如果数据量非常的时候，超过了服务A能处理的程度，则会导致服务OOM。



**总结**

这些问题都是响应式编程要解决的。

优势：

- 不用Thread per Request模型，使用少量线程即可处理大量的请求。
- 在执行IO操作时不让线程等待。
- 简化并行调用。
- 支持背压，让客户端告诉服务端它能处理多少负载。

### 1.1.1  消息驱动通信

响应式编程的定义

响应式编程使用异步、事件驱动构建非阻塞式应用的。此类应用仅需少量的线程用于横向扩展。

该定义的关键一点是：借助背压技术，防止生产者压垮消费者。

**怎么做？**

答案就是使用异步数据流编程。

如果服务A需要从服务B获取数据。对于响应式编程，服务A向服务B发起请求，并立即返回（非阻塞异步）。

之后请求的数据以数据流的方式返回给服务A，服务B对每个数据项发布onNext事件，当所有的数据都发布了OnNext事件，就发布OnComplete事件结束，如果发生异常，服务B就发布OnError事件，之后不再发布OnNext事件。

![image-20241126093315691](.\images\image-20241126093315691.png)

响应式编程使用函数式编程风格，用于对数据流进行不同的转换。

流可以作为输入，也可以合并，映射和过滤等。

**响应式系统**

响应式系统的设计目标：

- 响应性（以时序的方式响应）
- 健壮（即使发生错误也可以保证响应性）
- 弹性（在不同的工作负载下保持响应性）
- 消息驱动（依赖异步消息传递机制）

响应式编程可以确保单个服务的异步非阻塞，整个系统的响应式需要整体考滤。



### 1.2 响应式应用案例

**响应式编程是使用异步数据流进行编程**

流是一个时序事件序列，可以发送三种不同的事件：（某种类型的）值 、错误或者一个完成信号。

分为值、错误、完成定义事件的函数，异步的处理事件。

监听一个流称为订阅，定义的函数称为观察者，流是被观察者，即观察者模式。

每个流会有多个方法，如map、filter、scan等等。

当调用其中一个方法时，它会基于原来的流返回一个新的流。

它不对原来的点击流做任何的修改，这个特性称为不变性，也可以称为方法链式调用。

```sh
clickStream:  ---c---c--c---c------c-->
              vvvv map(c becomes 1)vvvv
              ---c---c--c---c------c-->
              vvvvvvvvv scan(+) vvvvvvvv
counterstream:---1---2--3---4------5-->
```

map(f) 会根据提供的f函数把原来Stream中的Value分别映射到新的Stream中

scan(g) 会根据你提供的G函数把Stream中的所有Value聚合成一个Value x=g(sccumulated,current)

每click一次，countStream就会把点击的总次数发送给它的观察者。



### 1.3 响应式编程的现状

2011年，微软发布了.NET的响应式扩展，以方便异步、事件驱动的程序。

ReactiveX混合了迭代器和观察者模式，不同之处在于一个是推模式，一个是基于迭代器的拉模式。

除了对变化事件的观察，完成事件和异常事件也会发送给订阅者。

ReactiveX的基本思想是事件是数据，数据是事件。

响应式扩展被移植到了几种语言和平台上，包括 javascript、Python、C++、swift和java、ReactiveX很快成为一种跨语言的标准，将响应式编程引入到行业中。

RxJava，是java的ReactiveX实现。

RxJava是其他reactivex jvm平台技术的主要技术，其他的如RxScala、RxKotlin、RxGroovy。RxJava已经碾为Android开发的核心技术，并且可以开箱即用的使用RxJava。

这表明RxJava不仅仅是一个库，它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。



### 1.4 为什么采用响应式Spring？

响应式系统非常的复杂，在构建这类系统时困难也非常的多。

要轻松构建响应式系统，就必须首先分析能够构建这类系统的框架，然后选择其中之一。

选择框架最常用的方法之一是分析其可用功能，相关性及社区。

在JVM领域，构建响应式系统最知名的框架是Akka和vert.x生态系统。

一方面,Akka是一个受欢迎的框架，具有大量功能和大型社区，然后，Akka最初是作为Scala生态系统的一部分构建的，在很长一段时间内，它仅在基于Scala编写的解决方法中展示它强大的功能，尽管Scala是一种基于JVM的语言，但它与JAVA明显不同，几年前，Akka直接支持java，但是出于某些原因，它在java世界中不像在Scala世界中那么受欢迎。

另一方法，Vert.x框架也是构建高效响应式系统的强大解决方案，Vert.x的设计初衷是作为Node.js在java虚拟机上的替代方法，它支持非阻塞和事件驱动。然后，Vert.x仅在几年前开始具备竞争力，在过去的15年中，Spring框架一直在构建灵活且健状的应用程序框架市场中占有主导地位。

Spring框架使用适合开发人员的编程模型，为构建Web应用程序提供了广泛的可能性，然后长期以来，它在构建健状的响应式系统方法存在一个局限。

Spring框架在一个单独的线程中包装了阻塞式网络调用，同时Spring MVC依赖于Servlet API ，这使得所有的实现必须使用线程的单次请求（thread-per-request)模型。

这种模型非常不理想，效率低下。

为此，响应式规则建议使用非阻塞的操作，但这是Spring生态系统缺少的。此外Spring也没有与Netty等响应式服务器进行良好的集成，而这些响应式服务器解决了上下文切换的问题。

## 2 无处不在的响应性

### 2.1 API不一致的问题

大量的同类弄响应式可供选择（RxJava、CompletableStage、Vert.x、Akka）

另外一方面，丰富的选择很容易使得系统过于复杂。例如，若存在两个依赖于同一个异步非阻塞通信概念但具有不同的API的库，会导致 我们需要提供额外的工具类，以便将一个回调转换为另外一个回调，反之亦然。

Spring4.x框架中的ListenableFuture和CompletionStage之间没有直接集成 。

在许多情况下，为了解决几个问题并使得几个独立的库兼容，必须提供自己的适配并在几个地方重用。

自己写的适配可能bug。需要额外的维护。

Spring5.x框架扩展了ListenableFuture的API并且提供了一个Completable的方法来解决不兼容的问题。

这里的核心 问题在于没有标准。



### 2.2 推拉

在整个响应式环境演变的早期阶段，所有库的设计思想都是把数据从源头推送到订阅者。

因为纯粹的拉模型在某些场景下效率不够高。

拉模型

![image-20241126222758306](.\images\image-20241126222758306.png)

问题：

处理时间方面，仍然存在一些效率低下的情况。

发送一批元素比发送一个元素需要更多的时间。

为了提供最终的优化，只会请求一次数据，当数据变为可用时，该数据源异步推送数据。

![image-20241126223017360](.\images\image-20241126223017360.png)

再次对整体处理时间做了优化。在交互过程中，只有当服务等待每个响应时会有大段空间时间，当第一个元素到达后，数据库会在数据到达时开始发送后续元素。



### 2.3 流量控制问题

在生产者与消费者的处理过程中，会存在两边处理速度不一致的问题。两种场景：

1. 慢生产者和快消费者。
2. 快生产者和慢消费者。

使用队列推送数据的关键要素之一是选择有合适特性的队列 

通常有3种。无界队列、有界丢序队列、有限阻塞队列。

**无界队列**

![image-20241126223504790](.\images\image-20241126223504790.png)

此队列的最大问题在于，一旦到达内存上限，整个系统就很容易崩溃。

**有界丢弃队列**

![image-20241126223629051](.\images\image-20241126223629051.png)

此技术考滤了资源的限制，并且可以根据资源的能力配制队列的容易，当消息的重要性很低时，采用这种队列是一种常见的做法。

**有界阻塞队列**

![image-20241126223917359](.\images\image-20241126223917359.png)

遗憾的是这种技术否定了系统的所有异步的行为。通常一旦生产者到达队列的限制。它就会开始被阻塞并将处理该状态，直接消费者消费了一个元素，从而使队列中出现可用空间为止，由此我们可以得出结论，最慢的消费者的吞吐率限制了系统总吞吐量。继而，除了否定异步行为了该技术还否定了有效的资源利用率，因此想要实现回弹性、弹性和即时响应所有的三方法，那么这些场景会部不可接受。





### 2.4 解决方法

来自 Lightbend、Netflix 和 Pivotal 的一群天才工程师齐聚一堂，共同解决上述问题 并为 JVM 社区提供标准。 

经过长达一年的努力，响应式流规范的初稿公诸于世。

其概念就是响应式编程模式的标准化。



## 3 响应式流规范

### 3.1 响应式流规范基础

响应式流规范网站：

```sh
http://www.reactive-streams.org
```

响应式规则发布了一组接口，用于实现：

maven地址:

```xml
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-tck-flow</artifactId>
  <version>1.0.3</version>
</dependency>
<dependency>
  <groupId>org.reactivestreams</groupId>
  <artifactId>reactive-streams-examples</artifactId>
  <version>1.0.3</version>
</dependency>
```

响应式流规范文档

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
```

**响应式流规范**

响应式流（Reactive Streams）规范，规定了异步组件之前使用背压进行交互。

响应式流在java 9中使用flow API适配。Flow API是互操作的规范，而不是具体的实现，它的主义跟响应式流规范一致。

响应式流规范包括如下接口

**Publisher**

表示数据流的生产者或者数据源，包含一个方法让订阅者注册 到发布者，Puhblisher代表了发布者和订阅者直接连接的标准化入口点。

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```



**Subscriber**

表示消费者，onSubscriber方法为我们提供了一种标准化的方法来通知Subscriber订阅成功。

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- onSubscribe发布者在开始处理之前调用，并向订阅者传递一个订阅票据对象（Subscription).
- onNext 用于通知订阅者发布者发布了新的数据项。
- onError 用于通知订阅者，发布者遇到了异常，不再发布数据事件。
- onComplete 用于通知订阅者所有的数据事件都已经发布完。

**Subscription**

onSubscribe方法的传入参数引入一名为Subscription(订阅)的订阅票据。

Subscription为控制元素的生产提供了基础。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

- request 用于让订阅者通知发布者随后 需要发布的元素数量。
- cancel 用于让订阅者取消发布者随后的事件流。

**Processor**

如果实体需要转换进来的项目，并将转换后的项目传递给另一个订阅者，此时需要Processor接口。该接口既是订阅者，又是发布者。

```xml
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```



### 3.2 响应式流规范实战

地址：

```sh
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification
```

添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

异步发布者

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Publisher的实现，用于进行数据的生产操作，可以理解为要加工的数据
 *
 * @author nullnull
 * @since 2023/6/27
 */
public class AsyncIterablePublisher<T> implements Publisher<T> {


    /**
     * 默认的批次大小
     */
    private static final int DEFAULT_BATCH_SIZE = 1024;

    /**
     * 迭代器，用于原始数据的生成操作
     */
    private final Iterable<T> iterable;

    /**
     * 线程池接口，用于生成任务的并行执行
     */
    private final Executor executor;

    /**
     * 用于批次处理任务的大小
     */
    private final int batchSize;


    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor) {
        this(iterable, executor, DEFAULT_BATCH_SIZE);
    }

    public AsyncIterablePublisher(Iterable<T> iterable, Executor executor, int batchSize) {
        //进行参数的检查
        if (null == iterable) {
            throw new NullPointerException("iterable is null");
        }

        if (null == executor) {
            throw new NullPointerException("executor is null");
        }

        if (batchSize < 1) {
            throw new IllegalArgumentException("param batch size is < 1");
        }


        this.iterable = iterable;
        this.executor = executor;
        this.batchSize = batchSize;
    }

    @Override
    public void subscribe(Subscriber<? super T> s) {
        new SubscriberImpl(s).init();
    }


    /**
     * 用于处理订阅的信号
     */
    static interface Signal {
    }

    /**
     * 取消订阅的信号
     */
    enum Cancel implements Signal {
        Instance;
    }

    /**
     * 订阅的信号
     */
    enum Subscribe implements Signal {
        Instance;
    }

    /**
     * 发送的信号
     */
    enum Send implements Signal {
        Instance;
    }

    /**
     * 请求的信号
     */
    static final class Request implements Signal {
        final long n;

        public Request(long n) {
            this.n = n;
        }
    }

    /**
     * 订阅票据，实现了Subscription接口和Runnable接口
     */
    final class SubscriberImpl implements Subscription, Runnable {

        /**
         * Subscriber的引用，用于通信
         */
        private final Subscriber<? super T> subscriber;

        /**
         * 该订阅票据是否失效的标志
         */
        private boolean cancelled = false;

        /**
         * 记录订阅者的数量，这些请求还没有对订阅者回复
         */
        private long demand = 0;

        /**
         * 发送给订阅者的数据流
         */
        private Iterator<T> iterator;

        /**
         * 该队列用于记录发送票据的信号（入栈信号），如"request"，"cancel"等。
         * <p>
         * 通过此队列可以在Publisher端使用多线程异步处理
         */
        private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


        /**
         * 确保票据不会并发的标志，
         * <p>
         * 防止在调用订阅者的onXxx方法的时候并发调用。规范1.3规定的不能并发。
         */
        private final AtomicBoolean on = new AtomicBoolean(false);

        public SubscriberImpl(Subscriber<? super T> subscriber) {
            //根据规范，如果Subscriber为null，需要抛空指针异常，此处抛null。
            if (null == subscriber) {
                throw null;
            }

            this.subscriber = subscriber;
        }


        private void doRequest(int n) {
            // 规范规定，如果请求的元素个数小于1，则抛异常
            // 并在异常信息中指明错误的原因：n必须是正整数。
            if (n < 1) {
                terminateDueTo(new IllegalArgumentException(subscriber
                        + "violated the Reactive Streams rule 3.9 by requesting a non -positive number of elements."));
            }
            // 根据规范 3.17，当请求的元素数大于Long.MAX_VALUE的时候，将请求数  设置为Long.MAX_VALUE即可。
            else if (demand + n < 1) {
                //此认为是无界流
                demand = Long.MAX_VALUE;
                //开始向下游发送元素
                doSend();
            }
            //其他情况，表示当前是设置了正常请求数量
            else {
                //记录下请求个数的元素
                demand += n;
                //开始向下游发送元素
                doSend();
            }
        }


        private void doSend() {
            try {
                long leftBatchSize = batchSize;
                //为充分利用线程池，最多发送BatchSize个元素。然后放弃当前线程，重新调度，通知订阅者onNext信号
                do {
                    T next;
                    boolean hashNext;

                    try {
                        //订阅者在订阅的时候，已经调用了hashNext方法，直接获取
                        // Need to keep track of End-of-Stream
                        next = iterator.next();
                        //检查还有没有数据，如果没有了，表示流结束了
                        hashNext = iterator.hasNext();
                    } catch (final Throwable e) {
                        // If `next` or `hasNext` throws (they can, since  it is user - provided),we need to treat
                        // the stream as errored as per rule1.4

                        //如果next方法或者hashNext方法抛出异常（用户提供），认为流招聘了异常了发送onError信号
                        terminateDueTo(e);

                        return;
                    }

                    //向下流订阅者发送next的信号
                    subscriber.onNext(next);

                    //如果已经到达结束位置，
                    if (!hashNext) {
                        // We need to consider this `Subscription` as cancelled as per rule 1.6
                        // 首先考滤票据取消了订阅
                        doCancel();

                        // Then we signal `onComplete` as per rule 1.2 and    1.5
                        //发送onComplete信号给订阅者
                        subscriber.onComplete();
                    }

                } while (
                    //确保当前没有被取消订阅
                    // This makes  sure that rule 1.8 is upheld,
                    // i.e.we need to stop signalling "eventually"
                        !cancelled
                                //并且还有剩余的元素
                                // 如果还有剩余批次的元素。This   makes sure that we only send
                                // `batchSize`number of elements in one go (so  we can yield to other Runnables)
                                && --leftBatchSize > 0
                                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)
                                && --demand > 0);


                // 如果还有订阅者的请求。This  makes sure that rule 1.1 is upheld (sending more than was demanded)

                // If the `Subscription` is still alive and well,
                // and we have demand to satisfy, we signal ourselves to send more data

                // 如果订阅票据没有取消，还有请求，通知自己发送更多的数据
                if (!cancelled && demand > 0)
                    signal(Send.Instance);

            } catch (Throwable t) {

                // We can only get here if `onNext` or `onComplete` threw,
                // and they are not allowed to according to 2.13,
                // so we can only cancel and log here.

                // 如果到这里，只能是onNext或onComplete抛异常，只能取消。

                // Make sure that we are cancelled,
                // since we cannot do   anything else since the `Subscriber`is faulty.

                // 确保已取消，因为是Subscriber的问题
                doCancel();

                // 记录错误信息
                (new IllegalStateException(subscriber
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onNext or "
                        + "onComplete. ", t))
                        .printStackTrace(System.err);
            }
        }


        /**
         * 异常给认
         *
         * @param signal
         */
        private void signal(final Signal signal) {
            //将信号放入入栈队列
            if (inboundSignals.offer(signal)) {
                //信号放入线程成功，则调度线程进行处理
                tryScheduleToExecute();
            }
        }

        /**
         * 该方法确保订阅票据同一个时间在同一个线程运行
         * <p>
         * 规范1.3规定，调用`Subscriber`的`onSubscribe`，`onNext`，`onError`和 `onComplete`方法必须串行，不允许并发。
         */
        private final void tryScheduleToExecute() {

            // 使用原子变量进行CAS操作，成功，是说明当前线程可以处理，失败表示已经在处理了
            if (on.compareAndSet(false, true)) {
                try {
                    //向线程池中提交一个任务
                    executor.execute(this);
                    //如果不能提交线程池运行，则优雅的退出
                } catch (Throwable e) {
                    if (!cancelled) {
                        //错误不可恢复，执行取消订阅
                        doCancel();
                        try {
                            // 停止,发送error信号
                            terminateDueTo(new
                                    IllegalStateException("Publisher terminated due to unavailable Executor.",
                                    e));
                        } finally {
                            // 后续的入站信号不需要处理了，清空信号
                            inboundSignals.clear();
                            // 取消当前订阅票据，但是让该票据处于可调度状态，以防清空入站信号之后又有入站信号加入。  异步订阅者：
                            on.set(false);

                        }

                    }

                }
            }

        }


        /**
         * 规范3.5指明，Subscription.cancel方法必须及时的返回，保持调用者的响应性， 还必须是幂等的，必须是线程安全的。
         * <p>
         * 因此该方法不能执行密集的计算。
         */
        private void doCancel() {
            cancelled = true;
        }


        /**
         * 终止订阅，
         * <p>
         * 规范1.6指出，`Publisher`在通知订阅者`onError`或者`onComplete`信号之
         * 前，
         * <p>
         * **必须**先取消订阅者的订阅票据（`Subscription`）。
         * <p>
         * <p>
         * <p>
         * 当发送onError信号之前先取消订阅
         *
         * @param exception
         */
        private void terminateDueTo(Throwable exception) {
            //发送error前，必须取消订阅
            cancelled = true;

            try {
                //给下游发送onError信号
                subscriber.onError(exception);
            } catch (Throwable e) {
                // 规范1.9指出，onError不能抛异常。
                // 如果onError抛异常，只能记录信息。
                (new IllegalStateException(
                        subscriber +
                                "violated the  Reactive Streams rule 2.13 by throwing an exception from onError.", e))
                        .printStackTrace(System.err);
            }
        }


        @Override
        public void run() {
            // 与上次线程执行建立happens-before关系，防止并发执行
            // 如果on.get()为false，则不执行，线程退出
            // 如果on.get()为false，则表示没有线程在执行，当前线程可以执行
            if (on.get()) {
                //1,从队列中取出一个信号
                Signal poll = inboundSignals.poll();
                // 规范1.8：如果`Subscription`被取消了，则必须最终停止向`Subscriber`发送通知。
                // 规范3.6：如果取消了`Subscription`，则随后调用`Subscription.request( long n)`必须是无效的（NOPs）。
                // 如果订阅票据没有取消
                if (!cancelled) {
                    try {
                        //根据信号进行方法的处理操作
                        // 请求
                        if (poll instanceof Request) {
                            doRequest((int) ((Request) poll).n);
                        }
                        //发送信息
                        if (poll == Send.Instance) {
                            doSend();
                        }
                        //取消信号
                        if (poll == Cancel.Instance) {
                            doCancel();
                        }
                        //订阅信号
                        if (poll == Subscribe.Instance) {
                            doSubscribe();
                        }
                    } finally {
                        // 保证与下一个线程调度的happens-before关系
                        on.set(false);
                        //如果还有信号需要处理
                        if (!inboundSignals.isEmpty()) {
                            // 调度当前线程进行处理
                            tryScheduleToExecute();
                        }
                    }

                }
            }


        }

        /**
         * 不是在`Publisher.subscribe`方法中同步地调用`subscriber.onSubscribe` 方法，而是异步地执行subscriber.onSubscribe方法
         * <p>
         * 这样可以避免在调用线程执行用户的代码。因为在订阅者的onSubscribe方法中要执行 Iterable.iterator方法。
         * <p>
         * 异步处理也无形中遵循了规范的1.9。
         */
        private void doSubscribe() {
            try {
                //获取数据源的迭代器
                iterator = iterable.iterator();

                if (iterator == null) {
                    // 如果iterator是null，就重置为空集合的迭代器。我们假设 iterator永远不是null值。
                    iterator = Collections.<T>emptyList().iterator();
                }
            } catch (Throwable e) {
                // Publisher发生了异常，此时需要通知订阅者onError信号。
                // 但是规范1.9指定了在通知订阅者其他信号之前，必须先通知订阅者  onSubscribe信号。
                // 因此，此处通知订阅者onSubscribe信号，发送空的订阅票据
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {
                        // 空的
                    }

                    @Override
                    public void cancel() {
                        // 空的
                    }
                });
                // 根据规范1.9，通知订阅者onError信号
                terminateDueTo(e);
            }

            if (!cancelled) {
                try {
                    // 为订阅者设置订阅票据。
                    subscriber.onSubscribe(this);
                } catch (Throwable e) {
                    // Publisher方法抛异常，此时需要通知订阅者onError信号。
                    // 但是根据规范2.13，通知订阅者onError信号之前必须先取消该订阅 者的订阅票据。
                    // Publisher记录下异常信息。
                    terminateDueTo(new IllegalStateException(subscriber
                            + "violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe. ",
                            e));
                }

                // 立即处理已经完成的迭代器
                boolean hashNext = false;
                try {
                    // 判断是否还有未发送的数据，如果没有，则向订阅者发送onComplete 信号
                    hashNext = iterator.hasNext();
                } catch (Throwable e) {
                    // 规范的1.4规定
                    // 如果hasNext发生异常，必须向订阅者发送onError信号，发送信号之  前先取消订阅
                    // 规范1.2规定，Publisher通过向订阅者通知onError或 onComplete信号，
                    // 发送少于订阅者请求的onNext信号。
                    terminateDueTo(e);
                }


                // 如果没有数据发送了，表示已经完成，直接发送onComplete信号终止订阅 票据。
                // 规范1.3规定，通知订阅者onXxx信号，必须串行，不能并发。
                if (!hashNext) {
                    try {
                        // 规范1.6指明，在通知订阅者onError或onComplete信号之   前，必须先取消订阅者的订阅票据。
                        // 在发送onComplete信号之前，考虑一下，有可能是  Subscription取消了订阅。
                        doCancel();
                        subscriber.onComplete();
                    } catch (final Throwable t) {
                        // 规范2.13指出，onComplete信号不允许抛异常，因此此处只能 记录下来日志
                        (new IllegalStateException(subscriber
                                + " violatedthe Reactive Streams rule 2.13 by throwing an exception from onComplete.",
                                t)).printStackTrace(System.err);
                    }
                }
            }

        }

        /**
         * 注册订阅者发送过来的信号
         *
         * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
         */
        @Override
        public void request(final long n) {
            signal(new Request(n));
        }


        @Override
        public void cancel() {
            signal(Cancel.Instance);
        }

        /**
         * init方法的设置，用于确保SubscriptionImpl实例在暴露给线程池之前已经构造完成
         * <p>
         * 因此，在构造器一完成，就调用该方法，仅调用一次。
         * <p>
         * 先发个信号试一下
         */
        void init() {
            signal(Subscribe.Instance);
        }
    }
```

异步订阅者

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 自定义订阅者信息
 * <p>
 * 基于Executor的异步运行的订阅者实现，一次请求一个元素，然后对每个元素调用用户定义的方
 * 法进行处理。
 * 注意：该类中使用了很多try-catch用于说明什么时候可以抛异常，什么时候不可以抛异常
 *
 * @author liujun
 * @since 2023/6/30
 */
public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {

    /**
     * Signal表示发布者和订阅者之间的异步协议
     */
    private static interface Signal {
    }

    /**
     * 表示数据流发送完成，完成信号
     */
    private enum OnComplete implements Signal {
        Instance;
    }

    /**
     * 错误信号
     */
    private static class OnError implements Signal {
        public final Throwable error;

        public OnError(Throwable error) {
            this.error = error;
        }
    }

    /**
     * 表示下一个数据项信号
     *
     * @param <T>
     */
    private static class OnNext<T> implements Signal {
        private T next;

        public OnNext(T next) {
            this.next = next;
        }
    }

    /**
     * 表示订阅者的订阅成功信号
     */
    private static class OnSubscribe implements Signal {
        private Subscription subscription;

        public OnSubscribe(Subscription subscription) {
            this.subscription = subscription;
        }
    }


    /**
     * 订阅单据,根据规范3.1，该引用是私有的
     */
    private Subscription subscription;

    /**
     * 用于表示当前的订阅者是否处理完成
     */
    private boolean done;

    /**
     * 根据规范的2.2条款，使用该线程池异步处理各个信号
     */
    private final Executor executor;


    /**
     * 存储信号的队列
     */
    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<>();


    /**
     * 根据规范2.7和2.11，使用原子变量确保不会有多个订阅者线程并发执行。
     */
    private final AtomicBoolean on = new AtomicBoolean(false);


    /**
     * This method is invoked when the OnNext signals arrive
     * Returns whether more elements are desired or not, and if no more elements are   desired,
     * for convenience.
     *
     * @param element
     * @return
     */
    protected abstract boolean whenNext(final T element);

    /**
     * This method is invoked when the OnComplete signal arrives
     * override this method to implement your own custom onComplete logic.
     */
    protected void whenOnComplete() {
    }


    /**
     * This method is invoked if the OnError signal arrives
     * override this method to implement your own custom onError logic.
     */
    protected void whenOnError(Throwable e) {

    }


    /**
     * 仅有这一个构造器，只能被子类调用
     * 传递一个线程池即可
     *
     * @param executor
     */
    public AsyncSubscriber(Executor executor) {
        if (executor == null) {
            throw null;
        }
        this.executor = executor;
    }

    @Override
    public void run() {
        // 跟上次线程执行建立happens-before关系，防止多个线程并发执行
        if (on.get()) {
            try {
                //从队列中取出信号
                Signal poll = inboundSignals.poll();
                // 根据规范条款2.8，如果当前订阅者已完成，就不需要处理了。
                if (!done) {
                    //根据信号类型对应处理
                    if (poll instanceof OnNext) {
                        handleOnNext(((OnNext<T>) poll).next);
                    }
                    //订阅信号
                    else if (poll instanceof OnSubscribe) {
                        handleOnSubscribe(((OnSubscribe) poll).subscription);
                    }
                    //错误信号
                    else if (poll instanceof OnError) {
                        handleOnError(((OnError) poll).error);
                    }
                    //完成信号
                    else if (poll instanceof OnComplete) {
                        handleOnComplete();
                    }
                }
            } finally {
                //设置为false，让下一个线程可以调度。
                on.set(false);
                //队列中还存在数据，继续执行入队列信号
                if (!inboundSignals.isEmpty()) {
                    tryScheduleToExecute();
                }
            }
        }
    }

    /**
     * 调度放入线程池处理操作
     * 确保订阅者一次仅在一个线程执行
     */
    private void tryScheduleToExecute() {
        //原子CAS操作，将false改为true
        if (on.compareAndSet(false, true)) {
            try {
                //将任务提交线程池
                executor.execute(this);
            } catch (Throwable e) {
                // 根据规范条款2.13，如果不能执行线程池的提交方法，需要优雅退出
                if (!done) {
                    try {
                        // 由于错误不可恢复，因此取消订阅票据
                        done();
                    } finally {
                        //首先做队列的清空处理
                        inboundSignals.clear();
                        // 由于订阅票据已经取消，但是此处依然让订阅者处于可调度的状
                        //态，以防在清空入站信号之后又有信号发送过来
                        // 因为信号的发送是异步的
                        on.set(false);
                    }
                }
            }
        }
    }

    /**
     * 幂等地标记当前订阅者已完成处理，不再处理更多的元素。
     * 因此，需要取消订阅票据（Subscription）
     */
    private void done() {
        // 在此处，可以添加done，对订阅者的完成状态进行设置；
        // 虽然规范3.7规定Subscription.cancel()是幂等的，我们不需要这么做。
        // 当whenNext方法抛异常，认为订阅者已经处理完成（不再接收更多元素）
        done = true;
        // If we are bailing out before we got a `Subscription`there 's little need for cancelling it.
        if (subscription != null) {
            try {
                subscription.cancel();
            } catch (Throwable e) {
                // 根据规范条款3.15，此处不能抛异常，因此只是记录下来。
                (new IllegalStateException(subscription
                        + " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        e)).printStackTrace(System.err);
            }
        }
    }

    /**
     * Here it is important that we do not violate 2.2 and 2.3 by calling  methods on  the `Subscription`or `Publisher`
     * <p>
     * 完成信号处理
     */
    private void handleOnComplete() {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onError before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive  Streams rule 1.09 signalling onError prior "
                            + "to onSubscribe. ")).printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;

        //发送完成信号
        whenOnComplete();

    }

    /**
     * 错误信号处理
     *
     * @param error
     */
    private void handleOnError(Throwable error) {

        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            // Publisher is not allowed to signal onComplete before
            //onSubscribe according to rule 1.09
            (new IllegalStateException(
                    "Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe. "))
                    .printStackTrace(System.err);
        }

        // Obey rule 2.4
        done = true;
        //发送错误信号
        whenOnError(error);
    }

    /**
     * 订阅信号处理
     *
     * @param subscriptionTmp
     */
    private void handleOnSubscribe(Subscription subscriptionTmp) {
        if (subscriptionTmp == null) {
            // Getting a null `Subscription` here is not valid so lets just  ignore it.
            return;
        }

        //如果上一个订阅还存在，则需进要对当前信号做取消处理
        if (subscription != null) {
            try {
                subscriptionTmp.cancel();
            } catch (final Throwable t) {
                //Subscription.cancel is not allowed to throw an exception, according to rule 3.15
                (new IllegalStateException(subscriptionTmp +
                        " violated the Reactive Streams rule 3.15 by throwing an exception from cancel.",
                        t)).printStackTrace(System.err);
            }
            return;
        }


        //其他情况，表示正常，发送首个请求数据的信号
        subscription = subscriptionTmp;

        try {
            // If we want elements, according to rule 2.1 we need to
            //call `request`
            // And, according to rule 3.2 we are allowed to call this
            //synchronously from within the `onSubscribe`method
            subscription.request(1); // Our Subscriber is unbuffered and modest,
            //it requests one element at a time
        } catch (final Throwable t) {
            // Subscription.request is not allowed to throw according
            //to rule 3.16
            (new IllegalStateException(subscription
                    + " violated the Reactive Streams rule 3.16 by throwing an exception from request.",
                    t)).printStackTrace(System.err);
        }
    }

    /**
     * 处理数据
     *
     * @param element
     */
    private void handleOnNext(final T element) {
        // If we aren't already done
        if (done) {
            return;
        }
        // Technically this check is not
        if (subscription == null) {
            //needed, since we are expecting Publishers to conform to the spec
            //        // Check for spec violation of 2.1 and 1.09
            (new IllegalStateException(
                    "Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before  "
                            + "`Subscription.request`. (no Subscription)")).printStackTrace(System.err);
        }

        try {
            //如果数据还有下一条记录，则再次请求1条记录
            if (whenNext(element)) {
                try {
                    // Our Subscriber is
                    //unbuffered and modest, it requests one element at a time
                    subscription.request(1);
                } catch (Throwable e) {
                    // Subscription.request is not allowed to throw
                    //according to rule 3.16
                    (new IllegalStateException(subscription
                            + "violated the Reactive Streams rule 3.16 by throwing an exception from request."
                            + " ", e)).printStackTrace(System.err);
                }
            }
            //如果没有元素了，标识结束
            else {
                done();
            }
        } catch (Throwable e) {
            //当发生异常，标识当前完成
            done();
            //发送异常信息
            try {
                onError(e);
            } catch (Throwable ex) {
                //Subscriber.onError is not allowed to throw an
                //exception, according to rule 2.13
                (new IllegalStateException(this
                        + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.",
                        ex)).printStackTrace(System.err);
            }

        }


    }

    @Override
    public void onSubscribe(Subscription s) {
        // As per rule 2.13, we need to throw a `java.lang.NullPointerException`if the `Subscription`is `null`
        if (s == null) {
            throw null;
        }
        signal(new OnSubscribe(s));
    }

    private void signal(Signal signal) {
        // 信号入站，线程池调度处理
        // 不需要检查是否为null，因为已经实例化了。
        if (inboundSignals.offer(signal)) {
            //放入执行调度，立即执行
            tryScheduleToExecute();
        }
    }

    @Override
    public void onNext(T t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `element`is `null`
        if (t == null) {
            throw null;
        }

        signal(new OnNext<>(t));
    }

    @Override
    public void onError(Throwable t) {
        // As per rule 2.13, we need to throw a
        //`java.lang.NullPointerException`if the `Throwable`is `null`
        if (t == null) {
            throw null;
        }
        signal(new OnError(t));
    }

    @Override
    public void onComplete() {
        signal(OnComplete.Instance);
    }
}
```

单元测试

```java
import org.junit.Test;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class AsyncReactiveTest {

    @Test
    public void dataTest() throws InterruptedException {
        Set<Integer> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(i);
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<Integer> publisher
                = new AsyncIterablePublisher<>(elements, executorService);

        //同步订阅者的测试
        MySubscriber subscriberTmp = new MySubscriber();
        publisher.subscribe(subscriberTmp);


        ////异常订阅者的处理
        //final SelfSubscriber<Integer> subscriber = new SelfSubscriber<>
        //        (Executors.newFixedThreadPool(2)) {
        //    @Override
        //    protected boolean whenNext(Integer element) {
        //        System.out.println("接收到的流元素：" + element);
        //        return true;
        //    }
        //};
        //publisher.subscribe(subscriber);

        Thread.sleep(1000000);

    }


    public class MySubscriber implements Subscriber<Integer> {
        private Subscription sub;

        private int randNum = 5;


        @Override
        public void onSubscribe(Subscription s) {
            System.out.println("调用了订阅方法");
            sub = s;
            sub.request(1);
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("调用了onNext方法" + integer + ",rand:" + randNum);

            if (integer == 0 || (integer + 1) % randNum == 0) {
                System.out.println("再次request:" + randNum);
                sub.request(randNum);
            }
        }

        @Override
        public void onError(Throwable t) {
            System.out.println("错误处理:" + t);
        }

        @Override
        public void onComplete() {
            System.out.println("结束");
        }
    }

}
```

### 3.3 响应式流技术兼容套件

#### 3.3.1 TCK

响应式流看着比较简单，实际包含许多的隐藏陷阱。

除java接口外，该规范还包含许多针对实现的文档化规则。

这些规则严格限制每个接口，同时，保留规范中提到的所有行为至关重要。

开发人员需要一个可以验证所有行为并确保响应库标准化且想到兼容的通用工具。

Konrad Malawski 已经为此实现了一个工具包，其名称为响应式流技术兼容套件（Reactive  Streams Technology Compatibility Kit），简称为 TCK。

TCK是一组TestNG测试用例，需要对其进行扩展，并为相应的Publisher或者Subscriber准备验证。

首先还是引入maven坐标

```xml
<dependencies>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams</artifactId>
        <version>1.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.reactivestreams</groupId>
        <artifactId>reactive-streams-tck</artifactId>
        <version>1.0.3</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>6.9.10</version>
        <!--           <scope>test</scope>-->
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.16</version>
    </dependency>
</dependencies>
```

**发布者验证**

```java
import org.reactivestreams.Publisher;
import org.reactivestreams.tck.PublisherVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TckTest extends PublisherVerification<String> {


    public TckTest()
    {
        super(new TestEnvironment());
    }

    @Override
    public Publisher<String> createPublisher(long l) {

        Set<String> elements = new HashSet<>();
        for (int i = 0; i < 20; i++) {
            elements.add(String.valueOf(i));
        }
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncIterablePublisher<String> publisher
                = new AsyncIterablePublisher<>(elements, executorService);
        return publisher;
    }

    @Override
    public Publisher<String> createFailedPublisher() {

        Set elements = new HashSet<>();
        elements.add(new RuntimeException("手动异常"));

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        return new AsyncIterablePublisher<>(elements,executorService);
    }
}
```

只遵循上述测试用例配制，无法检查该Publisher的准确性，因为许多测试假设流中存在多个元素。

响应式流TCK考滤了这种极端情况，并支持设置一外名为maxElementsFromPublisher方法，该方法返回一个值，用于指定生成元素的最大数量。

```java
    @Override
    public long maxElementsFromPublisher() {
        //return super.maxElementsFromPublisher();
        return 10;
    }
```

一方面重写该方法可以跳过需要多个元素的测试，另一方面，响应式流规则的覆盖范围将减小，可能需要实现自定义测试用例。

**订阅者验证**

订阅者存在两种验证方式。黑盒验证和白盒验证。

首先看黑盒验证

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.tck.SubscriberBlackboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author nullnull
 * @since 2024/11/27
 */
public class TCKBlackBoxTest extends SubscriberBlackboxVerification<Integer> {


    protected TCKBlackBoxTest() {
        super(new TestEnvironment());
    }

    @Override
    public Subscriber<Integer> createSubscriber() {
        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);
        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素:" + element);
                //该返回为true，表示继续接收下一个元素，false表示不再请求了
                return true;
            }
        };
        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }

    //@Override
    //public void triggerRequest(Subscriber<? super Integer> subscriber) {
    //    //该方法直接向订阅者发送信号，默认该方法什么都不做
    //    AsyncSubscriber<Integer> subscriber1 = (AsyncSubscriber<Integer>) subscriber;
    //    subscriber1.onNext(100000);
    //}
}
```

该测试用例，可以模拟真实的用户活动。

再看白盒测试

```java
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.reactivestreams.tck.SubscriberWhiteboxVerification;
import org.reactivestreams.tck.TestEnvironment;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class TestWhiteBoxTest extends SubscriberWhiteboxVerification<Integer> {

    protected TestWhiteBoxTest() {
        super(new TestEnvironment());
    }


    @Override
    public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> whiteboxSubscriberProbe) {

        final ExecutorService executorService =
                Executors.newFixedThreadPool(5);

        AsyncSubscriber subscriber = new AsyncSubscriber(executorService) {
            @Override
            protected boolean whenNext(Object element) {
                System.out.println("接收到的元素：" + element);
                //返回true表示请求下一个元素，false表示不再请求
                return true;
            }

            @Override
            public void onSubscribe(Subscription subscription) {
                super.onSubscribe(subscription);
                whiteboxSubscriberProbe.registerOnSubscribe(new SubscriberPuppet() {
                    @Override
                    public void triggerRequest(long elements) {
                        subscription.request(elements);
                    }

                    @Override
                    public void signalCancel() {
                        subscription.cancel();
                    }
                });
            }

            @Override
            public void onNext(Object object) {
                super.onNext(object);
                whiteboxSubscriberProbe.registerOnNext((Integer) object);
            }

            @Override
            public void onError(Throwable t) {
                super.onError(t);
                whiteboxSubscriberProbe.registerOnError(t);
            }

            @Override
            public void onComplete() {
                super.onComplete();
                whiteboxSubscriberProbe.registerOnComplete();
            }
        };


        return subscriber;
    }

    @Override
    public Integer createElement(int i) {
        return i;
    }
}
```

createSubscriber方法实现与黑盒验证的工作方式相同，并返回Subscriber实例，但此处还有一个名为whiteboxSubscriberProbe的附加参数。

在这种情况下，whiteboxSubscriberProbe代表了一种机制，该机制实现对需求的嵌入式控制和输入信号的捕获。

与黑盒验证相比，通过正确的注册探测钩子，测试套件不仅能够发送需求，还能验证需求是否被满足以及所有元素是否被接受。同时，需求监控机制比以前更加透明。我们实现了subScriberPupper，它会为直接访问收到的Subscription进行适配。



同时TCK还提供 了processor的测试，此处略过。



## 4. 响应流的异步与并行

一方面，响应流的API中的规则 2.2和3.4规定，对由publisher生成并由Subscriber消费的所有信号的处理过程应该是非阻塞和非干扰的。

因此基于具体的执行环境，可以高效的利用处理器的一个节点和一个内核。

另一方面，所有处理器或者内核的高效利用需要并行化，对响应式流规范中的并行化概念的可以理解为对Subscrber#onNext方法的并行调用。

遗憾的是，规则 中的规则1.3规定，必须以线程安全的方式触发onXXX方法的调用，并且如果由多个线程执行，则使用外部同步，这一假定对所有OnXXX方法的串行化或者简单顺序调用。反过来，这意味着无法创建类型ParallelPublisher的组件并在流中对元素进行并行处理。

如果高效的利用资源，就必须分析常见了流处理管道。



![image-20241127122543496](.\images\image-20241127122543496.png)

一种解决方案是在阶段之间传递异步消息，对于基于内存的流处理而言，这意味着执行过程的一部分被绑定到了一个线程而另一部分被绑定到了另一个线程。

![image-20241127122804397](.\images\image-20241127122804397.png)

通常的做法是：两个独立 的线程之间拆分处理过程，在阶段之前放置异步边界。

又因为两个线程可以彼此独立地工作，所以通过这样做，将元素的整体处理过程并行化。为了实现并行化，必须应用一种数据结构（例如queue)来正确的解耦处理过程。

拆分线程之间的处理过程会导致数据结构中的额外的开销。当然，由于响应式流的规定，这样的数据结构是有界的。数据结构中的数据项数量通常等于Subscriber从其他Publisher请求的批处理的大小，而这取决于系统的一般容量。



![image-20241127123609250](.\images\image-20241127123609250.png)

每个处理阶段都可以绑定一个单犯的线程。



## 5. 响应式环境的转变

JDK9包含了响应式规范这一事实强调了该规范的重要性，并且该规范已经开始改变这个行业。

### 5.1 RxJava的转变

例如：一个应用程序把RxJava1.x和Observalbe作为组件之间的核心通信类型:

```java
interface LogService {
    Observable<String> stream();
}
```

遵循响应式流规范并从以下特定依赖中报出我们的接口

```java
interface LogService {
    Publisher<String> stream();
}
```

将RxJava2类型反向转换为响应式流兼容类型：

```java
Flowable.just(1, 2, 3)
   .map(String::valueOf)
   .toObservable()
   .toFlowable(BackpressureStrategy.ERROR)
   .subscribe();

```



### 5.2 Vert.x 的调整

为了遵循规范，Vert.x  包含一个额外的模块，该模块为响应式流 API 提供支持

```java
// ...
.requestHandler(request -> {
    ReactiveReadStream<Buffer> rrs = ReactiveReadStream.readStream();
    HttpServerResponse response = request.response();
    Flowable<Buffer> logs = 
Flowable.fromPublisher(logsService.stream()).map(Buffer::buffer)
       .doOnTerminate(response::end);
    logs.subscribe(rrs);
    response.setStatusCode(200);
    response.setChunked(true);
    response.putHeader("Content-Type", "text/plain");
    response.putHeader("Connection", "keep-alive");
    Pump.pump(rrs, response).start();
});
// ...
```

### 5.3 Ratpack的改进

```java
RatpackServer.start(server -> server.handlers(chain -> chain.all(ctx -> {
    Publisher<String> logs = logsService.stream();
    ServerSentEvents events = serverSentEvents(
        logs, event -> event.id(Objects::toString).event("log").data(Function.identity());
   );
    ctx.render(events);
})));
```

Patpack还提供了对规范接口的自身实现

```java
Publisher<String> logs = logsService.stream();
TransformablePublisher publisher = Streams.transformable(logs)
   .filter(this::filterUserSensitiveLogs)
   .map(this::escape);
```



## 6. Spring响应式编程

### 6.1 观察者模式

好像观察者模式似乎与响应式编程无关，但经过一些小改动，它定义了响应式编程的基础

![image-20241127125125558](.\images\image-20241127125125558.png)

**Subject接口**

```java

/**
 * Subject接口
 *
 * @author liujun
 * @since 2023/7/13
 */
public interface Subject {

    /**
     *  注册观察者
     */
    void registerObserver(Observer observer);

    /**
     * 解绑观察者
     *
     * @param observer
     */
    void unregisterObserver(Observer observer);

    /**
     * 通知事件变更
     *
     * @param event
     */
    void notifyObservers(String event);

}

```

**Observer接口**

```java

/**
 * Observer接口
 *
 * @author nullnull
 * @since 2023/7/13
 */
public interface Observer {

    void observe(String event);

}
```

**Subject实现类**

```java

import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteSubject implements Subject {

    /**
     * 保证Set是线程安全的
     */
    private Set<Observer> observers = new CopyOnWriteArraySet<>();

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void unregisterObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String event) {
        observers.forEach(observer -> observer.observe(event));
    }
}
```

Observer的实现类

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverA implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}

```

```java
/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ConcreteObserverB implements Observer {

    @Override
    public void observe(String event) {
        System.out.println(getClass().getCanonicalName() + " --- " + event);
    }
}
```

单元测试

```java
import org.junit.Test;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class ObserverTest {
    @Test
    public void dataTest() {
        Subject subject = new ConcreteSubject();
        Observer observer1 = new ConcreteObserverA();
        Observer observer2 = new ConcreteObserverB();
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);
        subject.notifyObservers("hello null null");
        System.out.println("==================================");
        subject.unregisterObserver(observer1);
        subject.notifyObservers("great null null");

    }
}

```

输出：

```java
com.nullnull.observer.ConcreteObserverA --- hello null null
com.nullnull.observer.ConcreteObserverB --- hello null null
==================================
com.nullnull.observer.ConcreteObserverB --- great null null
```

可以使用java8的lambda的特性:

```java
 @Test
    public void dataTestLambda() {
        Subject subject = new ConcreteSubject();
        subject.registerObserver(e -> System.out.println("A: " + e));
        subject.registerObserver(e -> System.out.println("B: " + e));
        subject.notifyObservers("This message will receive A & B");

        subject.notifyObservers("hello null null");
        System.out.println("==================================");

    }
```

输出:

```java
A: This message will receive A & B
B: This message will receive A & B
A: hello null null
B: hello null null
```



### 6.2 基于@EventListener注解的发布和订阅模式

实现一个简单的WEB服务，用于显示当前的温度。

![image-20241127222027473](.\images\image-20241127222027473.png)

**maven依赖**

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>


        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

**实体**

```java

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }
}

```

**TemperatureSensor类模拟传感器**

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    private final ApplicationEventPublisher publisher;

    private final Random random = new Random();

    private final ScheduledExecutorService service =
            Executors.newSingleThreadScheduledExecutor();

    public TemperatureSensor(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    @PostConstruct
    public void startProcessing() {
        this.service.schedule(this::probe, 1, TimeUnit.SECONDS);
    }

    private void probe() {
        double temperature = 16 + random.nextGaussian() * 10;
        System.err.println("发送事件。。。");
        // 通过ApplicationEventPublisher发布Temperature事件

        publisher.publishEvent(new Temperature(temperature));
        service.schedule(this::probe, random.nextInt(5000),
                TimeUnit.MILLISECONDS);
    }
}
```

**暴露SSE端点**

```java
import org.json.JSONObject;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author nullnull
 * @since 2023/7/13
 */
@RestController
public class TemperatureController {

    private final Set<SseEmitter> clients = new CopyOnWriteArraySet<>();

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {

        // ResponseBodyEmitter的子类，用于发送SSE（Server-Send Event）：服务器发送 的事件
        //    SseEmitter emitter = new SseEmitter();
        // 设置超时时间
        SseEmitter emitter = new SseEmitter(10000L);
        // 将当前发射器放到集合中
        clients.add(emitter);
        // 给当前发射器设置事件处理函数

        /*
        当异步请求超时的时候调用的代码。
        该方法在异步请求超时的时候由容器线程调用。
         */
        emitter.onTimeout(() -> clients.remove(emitter));
        /*
        当异步请求结束的时候调用的代码。
        当超时或网络错误而终止异步请求处理的时候，在容器线程调用该方法。
        该方法一般用于检车一个ResponseBodyEmitter实例已经无用了。
         */
        emitter.onCompletion(() -> clients.remove(emitter));
        return emitter;
    }

    /**
     * @param temperature
     * @Async // 异步事件处理
     * @EventListener // 事件监听器，该监听器只接收Temperature事件
     */
    @Async // 异步事件处理
    @EventListener // 事件监听器，该监听器只接收Temperature事件
    public void handleMessage(Temperature temperature) {
        System.out.println("监听到web的调度事件了 -- " + temperature);
        List<SseEmitter> deadEmitters = new ArrayList<>();
        // 遍历发射器集合
        clients.forEach(emitter -> {
            try {
                // 发射器发送温度对象，json类型
                final JSONObject jsonObject = new JSONObject(temperature);
                final String s1 = jsonObject.toString();
                emitter.send(s1);
            } catch (Exception ignore) {
                // 如果抛异常，则将该发射器放到deadEmitters集合中
                deadEmitters.add(emitter);
            }
        });
        // 从clients中移除所有失效的发射器。
        clients.removeAll(deadEmitters);
    }
}

```

**配制异步支持**

```java
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@Configuration
@EnableAsync
public class MyAsyncConfig implements AsyncConfigurer {
    // 为异步调用设置Executor
    @Override
    public Executor getAsyncExecutor() {
        // 使用包含两个核心线程的 ThreadPoolTaskExecutor，可以将核心线程增加到一百  个。
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(100);
        // 如果没有正确配置队列容量，线程池就无法增长。
        // 这是因为程序将转而使用 SynchronousQueue，而这限制了并发。
        executor.setQueueCapacity(5);
        executor.initialize();
        return executor;
    }
    // 为异步执行引发的异常配置异常处理程序。
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        // 此处仅记录异常
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

**入口程序配制**

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo10Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo10Application.class, args);
  }
}
```

resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```

启动服务

Demo10Application

访问网页

http://127.0.0.1:8080/

显示：

```tex
Connection opened
Temperature: 23.53 C
Temperature: 8.66 C
Temperature: 19.28 C
Connection closed
Connection opened
```

控制台输出：

```sh
发送事件。。。
2024-11-27 22:30:50.741  INFO 28324 --- [pool-1-thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@499ff586
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@1ad9aed1
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@6eed6b83
发送事件。。。
监听到web的调度事件了 -- com.nullnull.spring4observer.Temperature@141e43fa
```



### 6.3 使用RxJava作为响应式框架

官网地址：

```sh
http://reactivex.io/
```

ReactiveX通常被定义为观察者模式、迭代器模式和函数式编程的组合。

Java平台上有一个用于响应式编程的标准库，即RxJava，是Reactive Extensions(响应式扩展，也称为ReactiveX)的Java实现，目前它并不是唯一的响应式库，还是Akka Streams和Project Reactor.

随着2.x版本的发布，RxJava本身发生了很大的变化。

RxJava是迄今为止应用最广泛的响应式库。

这些API从该库的早期版本以来就没有发生改变。



#### 6.3.1 响应式流

使用Rxjava1.x版本实现生产者与消费者

maven坐标

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>


    <dependencies>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

代码

```java
    @Test
    public void rxjava1() {

        //创建发布者
        Observable<String> observable = Observable.create(
                new Observable.OnSubscribe<String>() {
                    @Override
                    public void call(Subscriber<? super String> subscriber) {
                        for (int i = 0; i < 10; i++) {
                            subscriber.onNext("hello null null " + i);
                        }
                        subscriber.onCompleted();
                    }
                });

        //创建订阅者
        observable.subscribe(new Subscriber<String>() {
            @Override

            public void onCompleted() {
                System.out.println("on completed");
            }

            @Override

            public void onError(Throwable throwable) {
                System.out.println("on error :" + throwable.getMessage());
            }

            @Override

            public void onNext(String s) {
                System.out.println("on next: " + s);
            }
        });
    }
```

控制台可以输出：

```java
on next: hello null null 0
on next: hello null null 1
on next: hello null null 2
on next: hello null null 3
on next: hello null null 4
on next: hello null null 5
on next: hello null null 6
on next: hello null null 7
on next: hello null null 8
on next: hello null null 9
on completed
```

创建一个Observable并使其带有一个回调，该回调将在订阅者出现时立即被触发。此时Observer将产生一个字符串值，交将流的结束信号发送给订阅者。

可以使用lambda改进下

```java
    @Test
    public void rxjava1Lambda() {
        //创建发布者，使用Lambda表达式
        Observable.create(
                        subscriber -> {
                            for (int i = 0; i < 10; i++) {
                                subscriber.onNext("hello null null " + i);
                            }
                            subscriber.onCompleted();
                        }
                )
                //指定了调用者
                .subscribe(
                        System.out::println,
                        System.err::println,
                        () -> System.out.println("结束")
                );

    }
```

还是同样的输出：

```tex
hello null null 0
hello null null 1
hello null null 2
hello null null 3
hello null null 4
hello null null 5
hello null null 6
hello null null 7
hello null null 8
hello null null 9
结束
```



#### 6.3.2 just方法

just用来引用元素，使用旧式数组、或者使用from，通过iterable集合创建observable实例

```java
    @Test
    public void testJust() {
        Observable<String> just = Observable.just("1", "2", "3", "4", "5");
        just.subscribe(
                item -> System.out.println(item),
                ex -> System.err.println(ex),
                () -> System.out.println("完成")
        );
    }
```

输出:

```tex
1
2
3
4
5
完成
```

使用from

```java
    @Test
    public void testFrom() {
        Observable<Integer> from = Observable.from(new Integer[]{1, 2, 3, 4, 5});
        from.subscribe(
                itm -> System.out.println("下一个元素是:" + itm),
                ex -> System.err.println("异常信息是:" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是:1
下一个元素是:2
下一个元素是:3
下一个元素是:4
下一个元素是:5
结束
```

#### 6.3.3 from方法

from甚至可以接收一个callable对象的返回。

```java
    @Test
    public void testFromCallable() {
        Observable<String> fromCallable = Observable.fromCallable(() -> "hello null null");

        fromCallable.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello null null
结束
```

或者接收一个Future对象

```java
    @Test
    public void testFeature() {
        Future<String> submit = Executors.newCachedThreadPool().submit(() -> "hello word");

        Observable<String> from = Observable.from(submit);

        from.subscribe(
                item -> System.out.println("下一个元素是：" + item),
                ex -> System.out.println("错误信息是：" + ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素是：hello word
结束
```



#### 6.3.4 concat方法

每个传入concat操作符会通过将每个数据项重新发送到下游观察者的方式来消费所有数据项。然后，传入流将被处理，直到发生终止操作（OnComplete()，OnError()），并且其处理顺序会与concat()方法中的顺序保持一致。

```java
    @Test
    public void testConcat() {
        Observable.concat(
                Observable.just("hello "),
                Observable.from(new String[]{"null null"}),
                Observable.just("!")
        ).forEach(
                item -> System.out.println("下一个元素：" + item),
                ex -> System.out.println(ex),
                () -> System.out.println("结束")
        );
    }
```

输出:

```tex
下一个元素：hello 
下一个元素：null null
下一个元素：!
结束
```

>注：虽然异常定义处理很方便，但在发生错误的情奖品下，默认的Subscriber实现仍会抛出`rx.exceptions.OnErrorNotImplementedException。`



#### 6.3.5 interval生成异步序列

RxJava不仅可以生成一个未来的事件，还可以基于时间间隔等生成一个异步事件的序列。

```java
    @Test
    public void testInterval() throws InterruptedException {
        Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素：" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成")
                );
        Thread.sleep(5000);
    }

```

输出：

```tex
下一个元素：0
下一个元素：1
下一个元素：2
下一个元素：3
下一个元素：4
```

每秒输出一人上元素。共5秒.

#### 6.3.6 取消订阅

取消订阅的接口:

```java
public interface Subscription {
    // 订阅取消
    void unsubscribe();
    // 检查 Subscriber是否仍在等待事件
    boolean isUnsubscribed();
}
```

为了便于理解这个取消订阅的接口，可以假调情况：订阅者是唯一对事件感兴趣的一方，并且订阅者会消费它，直到CountDownLatch发出一个外部信号。传入流每100毫秒生成一个新事件，而这些事件会产生无限序号，即0,1,2,3....，以下订阅以及取消订阅

```java
    @Test
    public void testUnsubscribe() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        Subscription subscribe = Observable.interval(1, TimeUnit.SECONDS)
                .subscribe(
                        item -> System.out.println("下一个元素:" + item),
                        ex -> System.err.println("异常:" + ex),
                        () -> System.out.println("完成:")
                );

        new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //如果订阅票据还在订阅状态，则取消订阅
            if (!subscribe.isUnsubscribed()) {
                subscribe.unsubscribe();
            }
            latch.countDown();
        }).start();

        System.out.println("主线程完成");
        latch.await();
        System.out.println("等待结束");
    }
```

输出:

```tex
主线程完成
下一个元素:0
下一个元素:1
等待结束
```

#### 6.3.7 map操作符

RxJava中最常用的操作符就是Map

```java
    /**
     * Returns an Observable that applies a specified function to each item emitted by the source Observable and
     * emits the results of these function applications.
     * <dl>
     *  <dt><b>Backpressure:</b></dt>
     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Observable}'s backpressure
     *  behavior.</dd>
     *  <dt><b>Scheduler:</b></dt>
     *  <dd>{@code map} does not operate by default on a particular {@link Scheduler}.</dd>
     * </dl>
     *
     * @param <R> the output type
     * @param func
     *            a function to apply to each item emitted by the Observable
     * @return an Observable that emits the items from the source Observable, transformed by the specified
     *         function
     * @see <a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>
     */
    public final <R> Observable<R> map(Func1<? super T, ? extends R> func) {
        return unsafeCreate(new OnSubscribeMap<T, R>(this, func));
    }
```

![image-20241128223247756](.\images\image-20241128223247756.png)

通过对每个数据项应用函数转换（Observable）发出的数据，map执行一对一转换。

输出流具有与输入流相同数量的元素。

```java
    /**
     * Map函数用于对象的转换操作
     */
    @Test
    public void map2() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.map(item -> {
            return item * 100;
        }).forEach(item -> System.out.println(item));
    }
```

输出：

```tex
100
200
300
400
500
600
```



#### 6.3.8 filter操作符

与map操作符相比，filter操作符所产生的元素可能少于它所接收的元素。它只发生那些已经成功通过谓词测试的元素：

![image-20241128223728825](.\images\image-20241128223728825.png)

代码

```java
    @Test
    public void filter() {
        Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
        just.filter(item -> {
            return item % 2 == 0;
        }).forEach(item -> System.out.println(item));
    }
```

输出:

```tex
2
4
6
```

#### 6.3.9 count操作符

count操作符自描述性很强，它发出的唯一值代表输入的元素数量。但是，count操作符只在原始流结束时发出结果，因此在处理无限流时，count操作符将不会完成或者返回任何内容：

![image-20241128224032199](.\images\image-20241128224032199.png)

样例：

```java
    @Test
    public void count() {
        List<Integer> dataList = new ArrayList<>(1000);

        for (int i = 0; i < 1000; i++) {
            dataList.add(i);
        }

        Observable.from(dataList)
                //过滤出偶数
                .filter(item -> item % 2 == 0)
                //计数
                .count()
                //输出
                .subscribe(
                        item -> System.out.println("结果计数:" + item)
                );
    }
```

```tex
结果计数:500
```

#### 6.3.10 zip操作符

该操作符具体更复杂的行为，因为它会通过应用zip函数来组合来自两个并行流的值。通常用于填充数据。具特别适合用于部分预期结果从不同源获取的情况：

![image-20241128224507365](.\images\image-20241128224507365.png)

样例代码

```java
    @Test
    public void zip() {
        Observable.zip(Observable.just(1, 2, 3, 4),
                        Observable.just("a", "b", "C", "D"),
                        (a, b) -> a + b)
                .forEach(System.out::println);

    }
```

输出：

```tex
1a
2b
3C
4D
```



#### 6.3.11 concatMap操作符

![image-20241129094319937](.\images\image-20241129094319937.png)





#### 更多

更多的响应式流的图片，可以查看：

```javascript
http://rxmarbles.com/
```

操作符的描述：

```javascript
https://reactivex.io/documentation/operators.html
```





### 6.4 Rxjava+SpringBoot

首先还是maven

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>flex_3_2</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <name>flex_3_2</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20200518</version>
        </dependency>


        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava2</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>2.2.20</version>-->
<!--        </dependency>-->
<!--        <dependency>-->
<!--            <groupId>io.reactivex.rxjava3</groupId>-->
<!--            <artifactId>rxjava</artifactId>-->
<!--            <version>3.0.7</version>-->
<!--        </dependency>-->
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

温度类的信息

```java
package com.nullnull.spring4observer2;

/**
 * @author nullnull
 * @since 2023/7/13
 */
public class Temperature {

    /**
     * 温度值
     */
    private final double value;

    public Temperature(double temperature) {
        this.value = temperature;
    }

    public double getValue() {
        return value;
    }

}

```

业务实现类

```java

import org.springframework.stereotype.Component;
import rx.Observable;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 业务实现类
 *
 * @author nullnull
 * @since 2023/7/13
 */
@Component
public class TemperatureSensor {
    /**
     * 随机数生成对象
     */
    private final Random random = new Random();

    private final Observable<Temperature> dataStream = Observable
            //随机生成0-int最大值的数
            .range(0, Integer.MAX_VALUE)
            //对以接收到的int数据做处理，Observable
            .concatMap(tick -> Observable.just(tick)
                    //随机延迟5秒内
                    .delay(random.nextInt(5000), TimeUnit.MILLISECONDS)
                    //将随机的流返回为Temperature对象
                    .map(tickKey -> this.probe())
                    //生成生产者
                    .publish()
                    // — 让一个可连接的Observable表现得像一个普通的Observable
                    .refCount()
            );

    private Temperature probe() {
        return new Temperature(16 + random.nextGaussian() * 10);
    }

    public Observable<Temperature> temperatureStream() {
        return dataStream;
    }
}
```

TemplateSensor 使用温度值暴露了一个流，通过使用TemperatureSensor, 可以将每个新的SseEmitter订阅到Observable流，并接收到onNext信号发送给SSE客户端

RxSseEmitter

```java
import org.json.JSONObject;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import rx.Subscriber;

import java.io.IOException;

/**
 * RxSseEmitter 负责从Subscriber接收到的数据转换为JSON响应客户端
 * @author nullnull
 * @since 2023/7/15
 */
public class RxSseEmitter extends SseEmitter {
    static final long SSE_SESSION_TIMEOUT = 30 * 60 * 1000L;
    private final Subscriber<Temperature> subscriber;

    public RxSseEmitter() {
        super(SSE_SESSION_TIMEOUT);
        //订阅一个流
        this.subscriber = new Subscriber<Temperature>() {
            @Override
            public void onNext(Temperature temperature) {
                try {
                    //将数据转换为JSON对象
                    final JSONObject jsonObject = new JSONObject(temperature);
                    final String temperatureJson = jsonObject.toString();
                    System.out.println(temperatureJson);
                    //数据输出
                    RxSseEmitter.this.send(temperatureJson);
                } catch (IOException e) {
                    unsubscribe();
                }
            }

            @Override
            public void onError(Throwable e) {
                System.err.println(e);
            }

            @Override
            public void onCompleted() {
                System.out.println("job done");
            }
        };
        onCompletion(subscriber::unsubscribe);
        onTimeout(subscriber::unsubscribe);
    }


    public Subscriber<Temperature> getSubscriber() {
        return subscriber;
    }
}
```

controller:

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.servlet.http.HttpServletRequest;

/**
 * @author nullnull
 * @since 2023/7/15
 */
@RestController
public class TemperatureController {

    private final TemperatureSensor temperatureSensor;

    public TemperatureController(TemperatureSensor temperatureSensor) {
        this.temperatureSensor = temperatureSensor;
    }

    @RequestMapping(value = "/temperature-stream", method =
            RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {
        RxSseEmitter emitter = new RxSseEmitter();
        //数据源对象生产数据，交给订阅者SseEmitter
        temperatureSensor.temperatureStream().subscribe(emitter.getSubscriber());
        return emitter;
    }
}

```

启动入口

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


/**
 * @author nullnull
 * @since 2023/7/13
 */
@SpringBootApplication
public class Demo12Application {
  public static void main(String[] args) {
    SpringApplication.run(Demo12Application.class, args);
  }
}

```

src/main/resources/static/index.html

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul id="events"></ul>
<script type="application/javascript">

  function add(message) {
    const el = document.createElement("li");
    el.innerHTML = message;
    document.getElementById("events").appendChild(el);
  }
  var eventSource = new EventSource("/temperature-stream");
  eventSource.onmessage = e => {
    const t = JSON.parse(e.data);
    const fixed = Number(t.value).toFixed(2);
    add('Temperature: ' + fixed + ' C');
  }
  eventSource.onopen = e => add('Connection opened');
  eventSource.onerror = e => add('Connection closed');
</script>
</body>
</html>
```



启动服务

```javascript
http://127.0.0.1:8080/
```

浏览器出现：

```tex
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```



浏览器访问：

```javascript
Connection opened
Temperature: 3.99 C
Temperature: 11.30 C
Temperature: 25.57 C
Temperature: 22.52 C
Temperature: 16.87 C
Connection closed
```

当没有订阅时，温度传感器不会探测数据，只有订阅后，才有数据返回。



### 6.5 Spring响应式编程

#### 6.5.1 Sping WebFlux

Spring Framework 5添加新模块`srping-web-reactive`,使用响应式非阻塞引擎支持类型Spring MVC的@controller编程模型

![image-20241129231123927](.\images\image-20241129231123927.png)

Spring web Reactive使用Servlet 3.1 非阻塞特性，也可以运行于非Servlet运行时，如Netty和Undertow等.

对每个运行时适配了一组公共的响应式`ServerHttpRequest`和`ServerHttpResponse`抽象，以`Flux<DataBuffer>`的形式暴露请求和响应，读写完全支持背压。

`spring-core`模块提供了`Encoder`和`Decoder`契约，用于对`Flux`的数据进行序列化和反序列化。

`spring-web`模块添加了JSON和XML的实现，用于web应用或其他SSE流和零拷贝文件传输。

`spring-web-reactive`模块包含了Spring Web Reactive框架以支持@controller编程模型。

重新定义了很多Spring MVC的契约，如`HandlerMapping`和`HandlerAdapter`以支持异步和非阻塞，响应式地操作HTTP的请求和响应。

Sping MVC和Sping Web Reactive不共享任何代码，处理逻辑有很多是共通的。

跟Spring MVC的编程模型一样，但是支持响应式的类型并且以响应式的方式执行。

下述类型都可以作为控制方法的@RequestBody参数来使用

- `Account account`-account在调用控制器之前非阻塞地反序列化。

- `Mono<Account> account`-控制使用`Mono`声明执行的逻辑，当account反序列化后执行。

- `Single<Account> account`-跟`Mono`一样，使用RxJava执行引擎。

- `Flux<Account> accounts`- 输入流场景

- `Observable<Account> accounts`-使用RxJava的输入流。

返回值类型

- `Mono<Account>`-当Mono结束，非阻塞地序列化给定的Account对象
- `Single<Account>`-跟Mono的一样，但是使用RxJava执行引擎。
- `Flux<Account>`-流场景，根据请求content type的不同，有可能是SSE
- `Flux<SseEvent>`-SSE流。
- `Observable<SseEvent>`-使用RxJava执行引擎的SSE流。
- `Mono<void>`-当Mono结束，请求处理结束。
- `void`-当方法返回。请求处理结束。表示同步、非阻塞的控制器方法。
- `Account`-非阻塞的序列化给定的Account，表示同步、非阻塞控制器方法。



#### 6.5.2 WebSocket

最知名的全双工客户端-服务器通信双工协议，即WebSocket。

WebSocket协议通信于2013年引入至Spring框架中，旨在进行异步消息发送，但其实际的实现仍然有一些阻塞操作。

例如，将数据写入I/O或者从I/O读取数据仍然是阻塞操作，因此这二者影响应用程序的性能。

WebFlux模块为WebSocket引入了改进版本的基础设施。WebFlux同时提供客户端和服务器基础设施。

**服务端WebSocket API**

WebFlux提供`webSocketHandler`作为处理WebSocket的连接的核心接口。

该接口有一个名为`handle`的方法，它接收`WebSocketSession`。`WebSocketSession`类表示客户端和服务器之间的成功握手，并提供包括有关握手、会话属性和传入数据流的信息和访问。

使用echo消息响应发送者的示例：

```java
class EchoWebSocketHandler implements WebSocketHandler{
    @Override
    public Mono<Void> handle(WebSocketSession session){
        return session.receive()
            .map(WebSocketMessage::getPayloadAsText)
            .map(tm -> "Echo:" + tm)
            .map(session::textMessage)
            .as(session::send);
    }
}
```

 此代码表示接收入站消息，并转换，然后封装为WebSocketMEssage对象，发送出去。其中发送返回Mono<Void>,当写出完成，该Mono完成。

WebSocketMessage是DataBuffer的包装器，它提供了额外功能，例如将以字节为单位的有效负载转换为文本。

一旦提取了传入消息，我们在该文本前加上“Echo.”后缀，将新文本消息包装在WebSocketMessage中，并使用WebSocketSession#Send方法将其发送回客户端。这里Send方法接受Publish<WebSocketMessage>并返回Mono<void>作为结果。

因此通过使用Reactor API中的as操作符，我们可以将Flux视作为Mono<Void>,并使用session::send作为转换函数。

**客户端 WebSocket API**

与WebSocket模块(基于WebMVC)不同，webFlux还为我们提供了客户端的支持。要发送WebSocket连接请坟，可以使用WebSocketClient类。

```java
public interface WebSocketClient {
    Mono<Void> execute(
   URI url,
        WebSocketHandler handler
   );
    Mono<Void> execute(
   URI url,
        HttpHeaders headers,
        WebSocketHandler handler
   );
}
```

**对比WebFlux WebSocket与Spring WebSocket模块**

Spring WebSocket模块的主要缺点是它阻塞了与I/O的交互，而Spring WebFlux提供了完全无阻塞的写入和读取。

WebFlux模块通过使用响应式流规范和Project Reactor提供了更好的流抽象，旧WebSocket模块中的WebSocketHandler接口只允许一次处理一条消息，此外WebSocketSession#SendMessage方法仅允许以同步方式发送消息。

旧Spring WebSocket模块的一个关键特性就是它与Spring Messaging模块的良好集成，而这能用@Message注解秋场景WebSocket端点。

```java
@Controller
public class GreetingController {
    @MessageMapping("/hello")
    @SendTo("/topic/greetings")
    public Greeting greeting(HelloMessage message) {
   return new Greeting("Hello, " + message.getName() + "!");
   }
}
```

上述代码展示了使用SpringMessaging模块声明的WebSocket端点，遗憾的是。WebFlux模块的WebSocket集成缺少此类支持，为了场景复杂的处理程序，必须提供自己的基础设施。

**作为WebSocket轻量级替代品的响应式SSE**

与重量级WebSocket一起，HTML5引入了一种创建静态连接的新方法，其中服务器能够推送事件。该技术解决了与WebSocket类似的问题。

SSE 不支持二进制编码并将事件限制为UTF-8 编码。这意味着WebSocket 可能对较小的消息 有用，并且在客户端和服务器之间传输的流量较少，因此具有较低的延迟。 

总而言之，SSE 通常是WebSocket 的一个很好的替代品。由于SSE 是HTTP 协议的抽象，因此 WebFlux 支持与典型REST 控制器相同的声明性函数式端点配置和消息转换

### 6.6 RSocket

Rsocket是一个应用通信协议，用于多路复用全双工通信中。可以TCP、WebSocket或其他字节流传输中使用，提供了如下交互模型：

- `Request-Response`-发送一个消息，接收一个消息
- `Request-Stream`-发一个消息，接收返回消息。
- `channel`-双向发送消息流。
- `Fire-and-Forget`-发送单向消息。

建立初始连接之后，就没有客户端服务端的概念了，因为双方地位对称，都可以初始化交互。因此Rocket中只有请求者或者响应者。而没有客户端和服务端的概念，交互称为“请求流”或者简单的称为“请求们”。

Rsocket关键特性和优势：

- 跨网络边界的响应式流定义-对于诸如“请求流”或者“通道”之类的流请求，背压信号在请求者和响应者之间传播，从而允许请求者放慢源处的响应者的速度，从而减少了对网络层拥塞控制的依赖以及在网络级别或者任何级别缓冲。
- Request throttling-可以从两端发送‘LEASE’帧，因此命名为'Leasing'，以及限定给时间内另一端允许的请求总数。租约定期更新。
- Session恢复-这是专为断开连接而设计，用于维护会话的状态。状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况停止生产者减少所需的状态量。
- 对于大消息的分隔和再组装。
- KeepAlived（心跳）

**协议**

Rsocket的优点之一是，它在线路上具有定义明确的行为，并且易于阅读的规范以及某些协议扩展。

**建立连接**

最初，客户端通过一些低级流传输(例如TCP或者UDP)连接到服务器，并向服务器发送"SETUP"帧以设置连接参数。

服务器可以拒绝“SETUP”帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非“SETUP”帧指示使用租凭语义来限制数量。在这种情况下，双方都必须等待另一方的“租约”帧以允许发出请求。

**发送请求**

一量建立连接，双方都可以通过帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一发起请求。这些帧中每一个都将一个消息从请求者传送到响应者。

响应者然后可以返回带有响应消息的“PAYLOAD”帧，并且在“REQUEST_CHANNEL”的情况下，请求者还可以发送带有更多请求消息的“PAYLOAD”帧发出信号。

每一端还可以通过“METADATA_PUSH”帧发送元数据通知，该元数据通知与任何单独请求无与，而与整个连接有关。



**消息格式**

Rsocket消息包含数据与元数据。元数据可以发送路由、安全令牌等。数据和元数据的格式可以不同。每个类的mime类型都在“SETUP”框架中声明，并应用于给定连接上的所有请求。

尽管所有消息都可以具有元数据，但通常每个请求都包含诸如路由之类的元数据，因此包含在请求的第一条消息中。即带有帧“REQUEST_RESPONSE”,"REQUEST_STREAM","REQUEST_CHANNEL","REQUEST_FNF"之一。

协议扩展定义了于用应用程序 的通用元数据格式：

- [composite Metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)-多个独立化的元数据条目。
- [Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)-请求的路由。



**java实现**

RSocket的java实现基于Project Reactor构建。TCP和WebScoket的传输建立在Reactor Netty之上。作为响应式库。Reactor简化了实现协议工作。对于应用程度，自然要配合使用带有声明性运算符和透明性背压支持的“Flux”和"Mono"

Spring Support  

 spring-messaging 模块包含如下内容：

 [RSocketRequester](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-requester) —流式API，使用 io.rsocket.RSocket 对数据和元数据编码解码，发起 请求。

 [Annotated Responders](https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-annot-responders) —  @MessageMapping 注解的用于处理请求的处理器方法

## Spring WebFlux核心原理

## 7. Project Reactor

### 7.1 Spring WebFlux与Project Reactor

Spring Framework从版本5开始，基于Project Reactor支持响应式编程。

Project Reactor是用于在JVM上构建非阻塞应用程序的Reactive库，基于Reactive Stream规范。

Project Reactor是生态系统中响应式的基础，并且与Spring密切合作进行开发。

Spring WebFlux要求Project Reactor作为核心依赖项。

**模块**

Project Reactor由Reactor文档中列出的一组模块组成。

主要组件是Reactor Core，其中包括响应类型Flux和它们实现了Reactive Stream的Publisher接口以及一组可应用于这些类型的运算符。

其中一些模块是：

`Reactor Test`——提供一些实用程序来测试响应流。

`Reactor Extra`——提供一些额外的Flux运算符。

`Reactor Netty`——无阻塞且支持背压的TCP，HTTP和UDP的客户端和服务器。

`Reactor Adapter`——用于与其他响应式（如Rxjava和Akka Streams）的适配。

`Reactor Kafka`——用于Kafka的响应式API，作为Kafka的消费者。

**并发模型**

有两种在响应式链中切换执行某些方式：`publishOn`和`subscribeOn`.

区别如下：

- publishOn（Scheduler scheduler）——响应所有后续运算符的执行（只要未指定其他任何内容）。
- subscribeOn(Schedule scheduler) ——根据链中最早的subscribeOn调用，更改整个操作符链所订阅的线程。它不影响随后对PublishOn的调用行为。

Schedulers类用于包含提供执行上下文的静态方法。

- `parallel()`——为并行工作而调整的固定线程池，可创建与CPU内核数量一样多的工作线程池。
- `single()`——单个可重用线程。此方法为所有调用方我不用同一线程，直到调度程序被释放为止。如果您希望按响应专用线程，则可以为每个呼叫使用Schedulers.newSingle()。
- `boundedElastic()`——动态创建一定数量的工作者，它限制了它可以支持线程的数量，并且在线程可用时重新调度要安排的任务。这是包装同步阻塞调用的不错选择。
- `immediate()`——立即在执行线程上运行，而不切换执行上下文。
- `fromExecutorService(ExecutorService)`——可用于从任何现有ExecutorService中创建调度程序。

### 7.2 Project Reactor 1.x 版本

通过与Spring框架的完美集成 以及与Netty的组合，非常适合开发具备异步和非阻塞消息处理的高性能系统。

Reactor 1.x的缺点：

1. 该库没有背夺控制。除了阻塞生产线线程或者跳过事件之外，事件驱动的Reacor 1.x并没有控制背压的方法。
2. 错误处理非常复杂。Reactor 1.x提供了几种错误处理和失败的方法。但使用比较复杂。

### 7.3 Project Reactor 2.x 版本

Reactor 2首开响应式流的先河

![image-20241201224830940](.\images\image-20241201224830940.png)

在Reacotr设计中，最重要的变化是将事件总线和流功能提供到单独的模块中。此外，深度的重新设计使新的Reacotr Stream库完全符合响应式流规范。Reactor团队大大改进了Reacotr的API。



### 7.4 Project Reactor 3.x版本

Reactor事件总线在2中得到了改进。首先负责发送消息的Reactor对象被重命名为EventBus，该模块也经过重新设计以支持响应式流规范。

Reactor3 以java8作为基线，同时Reactor 3.x塑造了Spring 5框架的响应式变种。

该库支持所有常见的背压传播模式：

1. 仅推送：当订阅者通过subscription.request(Long.Max_VALUE)请求有效无限数量的元素时。
2. 仅拉取：当订阅者通过subscription.request(1)仅在收到一个元素后请求下一个元素。
3. 推-拉（混合）当订阅者的实时控制需求，且发布者可以适应所提出的数据消费速度时。

为适配不支持推拉式操作的模型的旧API，Reactor提供了许多老式背压机制，包括缓冲、开窗、消息丢弃、启动异常等。

某些情况下，上述策略甚至可以用于实际需求出现之前预取数据，从而提高系统的响应性。

此外，Reactor API还提供了足够的工具用于消除用户活动的尖峰并防止系统过载。

Project Reactor在设计上脂在对并发透时，因此它不会强制执行任何并发模型。同时，它提供了一组有用的调度程序，它们几乎能以任何形式管理执行线程，如果所提出的所有调度程序都不符合要求，开发人员可以基于完全的低阶控制来创建自己的调度程序。

## 8.Project Reactor核心

### 8.1 在项目中添加Reactor

mavn依赖:

```xml
<dependencies>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <version>3.4.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 8.2 响应类型——Flux和Mono

响应流规范只定义了4个接口：

- Publisher<T>
- Subscriber<T>
- Subscription
- Processor<T,R>

Project Reactor提供了Publish<T>接口的实现，即Flux<T>和Mono<T>

**Flux**

Flux定义了一个通用的响应式流，它可以产生零个、一个或者多个元素，乃至无限元素。有公式

```sh
onNext x 0..N [OnError | OnComplete]
```

**Mono**

与Flux相比,Mono类型定义了一个最多可以生成一个元素的流。有公式如下

```sh
onNext x 0..1 [OnError | OnComplete]
```

当应用程序API最多返回一个元素时，可以使用Mono<T>

它可以轻松替换CompletableFuture<T>，并提供相似的语义，只不过completableFuture在没有发出值的情况下无法正常完成。

`CompletableFuture`全立即开始处理，而Mono在订阅者出现之前什么也不做。

Mono类型不仅提供了大量的响应式操作符，还能够整合到更大 的响应式工作流中。

当需要对已完成的操作通知客户端时，也可以使用Mono。此时可以返回`Mono<void>`类型并在处理完成时发出onComplete的信号，或者在发生异常时返回`onError()`,此时我们不返回任何数据，而发出通知信号，而该信号可以用作进一步计算的触发器。

Mono和Flux可以容易地想到转换。

如: `Flux<T>.collectLIst()`返回`Mono<List<T>>`，而`Mono<T>.flux()`返回`Flux<T>`

**RxJava2响应式类型**

即使RxJava2.x库和Project Reactor具有相同的基础，RxJava2还是有一组不同的响应式发布者。

由于这两个库实现了相同的理念，包含响应操作符、线程管理和错误处理，都非常的相似。因此、或者或少熟悉其中一个库意味着同时熟悉了这两个库。

Rxjava1.x中最初只有`Observable`这一个响应式类型，之后又添加了`Single`和`Completable`类型。

在版本2.具体以下响应式类型：

- `Observable`
- `Flowable`
- `Single`
- `Maybe`
- `Completable`

1. **Observable**

   1. 与Rxjava1.x的Observable语义几乎相同，但是不接收`null`值。
   2. `Observable`即不支持背压，也不实现Publisher接口，所以它与响应式流规范不直接兼容。
   3. Observable类型的开销小于Flowable类型。
   4. 它具有toFlowable方法，可以通过用户选择的背压策略将流转换为Flowable。

2. **Flowable**

   1. Flowable类型是Reactor Flux类型的直接对应物。
   2. 实现了响应式流的Publisher，可以应用由Project Reactor实现的响应式工作流中。困为API消费PUblisher类型的参数，而不是针对特定的Flux类型。

3. **Single**

   1. Single类型表示生成仅生成一个元素的流。
   2. 不继承Publisher接口。
   3. 具有toFlowable方法。
   4. 不需要背压策略。
   5. 相较于Reactor中的Mono类型，Single更好地表示了CompletableFuture的主义。但是在订阅发生之前它仍不会开始处理。

4. **Maybe**

   1. 实现了与Reactor中的Mono类型相同的语义，但是不兼容响应式流，因为Maybe不实现Publisher接口。
   2. 具有toFlowable方法，以兼容响应式流规范。

5. **Completable**

   1. 只能触发OnError或者OnComplete信号，但不能产生OnNext信号。
   2. 不实现Publisher接口，但是具有toFlowable方法。
   3. 它对应不能生成OnNext信号的Mono<Void>类型。

   

   总而言之，要与其他兼容响应式流的代码集成，应将RxJava类型转换为Flowable类型。

   

   

   

   ### 8.3 创建Flux和Mono序列

   Flux和Mono提供了许多工厂方法，可以根据已有的数据流创建响应流。
   
   如：可以使用对象引用或集合创建Flux，甚至可以简单地用数字范围来创建。
   
   ```java
     /**
        * 使用元素进行构建
        */
       @Test
       public void just() {
           Flux<String> just = Flux.just("hello", "nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   ```
   
   使用数组构建
   
   ```java
       @Test
       public void fromArray() {
           Flux<String> arrayFlux = Flux.fromArray(new String[]{"hello", "nullnull", "dd"});
           arrayFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   hello
   nullnull
   dd
   ```
   
   使用集合构建
   
   ```java
       @Test
       public void fromIterable() {
           Flux<Integer> interFlux = Flux.fromIterable(Arrays.asList(1, 2, 3, 4, 5));
           interFlux.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   1
   2
   3
   4
   5
   ```
   
   使用range生成
   
   ```java
       @Test
       public void range() {
           Flux<Integer> range = Flux.range(100, 5);
           range.subscribe(System.out::println);
       }
   ```
   
   输出:
   
   ```tex
   100
   101
   102
   103
   104
   ```

   

   **创建Mono序列**
   
   Mono提供类似的工厂方法，但订针对单个元素。它经常与nullable类型和Optional类型一起使用。
   
   ```java
       @Test
       public void just()
       {
           Mono<String> just = Mono.just("nullnull");
           just.subscribe(System.out::println);
       }
   ```
   
   输出:

   ```tex
   nullnull
   ```
   
   使用`justOrEmpty`
   
   ```java
       @Test
       public void justOrEmpty() {
           Mono<String> objectMono = Mono.justOrEmpty(null);
           objectMono.subscribe(System.out::println);
       }
   ```

   此啥也不会输出
   
   避免空指针，使用Option对象
   
   ```java
       @Test
       public void justOrEmptyOption()
       {
           Mono<String> objectMono = Mono.justOrEmpty(Optional.empty());
           objectMono.subscribe(System.out::println);
       }
   ```

   同样的，这个啥也不会输出.
   
   点击`justOrEmpty`方法的源码发现，以上两种参数调用，都是同一个方法，在内部做了判断。
   
   ```java
   	public static <T> Mono<T> justOrEmpty(@Nullable Optional<? extends T> data) {
   		return data != null && data.isPresent() ? just(data.get()) : empty();
   	}
   ```

   同时Mono对于包装异步操作非常有用。
   
   Mono提供了：
   
   - `fromCallable(Callable)`
   - `fromRunnable(Runnable)`
   - `fromSupplier(Supplier)`
   - `fromFuture(CompletableFuture)`
   - `fromCompletionStage(CompletionStage)`
   
   样例：使用Mono包装Http请求：
   
   ```java
       @Test
       public void monoHttpRequest() throws IOException {
           Mono.fromCallable(() -> httpRequest()).subscribe(System.out::println);
       }
   
       @Test
       public void monoHttpRequestLambda() {
           Mono.fromCallable(this::httpRequest).subscribe(System.out::println);
       }
   
       private String httpRequest() throws IOException {
           URL url = new URL("https://www.baidu.com");
           URLConnection urlConnection = url.openConnection();
           urlConnection.connect();
   
           try (InputStream inputStream = urlConnection.getInputStream();
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);) {
               String tmp = null;
   
               StringBuilder result = new StringBuilder();
   
               while ((tmp = bufferedReader.readLine()) != null) {
                   result.append(tmp).append("\n");
               }
   
               return result.toString();
           } catch (IOException e) {
               throw e;
           }
       }
   ```
   
   输出：
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   ```
   
   带有error以及完成的信号处理
   
   ```java
       /**
        * 异常及完成信号处理
        */
       @Test
       public void monoHttpRequestLambdaFull() {
           Mono.fromCallable(this::httpRequest).subscribe(
                   item -> System.out.println(item),
                   ex -> System.out.println("异常信息:" + ex.toString()),
                   () -> System.out.println("请求完成")
           );
       }
   ```
   
   输出:
   
   ```tex
   <!DOCTYPE html>
   <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc>
   ......
   </body> </html>
   请求完成
   ```

   Flux和Mono都可以使用`from(Publish<T> p)`工厂方法适配任何其他Publisher实例。
   
   flux使用Publisher
   
   ```java
       @Test
       public void publisher() {
           Flux.from((subscriber) -> {
                       for (int i = 0; i < 10; i++) {
                           subscriber.onNext("hello" + i);
                       }
                       subscriber.onComplete();
                   })
                   .subscribe(
                           System.out::println,
                           System.out::println,
                           () -> System.out.println("处理结果")
                   );
       }
   ```
   
   输出：
   
   ```tex
   hello0
   hello1
   hello2
   hello3
   hello4
   hello5
   hello6
   hello7
   hello8
   hello9
   处理结果
   ```
   
   两种响应式类型都提供了简单的方法来创建常用的空流以及只包含错误的流：
   
   ```java
           //empty工厂方法，它们分别生成Flux或者Mono的空实例。
           Flux<String> empty = Flux.empty();
           //never方法创建一个永远不会发出完成、数据、或者错误等信号的流
           Flux<String> never = Flux.never();
           //error(Throwable)工厂方法创建一个序列，该序列在订阅时始终通过每个订阅者的onError(....)方法传播错误。
           // 由于错误是在Flux或者Mono声明期间被创建，因此每个订阅者都会收到相同的Throwable实例。
           Mono<String> error = Mono.error(new RuntimeException("错误对象"));
   ```
   
   defer工厂方法创建一个序列，并在订阅时决定其行为，可以为不同的订阅者生成 不同的数据：
   
   ```java
      public boolean isValidSeed(String seed) {
           System.out.println("调用了isValidSeed方法");
           return true;
       }
   
       public String getData(String seed) {
           try {
               System.out.println("方法执行：5s");
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           return "echo:" + seed;
       }
   
       public Mono<String> requestData(String seed) {
           if (isValidSeed(seed)) {
               return Mono.fromCallable(() -> getData(seed));
           } else {
               return Mono.error(new RuntimeException("Invalid seed value"));
           }
       }
   
       public Mono<String> requestDeferData(String seed) {
           Mono<String> data;
           if (isValidSeed(seed)) {
               data = Mono.fromCallable(() -> getData(seed));
           } else {
               data = Mono.error(new RuntimeException("Invalid seed value"));
           }
           return Mono.defer(() -> data);
       }
   
       /**
        * 仅调用requestData方法
        */
       @Test
       public void request() {
           requestData("nullnull");
       }
   
       /**
        * 调用requestDeferData方法不订阅
        */
       @Test
       public void requestDeferData() {
           requestDeferData("nullnull");
       }
   
       /**
        * 调用requestDeferData并订阅
        */
       @Test
       public void requestDeferDataSubscribe() {
           requestDeferData("nullnull").subscribe();
       }
   ```

   首先执行`request`
   
   可以看到输出:

   ```java
   调用了isValidSeed方法
   ```

   而`getData`方法并未被触发执行

   
   
   再执行`requestDeferData`方法

   ```java
   调用了isValidSeed方法
   ```

   还是同样的结果，仅仅仅证方法被执行，而`getData`方法并未被触发执行

   
   
   最后执行带有订阅的方法`requestDeferDataSubscribe`
   
   ```tex
   调用了isValidSeed方法
   方法执行：5s
   ```
   
   此时`getData`方法，在被订阅后，被执行。

总结：

1. Project Reactor只需要使用`just`方法枚举元素就可以创建Flux和Mono序列。
2. 可以使用justOrEmpty轻松的将Optional包装到Mono中，或者使用fromSupplier方法将Supplier包装到Mono中。
3. 可以使用fromFuture方法映射Future，或者使用fromRunnable工厂方法映射Runnable.
4. 可以使用fromArray或者fromIterator方法将数组或者Iterator集合转换为Flux流。



### 8.4 订阅响应式流

Flux和Mono提供对subscribe()方法基于lambda的重载，简化了订阅的开发。

subscribe方法的所有重载都返回Disposable接口的实例，可以用于取消基础的订阅过程。

在重载方法1-4中，订阅发出无界数据（Long.MAX_VALUE）的请求。

注意：简单订阅请求无界数据（Long.MAX_VALUE）的选项有时可能迫使生产者完成大量工作以满足需求。因此，如果生产者适合处理有界数据，建议使用订阅对象或者应用请求限制操作符来控制需求。

```java
//重载方法1
//订阅流的最简单的方法，忽略所有信号，通常用于触发具有副作用的流处理。
public final Disposable subscribe();


//重载方法2
//对每个值(onNext信号)调用DataCompsumer，不处理OnError和onComplete信号
public final Disposable subscribe(Consumer<? super T> consumer);

//重载方法3
//与重载方法2相同，处理OnError信号，忽略onComplete信号
public final Disposable subscribe(@Nullable Consumer<? super T> consumer, Consumer<? super Throwable> errorConsumer) 
    
    
//重载方法4
//与方法3相同，处理onComplete信号。
public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer) ;

//重载方法5
//消费响应式流中所有元素，包括错误处理和完成信号，重要的是，这种重载方法能通过请求足够数量的数据来控制订阅，当然请求数量仍然可以是Long.MAX_VALUE.
	public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer,
			@Nullable Consumer<? super Subscription> subscriptionConsumer);

//重载方法6,此方法最通用，但很少被用到
//订阅序列的通用方法，可以为Subscribe的实现提供所需的行为
public final void subscribe(Subscriber<? super T> actual) ;

```

subscribe案例1

```java
    @Test
    public void subscribe() {
        Flux.just("hello", "nullnull", "kk")
                .subscribe(
                        data -> System.out.println("onNext:" + data),
                        ex -> System.out.println("异常信息:" + ex),
                        () -> System.out.println("完成信号")
                );
    }
```

subscribe最基本的用法,输出:

```tex
onNext:hello
onNext:nullnull
onNext:kk
完成信号
```

添副作用

```java
    @Test
    public void subscribeDoOnNext() {
        Flux.range(10, 20)
                //过滤能被5整除的数
                .filter(item -> item % 5 == 0)
                //数据转换，添加前缀v，并转换为字符串
                .map(num -> "v->" + num)
                // 添副作用,用于在发送新的数据项之前执行一些操作，但它不改变数据流本身
                .doOnNext(System.out::println)
                .subscribe();
    }
```

输出:

```tex
v->10
v->15
v->20
v->25
```

**只处理正常情况**

```java
    @Test
    public void subscribeOk() {
        Flux.range(1, 20)
                .filter(item -> item % 4 == 0)
                .subscribe(System.out::println);
    }
```

输出：

```tex
4
8
12
16
20
```

**添加异常处理**

```java
    @Test
    public void subscribeException() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onError(new IllegalArgumentException("添加错误"));
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex)
        );
    }
```

输出:

```tex
tem:0
item:1
item:2
item:3
item:4
异常情况:java.lang.IllegalArgumentException: 添加错误
```

**添加完成事件**

```java
    @Test
    public void subscribeFinish() {
        Flux.from(subscriber -> {
            for (int i = 0; i < 5; i++) {
                subscriber.onNext(i);
            }
            subscriber.onComplete();
            ;
        }).subscribe(item -> System.out.println("item:" + item),
                ex -> System.out.println("异常情况:" + ex),
                () -> System.out.println("处理完成")
        );
    }
```

输出：

```tex
item:0
item:1
item:2
item:3
item:4
处理完成
```

**订阅成功就取消**

```java
    @Test
    public void subscribeCancel() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        //一订阅成功就取消订阅
                        subscription -> subscription.cancel()
                );
    }
```

控制台没有任何的输出

**订阅指定数量**

```java
    @Test
    public void subscribeRequest() {
        Flux.range(1, 20)
                .subscribe(item -> System.out.println("onNext:" + item),
                        ex -> System.out.println("异常情况:" + ex),
                        () -> System.out.println("处理完成"),
                        subscription -> {
                            //订阅响应式流5个元素
                            subscription.request(5);
                            //取消订阅
                            subscription.cancel();
                        }
                );
    }
```

输出：

```tex
onNext:1
onNext:2
onNext:3
onNext:4
onNext:5
```

此处没有收到onComplete信号，因为订阅者在流完成之前取消了订阅。

注意：

1. 响应式流可以由生产者完成（使用onError或者OnComplete信号）
2. 响应流也可以由订阅者完成，通过Subscription实例进行取消。
3. Disposable实例也可用于取消。





## 结束
